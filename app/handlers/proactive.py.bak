from __future__ import annotations

import re
from datetime import time

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from typing import Any


from app.models.user import User

router = Router()

@router.callback_query(F.data == "assistant:proactive:open")
async def proactive_open(call: CallbackQuery, session: Any, user: User, lang: str):
    # –ø—Ä–æ—Å—Ç–æ –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–∫—Ä–∞–Ω –Ω–∞—Å—Ç—Ä–æ–µ–∫ (—Ç–æ—Ç –∂–µ, —á—Ç–æ –±—ã–ª —Ä–∞–Ω—å—à–µ –ø–æ –∫–Ω–æ–ø–∫–µ "ü§ñ –ü–æ–º–æ—â–Ω–∏–∫")
    # –µ—Å–ª–∏ —É —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã/—ç–∫—Ä–∞–Ω–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π –µ—ë —Ç—É—Ç.
    # –ù–∏–∂–µ ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π fallback: –≤—ã–∑—ã–≤–∞–µ–º show_proactive_menu –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å.
    if "show_proactive_menu" in globals():
        await show_proactive_menu(call.message, session, user, lang)  # type: ignore
        await call.answer()
        return
    await call.message.answer("‚ö°Ô∏è –ü—Ä–æ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: —ç–∫—Ä–∞–Ω –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω (–Ω–µ—Ç show_proactive_menu).")
    await call.answer()



_TIME_RE = re.compile(r"^\s*(\d{1,2}):(\d{2})\s*$")

class ProactiveStates(StatesGroup):
    waiting_time = State()


def _fmt_time(t: time | str | None) -> str:
    if t is None:
        return "‚Äî"
    if isinstance(t, str):
        return t
    return f"{t.hour:02d}:{t.minute:02d}"


def _kb(u: User):
    b = InlineKeyboardBuilder()

    m_on = "‚úÖ –í–∫–ª" if u.morning_auto else "‚õîÔ∏è –í—ã–∫–ª"
    e_on = "‚úÖ –í–∫–ª" if u.evening_auto else "‚õîÔ∏è –í—ã–∫–ª"

    b.button(text=f"‚òÄÔ∏è –£—Ç—Ä–æ: {m_on}", callback_data="assistant:proactive:toggle:morning")
    b.button(text=f"üïò –í—Ä–µ–º—è —É—Ç—Ä–∞: {_fmt_time(u.morning_time)}", callback_data="assistant:proactive:set_time:morning")

    b.button(text=f"üåô –í–µ—á–µ—Ä: {e_on}", callback_data="assistant:proactive:toggle:evening")
    b.button(text=f"üïò –í—Ä–µ–º—è –≤–µ—á–µ—Ä–∞: {_fmt_time(u.evening_time)}", callback_data="assistant:proactive:set_time:evening")

    b.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu:home")  # –µ—Å–ª–∏ —É —Ç–µ–±—è –¥—Ä—É–≥–æ–µ ‚Äî –ø–æ–º–µ–Ω—è–µ—à—å
    b.adjust(1)
    return b.as_markup()


async def _get_user(session: AsyncSession, tg_id: int) -> User:
    u = (await session.execute(select(User).where(User.tg_id == tg_id))).scalar_one()
    return u


@router.message(F.text == "‚ö°Ô∏è –ü—Ä–æ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å")
async def proactive_entry(message: Message, session: AsyncSession, lang: str = "ru"):
    u = await _get_user(session, message.from_user.id)
    await message.answer(
        "ü§ñ **–ü—Ä–æ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å**\n"
        "–ù–∞—Å—Ç—Ä–æ–π —É—Ç—Ä–µ–Ω–Ω–∏–π briefing –∏ –≤–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω.\n\n"
        "–í–∞–∂–Ω–æ: –µ—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω–æ ‚Äî –±–æ—Ç —Å–∞–º –Ω–µ –ø–∏—à–µ—Ç.",
        reply_markup=_kb(u),
        parse_mode="Markdown",
    )


@router.callback_query(F.data.startswith("assistant:proactive:toggle:"))
async def proactive_toggle(cb: CallbackQuery, session: AsyncSession):
    u = await _get_user(session, cb.from_user.id)

    _, _, part = cb.data.split(":")  # morning/evening
    if part == "morning":
        u.morning_auto = not bool(u.morning_auto)
    elif part == "evening":
        u.evening_auto = not bool(u.evening_auto)

    await session.commit()

    await cb.message.edit_reply_markup(reply_markup=_kb(u))
    await cb.answer("–û–∫")


@router.callback_query(F.data.startswith("assistant:proactive:set_time:"))
async def proactive_set_time(cb: CallbackQuery, state: FSMContext):
    _, _, part = cb.data.split(":")  # morning/evening
    await state.set_state(ProactiveStates.waiting_time)
    await state.update_data(part=part)

    await cb.message.answer(
        f"üïò –í–≤–µ–¥–∏ –≤—Ä–µ–º—è –¥–ª—è **{('—É—Ç—Ä–∞' if part=='morning' else '–≤–µ—á–µ—Ä–∞')}** –≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM\n"
        "–ü—Ä–∏–º–µ—Ä: 09:30\n\n"
        "–û—Ç–º–µ–Ω–∞: /cancel",
        parse_mode="Markdown",
    )
    await cb.answer()

@router.message(ProactiveStates.waiting_time)
async def proactive_time_input(message: Message, session: AsyncSession, state: FSMContext):
    txt = (message.text or "").strip()

    if txt.lower() in ("/cancel", "cancel", "—Å—Ç–æ–ø", "stop"):
        await state.clear()
        await message.answer("–û–∫, –æ—Ç–º–µ–Ω–∏–ª.")
        return

    m = _TIME_RE.match(txt)
    if not m:
        await message.answer("‚ùå –§–æ—Ä–º–∞—Ç –Ω–µ —Ç–æ—Ç. –í–≤–µ–¥–∏ HH:MM, –Ω–∞–ø—Ä–∏–º–µ—Ä 09:30. –ò–ª–∏ /cancel")
        return

    hh = int(m.group(1))
    mm = int(m.group(2))
    if not (0 <= hh <= 23 and 0 <= mm <= 59):
        await message.answer("‚ùå –í—Ä–µ–º—è –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞. –í–≤–µ–¥–∏ 00:00‚Äì23:59. –ò–ª–∏ /cancel")
        return

    data = await state.get_data()
    part = data.get("part")

    u = await _get_user(session, message.from_user.id)

    new_t = time(hh, mm)

    if part == "morning":
        u.morning_time = new_t
        u.morning_auto = True
        u.morning_last_sent_at = None  # —á—Ç–æ–±—ã –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è —Å—Ä–∞–±–æ—Ç–∞–ª–æ —Å–µ–≥–æ–¥–Ω—è
    else:
        u.evening_time = new_t
        u.evening_auto = True
        u.evening_last_sent_at = None

    await session.commit()
    await state.clear()

    await message.answer(
        f"‚úÖ –ü–æ—Å—Ç–∞–≤–∏–ª –≤—Ä–µ–º—è: {hh:02d}:{mm:02d}\n"
        f"{'‚òÄÔ∏è –£—Ç—Ä–æ –≤–∫–ª—é—á–µ–Ω–æ' if part=='morning' else 'üåô –í–µ—á–µ—Ä –≤–∫–ª—é—á–µ–Ω'}"
    )
    await message.answer("–û—Ç–∫—Ä–æ–π ü§ñ –ü–æ–º–æ—â–Ω–∏–∫ ‚Äî —É–≤–∏–¥–∏—à—å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏.")