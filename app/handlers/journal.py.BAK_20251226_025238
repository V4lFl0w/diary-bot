from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Optional

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, text as sql_text

from app.models.user import User
from app.models.journal import JournalEntry
from app.keyboards import (
    get_main_kb,
    is_journal_add_btn,
    is_history_btn,
    is_today_btn,
    is_week_btn,
    is_search_btn,
    is_range_btn,
    is_stats_btn,
)

# premium trial hook (–º—è–≥–∫–∏–π, –Ω–µ –ª–æ–º–∞–µ–º –µ—Å–ª–∏ –º–æ–¥—É–ª—è –Ω–µ—Ç)
try:
    from app.handlers.premium import maybe_grant_trial
except Exception:
    async def maybe_grant_trial(*a, **k):
        return False

# feature-gates
try:
    from app.services.features_v2 import require_feature_v2
except Exception:
    async def require_feature_v2(*a, **k):
        return True


router = Router(name="journal")


class JournalFSM(StatesGroup):
    waiting_text = State()


SUPPORTED_LANGS = {"ru", "uk", "en"}


def _normalize_lang(code: Optional[str]) -> str:
    """
    –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —è–∑—ã–∫–∞ –∫ ru/uk/en.
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç ua, uk-UA, en-US, ru-RU –∏ —Ç.–ø.
    """
    s = (code or "ru").strip().lower()
    # –±–µ—Ä—ë–º –±–∞–∑–æ–≤—ã–π –ø—Ä–µ—Ñ–∏–∫—Å –¥–æ –¥–µ—Ñ–∏—Å–∞
    base = s.split("-")[0]

    if base in ("ua", "uk"):
        return "uk"
    if base == "en":
        return "en"
    if base == "ru":
        return "ru"
    return "ru"


def _tr(lang: Optional[str], ru: str, uk: str, en: str) -> str:
    l = _normalize_lang(lang)
    if l == "uk":
        return uk
    if l == "en":
        return en
    return ru


async def _get_user(session: AsyncSession, tg_id: int) -> Optional[User]:
    return (
        await session.execute(select(User).where(User.tg_id == tg_id))
    ).scalar_one_or_none()


def _user_lang(user: Optional[User], fallback: Optional[str]) -> str:
    raw = (
        getattr(user, "locale", None)
        or getattr(user, "lang", None)
        or fallback
        or "ru"
    )
    return _normalize_lang(str(raw))


def _now_utc() -> datetime:
    return datetime.now(timezone.utc)


def _user_tz(user: Optional[User]):
    tz_name = getattr(user, "tz", None) or "Europe/Kyiv"
    try:
        from zoneinfo import ZoneInfo
        return ZoneInfo(tz_name)
    except Exception:
        return timezone.utc


def _is_premium_user(user: Optional[User]) -> bool:
    if not user:
        return False

    # 1) —Ñ–ª–∞–≥
    try:
        if bool(getattr(user, "is_premium", False)):
            return True
    except Exception:
        pass

    # 2) premium_until
    pu = getattr(user, "premium_until", None)
    if pu:
        try:
            if pu.tzinfo is None:
                pu = pu.replace(tzinfo=timezone.utc)
            return pu > _now_utc()
        except Exception:
            return False

    return False


# --- admin check (best-effort) ---
try:
    from app.handlers.admin import is_admin_tg  # type: ignore
except Exception:  # pragma: no cover
    def is_admin_tg(_: int) -> bool:
        return False


def _is_admin_user(user: Optional[User], tg_id: Optional[int] = None) -> bool:
    """
    –ö–∞–Ω–æ–Ω–∏—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω–∞:
    1) –ø–æ tg_id —á–µ—Ä–µ–∑ is_admin_tg (–≥–ª–∞–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã)
    2) fallback –Ω–∞ –ø–æ–ª–µ user.is_admin (–µ—Å–ª–∏ –≥–¥–µ-—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å)
    """
    try:
        if tg_id and is_admin_tg(int(tg_id)):
            return True
    except Exception:
        pass

    try:
        return bool(getattr(user, "is_admin", False)) if user else False
    except Exception:
        return False


def _main_kb_for(user: Optional[User], lang: str, *, tg_id: Optional[int] = None):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ get_main_kb:
    - –ø—Ä–µ–º–∏—É–º —Å—á–∏—Ç–∞–µ–º –ø–æ _is_premium_user(user)
    - –∞–¥–º–∏–Ω —Å—á–∏—Ç–∞–µ–º —á–µ—Ä–µ–∑ is_admin_tg(tg_id) (–∞ –Ω–µ —Ç–æ–ª—å–∫–æ user.is_admin)
    """
    is_premium = _is_premium_user(user)
    is_admin = _is_admin_user(user, tg_id=tg_id)

    try:
        return get_main_kb(lang, is_premium=is_premium, is_admin=is_admin)
    except TypeError:
        try:
            return get_main_kb(lang, is_premium=is_premium)
        except TypeError:
            return get_main_kb(lang)


def _policy_ok(user: Optional[User]) -> bool:
    """
    –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:
    - policy_accepted (—Å—Ç–∞—Ä—ã–π/–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–ª–∞–≥)
    - consent_accepted_at (–µ—Å–ª–∏ —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å)
    """
    if not user:
        return False

    try:
        if bool(getattr(user, "policy_accepted", False)):
            return True
    except Exception:
        pass

    return bool(getattr(user, "consent_accepted_at", None))


# -------------------- –±–∞–∑–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã/–∫–Ω–æ–ø–∫–∏ --------------------

@router.message(Command("journal"))
@router.message(F.text.func(is_journal_add_btn))
async def journal_prompt(
    m: Message,
    state: FSMContext,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not _policy_ok(user):
        await m.answer(
            _tr(
                loc,
                "–ù—É–∂–Ω–æ –ø—Ä–∏–Ω—è—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É: –Ω–∞–∂–º–∏ üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
                "–ü–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫—É: –Ω–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
                "You need to accept the policy: tap üîí Privacy",
            ),
            reply_markup=_main_kb_for(user, loc, tg_id=m.from_user.id),
        )
        return

    await state.set_state(JournalFSM.waiting_text)
    await m.answer(
        _tr(
            loc,
            "–ù–∞–ø–∏—à–∏ 2‚Äì3 –º—ã—Å–ª–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n\n/cancel ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å",
            "–ù–∞–ø–∏—à–∏ 2‚Äì3 –¥—É–º–∫–∏ –∑–∞ —Å—å–æ–≥–æ–¥–Ω—ñ –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.\n\n/cancel ‚Äî —Å–∫–∞—Å—É–≤–∞—Ç–∏",
            "Send 2‚Äì3 thoughts for today in one message.\n\n/cancel ‚Äî cancel",
        )
    )


@router.message(JournalFSM.waiting_text, Command("cancel"))
@router.message(Command("cancel"))
async def journal_cancel(
    m: Message,
    state: FSMContext,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    await state.clear()
    await m.answer(
        _tr(
            loc,
            "–û—Ç–º–µ–Ω–∏–ª. –ó–∞–ø–∏—Å—å –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.",
            "–°–∫–∞—Å—É–≤–∞–≤. –ó–∞–ø–∏—Å –Ω–µ –∑–±–µ—Ä–µ–∂–µ–Ω–æ.",
            "Cancelled. Entry not saved.",
        ),
        reply_markup=_main_kb_for(user, loc, tg_id=m.from_user.id),
    )


@router.message(JournalFSM.waiting_text, F.text)
async def journal_save(
    m: Message,
    state: FSMContext,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not user:
        await state.clear()
        await m.answer(
            _tr(loc, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"),
            reply_markup=_main_kb_for(None, loc, tg_id=m.from_user.id),
        )
        return

    if not _policy_ok(user):
        await state.clear()
        await m.answer(
            _tr(
                loc,
                "–ù—É–∂–Ω–æ –ø—Ä–∏–Ω—è—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É: –Ω–∞–∂–º–∏ üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
                "–ü–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫—É: –Ω–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
                "You need to accept the policy: tap üîí Privacy",
            ),
            reply_markup=_main_kb_for(user, loc, tg_id=m.from_user.id),
        )
        return

    text = (m.text or "").strip()
    if len(text) < 3:
        await m.answer(
            _tr(
                loc,
                "–ö–æ—Ä–æ—Ç–∫–æ–≤–∞—Ç–æ. –î–æ–±–∞–≤—å –¥–µ—Ç–∞–ª–µ–π –∏ –æ—Ç–ø—Ä–∞–≤—å –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
                "–ó–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫–æ. –î–æ–¥–∞–π –¥–µ—Ç–∞–ª–µ–π —ñ –Ω–∞–¥—ñ—à–ª–∏ –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.",
                "Too short. Add a bit more detail and send again in one message.",
            )
        )
        return

    entry = JournalEntry(user_id=user.id, text=text)
    session.add(entry)
    await session.commit()

    try:
        await maybe_grant_trial(session, m.from_user.id)
    except Exception:
        pass

    await state.clear()

    total = (
        await session.execute(
            select(func.count())
            .select_from(JournalEntry)
            .where(JournalEntry.user_id == user.id)
        )
    ).scalar() or 0

    await m.answer(
        _tr(
            loc,
            f"–°–æ—Ö—Ä–∞–Ω–∏–ª. –ó–∞–ø–∏—Å–µ–π –≤—Å–µ–≥–æ: {total}.\n\n"
            "–ë—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –µ—Å—Ç—å –≤ –º–µ–Ω—é.\n"
            "–ü—Ä–µ–º–∏—É–º —Ä–∞—Å—à–∏—Ä—è–µ—Ç: –ø–æ–∏—Å–∫, –¥–∏–∞–ø–∞–∑–æ–Ω—ã, —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.",
            f"–ó–±–µ—Ä—ñ–≥. –ó–∞–ø–∏—Å—ñ–≤ –≤—Å—å–æ–≥–æ: {total}.\n\n"
            "–®–≤–∏–¥–∫—ñ –¥—ñ—ó —î –≤ –º–µ–Ω—é.\n"
            "–ü—Ä–µ–º—ñ—É–º —Ä–æ–∑—à–∏—Ä—é—î: –ø–æ—à—É–∫, –¥—ñ–∞–ø–∞–∑–æ–Ω–∏, —Ä–æ–∑—à–∏—Ä–µ–Ω—É —ñ—Å—Ç–æ—Ä—ñ—é —Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.",
            f"Saved. Total entries: {total}.\n\n"
            "Quick actions are in the menu.\n"
            "Premium expands: search, ranges, extended history and stats.",
        ),
        reply_markup=_main_kb_for(user, loc, tg_id=m.from_user.id),
    )


# -------------------- stats --------------------

@router.message(Command("stats"))
@router.message(F.text.func(is_stats_btn))
async def journal_stats(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not user:
        await m.answer(_tr(loc, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))
        return

    ok = await require_feature_v2(m, session, user, "journal_stats")
    if not ok:
        return

    total = (
        await session.execute(
            select(func.count())
            .select_from(JournalEntry)
            .where(JournalEntry.user_id == user.id)
        )
    ).scalar() or 0

    # --- trial events (7d) ---
    trial_click = trial_granted = trial_denied = 0
    try:
        since = _now_utc() - timedelta(days=7)
        rows = (await session.execute(
            sql_text("""
                SELECT name, COUNT(*) AS cnt
                FROM events
                WHERE created_at >= :since
                  AND name IN ('trial_click','trial_granted','trial_denied')
                GROUP BY name
            """),
            {"since": since},
        )).fetchall()

        mp = {str(n): int(c) for (n, c) in rows}
        trial_click = mp.get("trial_click", 0)
        trial_granted = mp.get("trial_granted", 0)
        trial_denied = mp.get("trial_denied", 0)
    except Exception:
        try:
            await session.rollback()
        except Exception:
            pass

    msg = _tr(
        loc,
        f"–ó–∞–ø–∏—Å–µ–π –≤—Å–µ–≥–æ: {total}. –ü—Ä–æ–¥–æ–ª–∂–∞–π –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!\n\n"
        f"üéÅ Trial (7d):\n"
        f"‚Ä¢ trial_click: {trial_click}\n"
        f"‚Ä¢ trial_granted: {trial_granted}\n"
        f"‚Ä¢ trial_denied: {trial_denied}",
        f"–ó–∞–ø–∏—Å—ñ–≤ –≤—Å—å–æ–≥–æ: {total}. –ü—Ä–æ–¥–æ–≤–∂—É–π —É —Ç–æ–º—É –∂ –¥—É—Å—ñ!\n\n"
        f"üéÅ Trial (7d):\n"
        f"‚Ä¢ trial_click: {trial_click}\n"
        f"‚Ä¢ trial_granted: {trial_granted}\n"
        f"‚Ä¢ trial_denied: {trial_denied}",
        f"Total entries: {total}. Keep it up!\n\n"
        f"üéÅ Trial (7d):\n"
        f"‚Ä¢ trial_click: {trial_click}\n"
        f"‚Ä¢ trial_granted: {trial_granted}\n"
        f"‚Ä¢ trial_denied: {trial_denied}",
    )

    await m.answer(msg)


# -------------------- today --------------------

@router.message(Command("today"))
@router.message(F.text.func(is_today_btn))
async def journal_today(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not user:
        await m.answer(_tr(loc, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))
        return

    tz = _user_tz(user)
    now = _now_utc().astimezone(tz)
    since = now - timedelta(days=1)

    q = (
        select(JournalEntry)
        .where(JournalEntry.user_id == user.id)
        .where(JournalEntry.created_at >= since.astimezone(timezone.utc))
        .order_by(JournalEntry.created_at.desc())
    )
    rows = (await session.execute(q)).scalars().all()

    if not rows:
        await m.answer(
            _tr(
                loc,
                "–ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞ –∑–∞–ø–∏—Å–µ–π –Ω–µ –±—ã–ª–æ.",
                "–ó–∞ –æ—Å—Ç–∞–Ω–Ω—ñ 24 –≥–æ–¥–∏–Ω–∏ –∑–∞–ø–∏—Å—ñ–≤ –Ω–µ –±—É–ª–æ.",
                "No entries in the last 24 hours.",
            )
        )
        return

    lines: list[str] = []
    for e in rows:
        dt_local = e.created_at
        if dt_local.tzinfo is None:
            dt_local = dt_local.replace(tzinfo=timezone.utc)
        dt_local = dt_local.astimezone(tz)
        snippet = (e.text or "").strip()
        if len(snippet) > 80:
            snippet = snippet[:77] + "‚Ä¶"
        lines.append(f"{dt_local:%Y-%m-%d %H:%M} ‚Äî {snippet}")

    header = _tr(
        loc,
        "–ó–∞–ø–∏—Å–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞:",
        "–ó–∞–ø–∏—Å–∏ –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ 24 –≥–æ–¥–∏–Ω–∏:",
        "Entries for the last 24 hours:",
    )
    await m.answer(header + "\n\n" + "\n".join(lines))


# -------------------- history --------------------

@router.message(Command("history"))
@router.message(F.text.func(is_history_btn))
async def journal_history(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not user:
        await m.answer(_tr(loc, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))
        return

    tz = _user_tz(user)

    parts = (m.text or "").split()
    requested: Optional[int] = None
    if len(parts) > 1 and parts[1].isdigit():
        requested = max(1, min(50, int(parts[1])))

    limit = 5
    if requested and requested > 5:
        ok = await require_feature_v2(m, session, user, "journal_history_extended")
        if not ok:
            return
        limit = requested
    elif requested:
        limit = requested

    q = (
        select(JournalEntry)
        .where(JournalEntry.user_id == user.id)
        .order_by(JournalEntry.created_at.desc())
        .limit(limit)
    )
    rows = (await session.execute(q)).scalars().all()

    if not rows:
        await m.answer(
            _tr(
                loc,
                "–ó–∞–ø–∏—Å–µ–π –ø–æ–∫–∞ –Ω–µ –±—ã–ª–æ.",
                "–ó–∞–ø–∏—Å—ñ–≤ –ø–æ–∫–∏ –Ω–µ –±—É–ª–æ.",
                "No entries yet.",
            )
        )
        return

    lines: list[str] = []
    for e in rows:
        dt_local = e.created_at
        if dt_local.tzinfo is None:
            dt_local = dt_local.replace(tzinfo=timezone.utc)
        dt_local = dt_local.astimezone(tz)
        snippet = (e.text or "").strip()
        if len(snippet) > 80:
            snippet = snippet[:77] + "‚Ä¶"
        lines.append(f"{dt_local:%Y-%m-%d %H:%M} ‚Äî {snippet}")

    header = _tr(
        loc,
        f"–ü–æ—Å–ª–µ–¥–Ω–∏–µ {len(rows)} –∑–∞–ø–∏—Å–µ–π:",
        f"–û—Å—Ç–∞–Ω–Ω—ñ {len(rows)} –∑–∞–ø–∏—Å—ñ–≤:",
        f"Last {len(rows)} entries:",
    )
    await m.answer(header + "\n\n" + "\n".join(lines))


# -------------------- search --------------------

@router.message(Command("search"))
@router.message(F.text.func(is_search_btn))
async def journal_search(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not user:
        await m.answer(_tr(loc, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))
        return

    ok = await require_feature_v2(m, session, user, "journal_search")
    if not ok:
        return

    parts = (m.text or "").split(maxsplit=1)
    if len(parts) < 2 or not parts[1].strip():
        await m.answer(
            _tr(
                loc,
                "–§–æ—Ä–º–∞—Ç: /search —Å–ª–æ–≤–æ",
                "–§–æ—Ä–º–∞—Ç: /search —Å–ª–æ–≤–æ",
                "Format: /search word",
            )
        )
        return

    query_text = parts[1].strip()

    q = (
        select(JournalEntry)
        .where(JournalEntry.user_id == user.id)
        .where(JournalEntry.text.ilike(f"%{query_text}%"))
        .order_by(JournalEntry.created_at.desc())
        .limit(10)
    )
    rows = (await session.execute(q)).scalars().all()

    if not rows:
        await m.answer(
            _tr(
                loc,
                "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à—ë–ª –ø–æ —ç—Ç–æ–º—É –∑–∞–ø—Ä–æ—Å—É.",
                "–ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π—à–æ–≤ –∑–∞ —Ü–∏–º –∑–∞–ø–∏—Ç–æ–º.",
                "No matches found.",
            )
        )
        return

    tz = _user_tz(user)
    lines: list[str] = []
    for e in rows:
        dt_local = e.created_at
        if dt_local.tzinfo is None:
            dt_local = dt_local.replace(tzinfo=timezone.utc)
        dt_local = dt_local.astimezone(tz)
        snippet = (e.text or "").strip()
        if len(snippet) > 90:
            snippet = snippet[:87] + "‚Ä¶"
        lines.append(f"{dt_local:%Y-%m-%d %H:%M} ‚Äî {snippet}")

    await m.answer(
        _tr(
            loc,
            "–ù–∞—à—ë–ª –≤–æ—Ç —á—Ç–æ:",
            "–ó–Ω–∞–π—à–æ–≤ –æ—Å—å —â–æ:",
            "Here‚Äôs what I found:",
        ) + "\n\n" + "\n".join(lines)
    )


# -------------------- range --------------------

@router.message(Command("range"))
@router.message(F.text.func(is_range_btn))
async def journal_range(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not user:
        await m.answer(_tr(loc, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))
        return

    ok = await require_feature_v2(m, session, user, "journal_range")
    if not ok:
        return

    parts = (m.text or "").split()
    if len(parts) < 3:
        await m.answer(
            _tr(
                loc,
                "–§–æ—Ä–º–∞—Ç: /range YYYY-MM-DD YYYY-MM-DD",
                "–§–æ—Ä–º–∞—Ç: /range YYYY-MM-DD YYYY-MM-DD",
                "Format: /range YYYY-MM-DD YYYY-MM-DD",
            )
        )
        return

    try:
        start = datetime.fromisoformat(parts[1]).replace(tzinfo=timezone.utc)
        end = datetime.fromisoformat(parts[2]).replace(tzinfo=timezone.utc) + timedelta(days=1)
    except Exception:
        await m.answer(
            _tr(
                loc,
                "–ù–µ –ø–æ–Ω—è–ª –¥–∞—Ç—ã. –ü—Ä–∏–º–µ—Ä: /range 2025-12-01 2025-12-06",
                "–ù–µ –∑—Ä–æ–∑—É–º—ñ–≤ –¥–∞—Ç–∏. –ü—Ä–∏–∫–ª–∞–¥: /range 2025-12-01 2025-12-06",
                "Invalid dates. Example: /range 2025-12-01 2025-12-06",
            )
        )
        return

    q = (
        select(JournalEntry)
        .where(JournalEntry.user_id == user.id)
        .where(JournalEntry.created_at >= start)
        .where(JournalEntry.created_at < end)
        .order_by(JournalEntry.created_at.desc())
        .limit(50)
    )
    rows = (await session.execute(q)).scalars().all()

    if not rows:
        await m.answer(
            _tr(
                loc,
                "–í —ç—Ç–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ –∑–∞–ø–∏—Å–µ–π –Ω–µ –±—ã–ª–æ.",
                "–£ —Ü—å–æ–º—É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ –∑–∞–ø–∏—Å—ñ–≤ –Ω–µ –±—É–ª–æ.",
                "No entries in this range.",
            )
        )
        return

    tz = _user_tz(user)
    lines: list[str] = []
    for e in rows:
        dt_local = e.created_at
        if dt_local.tzinfo is None:
            dt_local = dt_local.replace(tzinfo=timezone.utc)
        dt_local = dt_local.astimezone(tz)
        snippet = (e.text or "").strip()
        if len(snippet) > 90:
            snippet = snippet[:87] + "‚Ä¶"
        lines.append(f"{dt_local:%Y-%m-%d %H:%M} ‚Äî {snippet}")

    await m.answer(
        _tr(
            loc,
            "–ó–∞–ø–∏—Å–∏ –∑–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥:",
            "–ó–∞–ø–∏—Å–∏ –∑–∞ –≤–∏–±—Ä–∞–Ω–∏–π –ø–µ—Ä—ñ–æ–¥:",
            "Entries for the selected period:",
        ) + "\n\n" + "\n".join(lines)
    )


# -------------------- week --------------------

@router.message(Command("week"))
@router.message(F.text.func(is_week_btn))
async def journal_week(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
):
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    loc = _user_lang(user, lang)

    if not user:
        await m.answer(_tr(loc, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))
        return

    tz = _user_tz(user)
    now = _now_utc().astimezone(tz)
    since = now - timedelta(days=7)

    q = (
        select(JournalEntry)
        .where(JournalEntry.user_id == user.id)
        .where(JournalEntry.created_at >= since.astimezone(timezone.utc))
    )
    rows = (await session.execute(q)).scalars().all()

    total = len(rows)

    dates = set()
    for e in rows:
        dt_local = e.created_at
        if dt_local.tzinfo is None:
            dt_local = dt_local.replace(tzinfo=timezone.utc)
        dt_local = dt_local.astimezone(tz)
        dates.add(dt_local.date())
    active_days = len(dates)

    overall_total = (
        await session.execute(
            select(func.count())
            .select_from(JournalEntry)
            .where(JournalEntry.user_id == user.id)
        )
    ).scalar() or 0

    text = _tr(
        loc,
        (
            "–ò—Ç–æ–≥–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π:\n\n"
            f"‚Ä¢ –ó–∞–ø–∏—Å–µ–π –∑–∞ –Ω–µ–¥–µ–ª—é: {total}\n"
            f"‚Ä¢ –î–Ω–µ–π —Å –∑–∞–ø–∏—Å—è–º–∏: {active_days} –∏–∑ 7\n"
            f"‚Ä¢ –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π –≤ –¥–Ω–µ–≤–Ω–∏–∫–µ: {overall_total}\n\n"
            "–≠—Ç–æ —É–∂–µ –¥–≤–∏–∂–µ–Ω–∏–µ. –ü—Ä–æ–¥–æ–ª–∂–∞–π –≤–µ—Å—Ç–∏ –¥–Ω–µ–≤–Ω–∏–∫."
        ),
        (
            "–ü—ñ–¥—Å—É–º–∫–∏ –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ 7 –¥–Ω—ñ–≤:\n\n"
            f"‚Ä¢ –ó–∞–ø–∏—Å—ñ–≤ –∑–∞ —Ç–∏–∂–¥–µ–Ω—å: {total}\n"
            f"‚Ä¢ –î–Ω—ñ–≤ —ñ–∑ –∑–∞–ø–∏—Å–∞–º–∏: {active_days} –∑ 7\n"
            f"‚Ä¢ –í—Å—å–æ–≥–æ –∑–∞–ø–∏—Å—ñ–≤ —É —â–æ–¥–µ–Ω–Ω–∏–∫—É: {overall_total}\n\n"
            "–¶–µ –≤–∂–µ —Ä—É—Ö. –ü—Ä–æ–¥–æ–≤–∂—É–π –≤–µ—Å—Ç–∏ —â–æ–¥–µ–Ω–Ω–∏–∫."
        ),
        (
            "Summary for the last 7 days:\n\n"
            f"‚Ä¢ Entries this week: {total}\n"
            f"‚Ä¢ Days with entries: {active_days} of 7\n"
            f"‚Ä¢ Total entries in the journal: {overall_total}\n\n"
            "This is progress already. Keep writing."
        ),
    )

    await m.answer(text)


__all__ = ["router"]