from __future__ import annotations

"""
–ü—Ä–µ–º–∏—É–º-–º–æ–¥—É–ª—å:
- –ø–æ–∫–∞–∑ –º–µ–Ω—é –ø—Ä–µ–º–∏—É–º–∞
- –≤—ã–¥–∞—á–∞ 24 —á–∞—Å–æ–≤ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –∫–∞–Ω–∞–ª
- —Å–±—Ä–æ—Å –ø—Ä–µ–º–∏—É–º–∞ –∞–¥–º–∏–Ω–æ–º

–í–∞–∂–Ω–æ:
- –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç callback_data="open_premium" (–Ω—É–∂–Ω–æ –¥–ª—è features_v2)
- –¥–∞—ë—Ç –∫–Ω–æ–ø–∫–∏:
    ‚Ä¢ –æ–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π (–≤–µ–±)
    ‚Ä¢ –æ–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ Telegram Stars (–≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π invoice)
"""

import os
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo
from typing import Any, Dict, Optional

from aiogram import Router, F
from aiogram.filters import StateFilter, Command
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

from app.config import settings
from app.filters.buttons import Btn
from sqlalchemy import select
from app.models.user import User
from app.services.subscriptions import cancel_active_subscription
from app.jobs.renewal_reminders import run_renewal_reminders

# ‚úÖ –≥–ª–∞–≤–Ω—ã–π –∫–ª–∞–≤–∞-–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
try:
    from app.keyboards import get_main_kb  # type: ignore
except Exception:
    def get_main_kb(lang: str, is_premium: bool = False, is_admin: bool = False):
        return None

# ‚úÖ –µ–¥–∏–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∞–¥–º–∏–Ω–∞ (–∫–∞–∫ –≤ start/admin)
try:
    from app.handlers.admin import is_admin_tg
except Exception:
    def is_admin_tg(_: int) -> bool:
        return False


router = Router()

SUPPORTED_LANGS = {"ru", "uk", "en"}

CB_OPEN_PREMIUM = "open_premium"
CB_PREMIUM_CHECK = "premium:check"
CB_PAY_STARS = "pay_stars"  # üëà —Å—é–¥–∞ –∂–º—ë—Ç –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞ Stars
CB_SUB_CANCEL = "sub:cancel"
CB_SUB_CANCEL_CONFIRM = "sub:cancel:confirm"
CB_TRIAL_START = "premium:trial:start"


def _normalize_lang(code: Optional[str]) -> str:
    """–ü—Ä–∏–≤–æ–¥–∏–º –∫–æ–¥ —è–∑—ã–∫–∞ –∫ ru/uk/en —Å —É—á—ë—Ç–æ–º ua ‚Üí uk."""
    l = (code or "ru").strip().lower()
    if l.startswith(("ua", "uk")):
        return "uk"
    if l.startswith("en"):
        return "en"
    return "ru"


TEXTS: Dict[str, Dict[str, str]] = {
    "sub_given": {
        "ru": "–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞ ‚úÖ",
        "uk": "–í—ñ—Ç–∞—é! –ü—ñ–¥–ø–∏—Å–∫—É –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ ‚Äî –ø—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ ‚úÖ",
        "en": "Congrats! Subscription confirmed ‚Äî Premium activated for 24 hours ‚úÖ",
    },
    "sub_not_found": {
        "ru": "–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫–∏. –ù–∞–∂–º–∏ ¬´–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è¬ª, –∑–∞—Ç–µ–º ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª. –ï—Å–ª–∏ –≤—Å—ë —Ä–∞–≤–Ω–æ –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç ‚Äî –ø—Ä–µ–º–∏—É–º –º–æ–∂–Ω–æ –æ—Ñ–æ—Ä–º–∏—Ç—å, –æ–ø–ª–∞—Ç–∏–≤ –∫–∞—Ä—Ç–æ–π –∏–ª–∏ —á–µ—Ä–µ–∑ Stars üí≥‚ú®",
        "uk": "–ù–µ –±–∞—á—É –ø—ñ–¥–ø–∏—Å–∫–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è¬ª, –ø–æ—Ç—ñ–º ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª. –Ø–∫—â–æ –≤—Å–µ –æ–¥–Ω–æ –Ω–µ —Å–ø—Ä–∞—Ü—å–æ–≤—É—î ‚Äî –ø—Ä–µ–º—ñ—É–º –º–æ–∂–Ω–∞ –æ—Ñ–æ—Ä–º–∏—Ç–∏, –æ–ø–ª–∞—Ç–∏–≤—à–∏ –∫–∞—Ä—Ç–∫–æ—é –∞–±–æ —á–µ—Ä–µ–∑ Stars üí≥‚ú®",
        "en": "I can‚Äôt see your subscription. Tap ‚ÄúSubscribe‚Äù, then ‚ÄúCheck‚Äù. If it still doesn‚Äôt work ‚Äî you can get Premium by paying with card or via Stars üí≥‚ú®",
    },
    "trial_used": {
        "ru": "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–µ–Ω—å —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω. –ß—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–µ–º–∏—É–º–æ–º –¥–∞–ª—å—à–µ, –Ω—É–∂–Ω–æ –æ—Ñ–æ—Ä–º–∏—Ç—å –ø–ª–∞—Ç–Ω—É—é –ø–æ–¥–ø–∏—Å–∫—É ‚Äî –æ–ø–ª–∞—Ç–∏—Ç—å –∫–∞—Ä—Ç–æ–π –∏–ª–∏ —á–µ—Ä–µ–∑ Stars üí≥‚ú®",
        "uk": "–ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏–π –¥–µ–Ω—å —É–∂–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ. –©–æ–± —ñ –Ω–∞–¥–∞–ª—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è –ø—Ä–µ–º—ñ—É–º–æ–º, –ø–æ—Ç—Ä—ñ–±–Ω–æ –æ—Ñ–æ—Ä–º–∏—Ç–∏ –ø–ª–∞—Ç–Ω—É –ø—ñ–¥–ø–∏—Å–∫—É ‚Äî –æ–ø–ª–∞—Ç–∏—Ç–∏ –∫–∞—Ä—Ç–∫–æ—é –∞–±–æ —á–µ—Ä–µ–∑ Stars üí≥‚ú®",
        "en": "Your free trial has already been used. To keep using Premium, please purchase a plan ‚Äî pay by card or via Stars üí≥‚ú®",
    },
    # –ß—ë—Ç–∫–æ –æ–±–æ–∑–Ω–∞—á–∞–µ–º, —á—Ç–æ —ç—Ç–æ –∏–º–µ–Ω–Ω–æ –æ–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π (Stars ‚Äî –æ—Ç–¥–µ–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞)
    "btn_pay":   {"ru": "–û–ø–ª–∞—Ç–∏—Ç—å –∫–∞—Ä—Ç–æ–π", "uk": "–û–ø–ª–∞—Ç–∏—Ç–∏ –∫–∞—Ä—Ç–∫–æ—é", "en": "Pay by card"},
    "btn_sub":   {"ru": "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è",     "uk": "–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è",      "en": "Subscribe"},
    "btn_check": {"ru": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å",       "uk": "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏",       "en": "Check"},
}


def t_local(lang: str, key: str, **fmt: Any) -> str:
    """–õ–æ–∫–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–ª—è —ç—Ç–æ–≥–æ –º–æ–¥—É–ª—è."""
    loc = _normalize_lang(lang)
    base = TEXTS.get(key) or {}
    v = base.get(loc) or base.get("ru") or key
    return v.format(**fmt) if fmt else v


CHANNEL_USERNAME = (
    getattr(settings, "premium_channel", None)
    or os.getenv("PREMIUM_CHANNEL")
    or "@NoticesDiarY"
)
CHANNEL_URL = f"https://t.me/{CHANNEL_USERNAME.lstrip('@')}"


def _lang_of(
    user: dict | None,
    obj: Message | CallbackQuery | None,
    fallback: Optional[str] = None,
) -> str:
    """
    –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:
    1) user.locale
    2) user.lang
    3) Telegram language_code
    4) fallback (–∏–∑ middleware)
    5) settings.default_locale / 'ru'
    """
    code: Optional[str] = None

    if user:
        code = user.get("locale") or user.get("lang")

    if not code and obj:
        fu = getattr(obj, "from_user", None)
        if not fu and isinstance(obj, CallbackQuery):
            fu = getattr(getattr(obj, "message", None), "from_user", None)
        code = getattr(fu, "language_code", None) if fu else None

    if not code:
        code = fallback or getattr(settings, "default_locale", "ru")

    return _normalize_lang(code)


async def _ensure_user_columns(session: AsyncSession) -> None:
    """
    SQLite-safe guard.
    –í –ø—Ä–æ–¥–µ –Ω–∞ Postgres —ç—Ç–∏ ALTER –º–æ–≥—É—Ç –ø–∞–¥–∞—Ç—å ‚Äî –ø–æ—Ç–æ–º—É best-effort.
    """
    ddls = (
        "ALTER TABLE users ADD COLUMN locale TEXT",
        "ALTER TABLE users ADD COLUMN lang TEXT",
        "ALTER TABLE users ADD COLUMN premium_until TIMESTAMP",
        "ALTER TABLE users ADD COLUMN is_premium INTEGER DEFAULT 0",
        "ALTER TABLE users ADD COLUMN premium_trial_given INTEGER DEFAULT 0",
        "ALTER TABLE users ADD COLUMN tz TEXT",
        "ALTER TABLE users ADD COLUMN is_admin INTEGER DEFAULT 0",
    )
    for ddl in ddls:
        try:
            await session.execute(sql_text(ddl))
        except Exception:
            pass
    try:
        await session.commit()
    except Exception:
        await session.rollback()


async def _fetch_user(session: AsyncSession, tg_id: int) -> dict:
    """–ó–∞–±–∏—Ä–∞–µ–º —é–∑–µ—Ä–∞ –∫–∞–∫ dict (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å—Ä–µ–∑)."""
    await _ensure_user_columns(session)

    q = sql_text(
        "SELECT id, tg_id, locale, lang, is_premium, premium_until, "
        "premium_trial_given, tz, is_admin "
        "FROM users WHERE tg_id=:tg"
    )

    row = (await session.execute(q, {"tg": tg_id})).first()
    default_tz = getattr(settings, "default_tz", "Europe/Kyiv")
    default_lang = _normalize_lang(getattr(settings, "default_locale", "ru"))

    if row:
        m = row._mapping  # type: ignore[attr-defined]
        locale = m.get("locale")
        lang = m.get("lang")
        is_premium = m.get("is_premium") or 0
        premium_until = m.get("premium_until")
        premium_trial_given = m.get("premium_trial_given") or 0
        tz = m.get("tz") or default_tz
        is_admin = m.get("is_admin") or 0

        lang_final = _normalize_lang(lang or locale or default_lang)

        return {
            "id": m.get("id"),
            "tg_id": m.get("tg_id"),
            "lang": lang_final,
            "locale": locale or lang_final,
            "is_premium": bool(is_premium),
            "premium_until": premium_until,
            "premium_trial_given": int(premium_trial_given),
            "tz": tz,
            "is_admin": bool(is_admin),
        }

    # –Æ–∑–µ—Ä –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω ‚Äî —Å–æ–∑–¥–∞—ë–º –±–∞–∑–æ–≤—É—é –∑–∞–ø–∏—Å—å
    await session.execute(
        sql_text(
            "INSERT INTO users (tg_id, locale, lang, is_premium, premium_trial_given, tz, is_admin) "
            "VALUES (:tg, :loc, :lang, 0, 0, :tz, 0)"
        ),
        {"tg": tg_id, "loc": default_lang, "lang": default_lang, "tz": default_tz},
    )
    await session.commit()

    return {
        "id": None,
        "tg_id": tg_id,
        "lang": default_lang,
        "locale": default_lang,
        "is_premium": False,
        "premium_until": None,
        "premium_trial_given": 0,
        "tz": default_tz,
        "is_admin": False,
    }


def _to_dt_aware(val: Any) -> Optional[datetime]:
    if val is None:
        return None
    if isinstance(val, datetime):
        return val if val.tzinfo else val.replace(tzinfo=timezone.utc)
    try:
        dt = datetime.fromisoformat(str(val).replace("Z", "+00:00"))
        return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)
    except Exception:
        return None


def _is_active(user: Dict[str, Any]) -> bool:
    if not user.get("is_premium"):
        return False
    until = _to_dt_aware(user.get("premium_until"))

    left_line = \"\"
    if active and user.get(\"premium_trial_given\") and until:
        now = datetime.now(timezone.utc)
        if now < until:
            left = int((until - now).total_seconds())
            if l == \"en\":
                left_line = f\"‚è≥ Free left: {_fmt_left(left)}\"
            elif l == \"uk\":
                left_line = f\"‚è≥ –ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–æ –ª–∏—à–∏–ª–æ—Å—å: {_fmt_left(left)}\"
            else:
                left_line = f\"‚è≥ –û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ: {_fmt_left(left)}\"
    if until is None:
        return True  # –±–µ—Å—Å—Ä–æ—á–Ω—ã–π –ø—Ä–µ–º–∏—É–º
    return datetime.now(timezone.utc) < until


def _fmt_local(dt_utc: datetime, tz_name: str) -> str:
    try:
        return dt_utc.astimezone(ZoneInfo(tz_name)).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return dt_utc.astimezone(ZoneInfo("Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")


def _resolve_is_admin(tg_id: int, user: Dict[str, Any] | None = None) -> bool:
    """–ï–¥–∏–Ω—ã–π –∏—Ç–æ–≥–æ–≤—ã–π —Ñ–ª–∞–≥ –∞–¥–º–∏–Ω–∞ –¥–ª—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã."""
    if is_admin_tg(tg_id):
        return True
    if user:
        return bool(user.get("is_admin"))
    return False


def _stars_label(lang: str) -> str:
    """–ü–æ–¥–ø–∏—Å—å –¥–ª—è –∫–Ω–æ–ø–∫–∏ –æ–ø–ª–∞—Ç—ã —á–µ—Ä–µ–∑ Stars."""
    loc = (lang or "ru")[:2].lower()
    if loc == "ua":
        loc = "uk"
    labels = {
        "ru": "‚≠ê –û–ø–ª–∞—Ç–∏—Ç—å Stars",
        "uk": "‚≠ê –û–ø–ª–∞—Ç–∏—Ç–∏ Stars",
        "en": "‚≠ê Pay with Stars",
    }
    return labels.get(loc, labels["ru"])


def _pay_kb(lang: str, tg_id: int, is_premium: bool = False) -> InlineKeyboardMarkup:
    """
    –ò–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ –æ–ø–ª–∞—Ç—ã:
    - –∫–∞—Ä—Ç–æ–π (—á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–∏–π /pay)
    - —á–µ—Ä–µ–∑ Telegram Stars (–≤–Ω—É—Ç—Ä–∏ –±–æ—Ç–∞)
    - –æ—Ç–º–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∏ (–µ—Å–ª–∏ –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω)
    """
    base = (getattr(settings, "public_url", None) or os.environ.get("PUBLIC_URL", "")).strip()
    if not base.startswith("http"):
        base = "https://example.com"

    rows = [
        [
            InlineKeyboardButton(
                text=t_local(lang, "btn_pay"),
                url=f"{base}/pay?tg_id={tg_id}",
            )
        ],
        [
            InlineKeyboardButton(
                text=_stars_label(lang),
                callback_data=CB_PAY_STARS,
            )
        ],
    ]

    if is_premium:
        rows.append([
            InlineKeyboardButton(
                text=_t_cancel_label(lang),
                callback_data=CB_SUB_CANCEL,
            )
        ])

    return InlineKeyboardMarkup(inline_keyboard=rows)

def _active_premium_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=_t_cancel_label(lang), callback_data=CB_SUB_CANCEL)],
        ]
    )


def _subscribe_kb(lang: str, tg_id: int) -> InlineKeyboardMarkup:
    """
    –ò–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å—Ü–µ–Ω–∞—Ä–∏—è:
    1) –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª ‚Üí 24h –ø—Ä–µ–º–∏—É–º–∞.
    2) –ö–Ω–æ–ø–∫–∞ ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª.
    3) –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ ‚Äî –æ–ø–ª–∞—Ç–∏—Ç—å –∫–∞—Ä—Ç–æ–π –∏–ª–∏ —á–µ—Ä–µ–∑ Stars.
    """
    base = (getattr(settings, "public_url", "") or "https://example.com").strip()
    if not base.startswith("http"):
        base = "https://example.com"

    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text=t_local(lang, "btn_sub"),
                    url=CHANNEL_URL,
                )
            ],
            [
                InlineKeyboardButton(
                    text="üéÅ –ü—Ä–æ–±–Ω—ã–π –¥–æ—Å—Ç—É–ø (24h)",
                    callback_data=CB_TRIAL_START,
                )
            ],
            [
                InlineKeyboardButton(
                    text=t_local(lang, "btn_check"),
                    callback_data=CB_PREMIUM_CHECK,
                )
            ],
            [
                InlineKeyboardButton(
                    text=t_local(lang, "btn_pay"),
                    url=f"{base}/pay?tg_id={tg_id}",
                )
            ],
            [
                InlineKeyboardButton(
                    text=_stars_label(lang),
                    callback_data=CB_PAY_STARS,
                )
            ],
        ]
    )

def _t_cancel_label(lang: str) -> str:
    loc = (lang or "ru")[:2].lower()
    if loc == "ua":
        loc = "uk"
    labels = {
        "ru": "‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É",
        "uk": "‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –ø—ñ–¥–ø–∏—Å–∫—É",
        "en": "‚ùå Cancel subscription",
    }
    return labels.get(loc, labels["ru"])


async def _user_is_channel_member(bot, user_id: int) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–ø–∏—Å–∞–Ω –ª–∏ —é–∑–µ—Ä –Ω–∞ –ø—Ä–µ–º–∏—É–º-–∫–∞–Ω–∞–ª."""
    try:
        cm = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        status = getattr(cm, "status", None)
        status = getattr(status, "value", status)
        return str(status) in {"member", "administrator", "creator"}
    except Exception:
        return False


async def _grant_24h(session: AsyncSession, tg_id: int) -> bool:
    """–í—ã–¥–∞—ë–º 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞, –µ—Å–ª–∏ —Ç—Ä–∏–∞–ª –µ—â—ë –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω."""
    user = await _fetch_user(session, tg_id)
    if user.get("premium_trial_given"):
        return False

    until = datetime.now(timezone.utc) + timedelta(days=1)
    await session.execute(
        sql_text(
            "UPDATE users SET is_premium=1, premium_until=:u, premium_trial_given=1 "
            "WHERE tg_id=:tg"
        ),
        {"u": until, "tg": tg_id},
    )
    await session.commit()
    return True

async def _cancel_subscription(session: AsyncSession, tg_id: int) -> bool:
    """
    MVP –æ—Ç–º–µ–Ω—ã: –æ—Ç–∫–ª—é—á–∞–µ–º auto_renew –∏ –ø–µ—Ä–µ–≤–æ–¥–∏–º –∞–∫—Ç–∏–≤–Ω—É—é –ø–æ–¥–ø–∏—Å–∫—É –≤ canceled.
    –ù–µ —Ä–µ–∂–µ–º –¥–æ—Å—Ç—É–ø —Å—Ä–∞–∑—É ‚Äî –æ–Ω –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –¥–æ expires_at.
    """
    # —Ç—É—Ç –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ tg_id = user_id –≤ —Ç–≤–æ–∏—Ö SQLAlchemy –º–æ–¥–µ–ª—è—Ö –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è,
    # –ø–æ—ç—Ç–æ–º—É —Ä–∞–±–æ—Ç–∞–µ–º —á–µ—Ä–µ–∑ users.id:
    user = await _fetch_user(session, tg_id)
    user_db_id = user.get("id")

    if not user_db_id:
        return False

    # –±–µ—Ä—ë–º –∞–∫—Ç–∏–≤–Ω—É—é –ø–æ–¥–ø–∏—Å–∫—É –ø–æ user_id
    q = sql_text(
        "UPDATE subscriptions "
        "SET auto_renew=0, status='canceled' "
        "WHERE user_id=:uid AND status='active' "
    )
    res = await session.execute(q, {"uid": user_db_id})

    # res.rowcount –º–æ–∂–µ—Ç –±—ã—Ç—å None –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –¥—Ä–∞–π–≤–µ—Ä–∞—Ö, –ø–æ—ç—Ç–æ–º—É –ø–µ—Ä–µ—Å—Ç—Ä–∞—Ö—É–µ–º—Å—è:
    await session.commit()

    # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –æ–±–Ω–æ–≤–∏–ª–æ—Å—å ‚Äî —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–µ—Ç
    # (–º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å SELECT –ø–µ—Ä–µ–¥ UPDATE, –Ω–æ MVP –æ–∫)
    return True


async def maybe_grant_trial(session: AsyncSession, tg_id: int) -> None:
    """
    –ú—è–≥–∫–æ –≤—ã–¥–∞—Ç—å —Ç—Ä–∏–∞–ª, –µ—Å–ª–∏:
    - –ø—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω
    - —Ç—Ä–∏–∞–ª –µ—â—ë –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω
    """
    user = await _fetch_user(session, tg_id)
    if not _is_active(user) and not user.get("premium_trial_given"):
        await _grant_24h(session, tg_id)




def _fmt_left(seconds: int) -> str:
    seconds = max(0, int(seconds))
    m = seconds // 60
    h = m // 60
    m = m % 60
    if h > 0:
        return f"{h}—á {m}–º"
    if m > 0:
        return f"{m}–º"
    return f"{seconds}—Å"


async def _log_event(session: AsyncSession, tg_id: int, name: str, meta: str | None = None) -> None:
    # best-effort –ø–æ–¥ —Ä–∞–∑–Ω—ã–µ —Å—Ö–µ–º—ã events
    payloads = [
        ("INSERT INTO events (tg_id, name, meta, created_at) VALUES (:tg, :n, :m, :ts)",
         {"tg": tg_id, "n": name, "m": meta, "ts": datetime.now(timezone.utc)}),
        ("INSERT INTO events (tg_id, name, created_at) VALUES (:tg, :n, :ts)",
         {"tg": tg_id, "n": name, "ts": datetime.now(timezone.utc)}),
        ("INSERT INTO events (tg_id, name) VALUES (:tg, :n)",
         {"tg": tg_id, "n": name}),
    ]
    for q, params in payloads:
        try:
            await session.execute(sql_text(q), params)
            await session.commit()
            return
        except Exception:
            try:
                await session.rollback()
            except Exception:
                pass

def _build_menu(lang: str, user: Dict[str, Any]) -> str:
    """–¢–µ–∫—Å—Ç –º–µ–Ω—é –ø—Ä–µ–º–∏—É–º–∞ (–ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π)."""
    l = _normalize_lang(lang)
    active = _is_active(user)
    tz_name = user.get("tz") or getattr(settings, "default_tz", "Europe/Kyiv")
    until = _to_dt_aware(user.get("premium_until"))

    if l == "uk":
        title = "üíé –ü—Ä–µ–º—ñ—É–º-–¥–æ—Å—Ç—É–ø"
        free_title = "–ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–æ:"
        premium_title = "–ü—Ä–µ–º—ñ—É–º:"
        free = [
            "‚úÖ –©–æ–¥–µ–Ω–Ω–∏–π –∂—É—Ä–Ω–∞–ª /journal",
            "‚úÖ –ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è /remind",
            "‚úÖ –ë–∞–∑–æ–≤–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ /stats",
            "‚úÖ –ë–∞–∑–æ–≤—ñ –º–µ–¥–∏—Ç–∞—Ü—ñ—ó —Ç–∞ –º—É–∑–∏–∫–∞",
            "‚úÖ –ö–∞–ª–æ—Ä—ñ—ó —Ç–µ–∫—Å—Ç–æ–º",
        ]
        premium = [
            "üîê –†–æ–∑—à–∏—Ä–µ–Ω—ñ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è",
            "üîê –ü—Ä–µ–º—ñ—É–º-–º–µ–¥–∏—Ç–∞—Ü—ñ—ó —Ç–∞ –ø–ª–µ–π–ª–∏—Å—Ç–∏",
            "üîê –†–æ–∑—à–∏—Ä–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
            "üîê –ö–∞–ª–æ—Ä—ñ—ó –∑ —Ñ–æ—Ç–æ",
            "üîê –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–Ω–∞ –ø—ñ–¥—Ç—Ä–∏–º–∫–∞",
        ]
        unlocked_cta = "–£ —Ç–µ–±–µ –≤–∂–µ —î –ø—Ä–µ–º—ñ—É–º ‚Äî –≤—Å—ñ —Ñ—É–Ω–∫—Ü—ñ—ó —Ä–æ–∑–±–ª–æ–∫–æ–≤–∞–Ω—ñ üíö"
        locked_cta = "–©–æ–± –≤—ñ–¥–∫—Ä–∏—Ç–∏ –∑–∞–º–æ—á–∫–∏, –æ—Ñ–æ—Ä–º–∏ –ø—Ä–µ–º—ñ—É–º –Ω–∏–∂—á–µ ‚Äî –æ–ø–ª–∞—Ç–æ—é –∫–∞—Ä—Ç–∫–æ—é –∞–±–æ —á–µ—Ä–µ–∑ Stars üëá"
        trial_hint = "–ú–æ–∂–Ω–∞ –æ—Ç—Ä–∏–º–∞—Ç–∏ 24 –≥–æ–¥–∏–Ω–∏ –ø—Ä–µ–º—ñ—É–º—É: –ø—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª —ñ –Ω–∞—Ç–∏—Å–Ω–∏ ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª."
        status_active = (
            f"–°—Ç–∞—Ç—É—Å: –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {_fmt_local(until, tz_name)} ({tz_name}) ‚úÖ"
            if until else "–°—Ç–∞—Ç—É—Å: –∞–∫—Ç–∏–≤–Ω–∏–π ‚úÖ"
        )
        status_inactive = "–°—Ç–∞—Ç—É—Å: –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π üîí"

    elif l == "en":
        title = "üíé Premium access"
        free_title = "Free:"
        premium_title = "Premium:"
        free = [
            "‚úÖ Daily journal /journal",
            "‚úÖ Reminders /remind",
            "‚úÖ Basic statistics /stats",
            "‚úÖ Basic meditations and music",
            "‚úÖ Text calories",
        ]
        premium = [
            "üîê Advanced reminders",
            "üîê Premium meditations and playlists",
            "üîê Extended statistics",
            "üîê Photo calories",
            "üîê Priority support",
        ]
        unlocked_cta = "You already have Premium ‚Äî everything is unlocked üíö"
        locked_cta = "To unlock everything, activate Premium below ‚Äî pay by card or via Stars üëá"
        trial_hint = "You can get 24 hours of Premium: subscribe to the channel and tap ‚ÄúCheck‚Äù."
        status_active = (
            f"Status: active until {_fmt_local(until, tz_name)} ({tz_name}) ‚úÖ"
            if until else "Status: active ‚úÖ"
        )
        status_inactive = "Status: not active üîí"

    else:
        title = "üíé –ü—Ä–µ–º–∏—É–º-–¥–æ—Å—Ç—É–ø"
        free_title = "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:"
        premium_title = "–ü—Ä–µ–º–∏—É–º:"
        free = [
            "‚úÖ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –∂—É—Ä–Ω–∞–ª /journal",
            "‚úÖ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è /remind",
            "‚úÖ –ë–∞–∑–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ /stats",
            "‚úÖ –ë–∞–∑–æ–≤—ã–µ –º–µ–¥–∏—Ç–∞—Ü–∏–∏ –∏ –º—É–∑—ã–∫–∞",
            "‚úÖ –ö–∞–ª–æ—Ä–∏–∏ —Ç–µ–∫—Å—Ç–æ–º",
        ]
        premium = [
            "üîê –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è",
            "üîê –ü—Ä–µ–º–∏—É–º-–º–µ–¥–∏—Ç–∞—Ü–∏–∏ –∏ –ø–ª–µ–π–ª–∏—Å—Ç—ã",
            "üîê –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
            "üîê –ö–∞–ª–æ—Ä–∏–∏ –ø–æ —Ñ–æ—Ç–æ",
            "üîê –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞",
        ]
        unlocked_cta = "–£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å –ø—Ä–µ–º–∏—É–º ‚Äî –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã üíö"
        locked_cta = "–ß—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–º–æ—á–∫–∏, –æ—Ñ–æ—Ä–º–∏ –ø—Ä–µ–º–∏—É–º –Ω–∏–∂–µ ‚Äî –æ–ø–ª–∞—Ç–æ–π –∫–∞—Ä—Ç–æ–π –∏–ª–∏ —á–µ—Ä–µ–∑ Stars üëá"
        trial_hint = "–ú–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞: –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –∏ –Ω–∞–∂–º–∏ ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª."
        status_active = (
            f"–°—Ç–∞—Ç—É—Å: –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {_fmt_local(until, tz_name)} ({tz_name}) ‚úÖ"
            if until else "–°—Ç–∞—Ç—É—Å: –∞–∫—Ç–∏–≤–µ–Ω ‚úÖ"
        )
        status_inactive = "–°—Ç–∞—Ç—É—Å: –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω üîí"

    free_block = "\n".join(free)

    if active:
        premium_block = "\n".join(s.replace("üîê", "‚úÖ") for s in premium)
        cta = unlocked_cta
        status_line = status_active
    else:
        premium_block = "\n".join(premium)
        cta = locked_cta
        status_line = status_inactive

    return (
        f"{title}\n\n"
        f"{status_line}\n" + (f"{left_line}\n" if left_line else "") + "\n"
        f"{free_title}\n{free_block}\n\n"
        f"{premium_title}\n{premium_block}\n\n"
        f"{cta}\n\n"
        f"{trial_hint}"
    )


# ===== –•—ç–Ω–¥–ª–µ—Ä—ã =====

@router.message(StateFilter("*"), Command("premium"))
@router.message(
    F.text.lower().in_(
        {"üíé premium", "premium", "–ø—Ä–µ–º–∏—É–º", "üíé –ø—Ä–µ–º–∏—É–º", "–ø—Ä–µ–º—ñ—É–º", "üíé –ø—Ä–µ–º—ñ—É–º"}
    )
)
async def cmd_premium(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    user = await _fetch_user(session, m.from_user.id)
    lang_code = _lang_of(user, m, fallback=lang)
    text = _build_menu(lang_code, user)

    active = _is_active(user)
    is_admin = _resolve_is_admin(m.from_user.id, user)

    if active:
        kb = _active_premium_kb(lang_code)   # üëà –≤–æ—Ç —Ç—É—Ç —Ç–µ–ø–µ—Ä—å –ø–æ—è–≤–∏—Ç—Å—è cancel
    else:
        kb = _subscribe_kb(lang_code, m.from_user.id, show_trial=not user.get(\"premium_trial_given\"))

    await m.answer(text, reply_markup=kb, parse_mode=None)


# ‚úÖ –ö–†–ò–¢–ò–ß–ù–û –î–õ–Ø V2: –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞–ø—Å–µ–π–ª-–∫–Ω–æ–ø–∫–∏
@router.callback_query(F.data == CB_OPEN_PREMIUM)
async def open_premium_cb(
    c: CallbackQuery,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    user = await _fetch_user(session, c.from_user.id)
    lang_code = _lang_of(user, c, fallback=lang)
    text = _build_menu(lang_code, user)

    active = _is_active(user)
    is_admin = _resolve_is_admin(c.from_user.id, user)

    if active:
        kb = _active_premium_kb(lang_code)   # üëà –≤–æ—Ç —Ç—É—Ç —Ç–µ–ø–µ—Ä—å –ø–æ—è–≤–∏—Ç—Å—è cancel
    else:
        kb = _subscribe_kb(lang_code, c.from_user.id, show_trial=not user.get(\"premium_trial_given\"))

    await c.answer()
    if c.message:
        await c.message.answer(text, reply_markup=kb, parse_mode=None)



@router.callback_query(F.data == CB_TRIAL_START)
async def trial_start_cb(
    c: CallbackQuery,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    user = await _fetch_user(session, c.from_user.id)
    lang_code = _lang_of(user, c, fallback=lang)

    await c.answer()
    if not c.message:
        return

    await c.message.answer(
        {
            "ru": "üéÅ –ü—Ä–æ–±–Ω—ã–π –¥–æ—Å—Ç—É–ø –Ω–∞ 24 —á–∞—Å–∞:\n1) –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª\n2) –ù–∞–∂–º–∏ ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª ‚úÖ",
            "uk": "üéÅ –ü—Ä–æ–±–Ω–∏–π –¥–æ—Å—Ç—É–ø –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏:\n1) –ü—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª\n2) –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª ‚úÖ",
            "en": "üéÅ 24h trial:\n1) Subscribe to the channel\n2) Tap ‚ÄúCheck‚Äù ‚úÖ",
        }.get(lang_code, "üéÅ Trial: subscribe then tap Check ‚úÖ"),
        reply_markup=_subscribe_kb(lang_code, c.from_user.id, show_trial=not user.get(\"premium_trial_given\")),
    )

@router.callback_query(F.data == CB_PREMIUM_CHECK)
async def premium_check(
    c: CallbackQuery,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    user = await _fetch_user(session, c.from_user.id)
    lang_code = _lang_of(user, c, fallback=lang)
    is_admin = _resolve_is_admin(c.from_user.id, user)

    try:
        is_member = await _user_is_channel_member(c.bot, c.from_user.id)
        await c.answer()
    except Exception:
        is_member = False
        await c.answer()

    if not c.message:
        return

    if is_member:
        granted = await _grant_24h(session, c.from_user.id)
        if granted:
            await _log_event(session, c.from_user.id, "trial_granted")
            await c.message.answer(
                t_local(lang_code, "sub_given"),
                reply_markup=get_main_kb(lang_code, is_premium=True, is_admin=is_admin),
            )
        else:
            await _log_event(session, c.from_user.id, "trial_denied", meta="used")
            await c.message.answer(
                t_local(lang_code, "trial_used"),
                reply_markup=_pay_kb(lang_code, c.from_user.id, is_premium=_is_active(user)),
            )
    else:
        await c.message.answer(
            t_local(lang_code, "sub_not_found"),
            reply_markup=_subscribe_kb(lang_code, c.from_user.id, show_trial=not user.get(\"premium_trial_given\")),
        )

def _cancel_confirm_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="‚úÖ –î–∞, –æ—Ç–º–µ–Ω–∏—Ç—å", callback_data=CB_SUB_CANCEL_CONFIRM)],
            [InlineKeyboardButton(text="‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data=CB_OPEN_PREMIUM)],
        ]
    )

@router.callback_query(F.data == CB_SUB_CANCEL)
async def sub_cancel_ask(
    c: CallbackQuery,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    user = await _fetch_user(session, c.from_user.id)
    lang_code = _lang_of(user, c, fallback=lang)

    await c.answer()
    if c.message:
        await c.message.answer(
            {
                "ru": "–¢–æ—á–Ω–æ –æ—Ç–º–µ–Ω—è–µ–º –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ? –ü—Ä–µ–º–∏—É–º –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –∞–∫—Ç–∏–≤–Ω—ã–º –¥–æ –∫–æ–Ω—Ü–∞ –æ–ø–ª–∞—á–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞.",
                "uk": "–¢–æ—á–Ω–æ –≤–∏–º–∏–∫–∞—î–º–æ –∞–≤—Ç–æ–ø—Ä–æ–¥–æ–≤–∂–µ–Ω–Ω—è? –ü—Ä–µ–º—ñ—É–º –±—É–¥–µ –∞–∫—Ç–∏–≤–Ω–∏–º –¥–æ –∫—ñ–Ω—Ü—è –æ–ø–ª–∞—á–µ–Ω–æ–≥–æ –ø–µ—Ä—ñ–æ–¥—É.",
                "en": "Confirm cancel auto-renew? Premium will stay active until the end of the paid period.",
            }.get(lang_code, "–¢–æ—á–Ω–æ –æ—Ç–º–µ–Ω—è–µ–º –∞–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ?"),
            reply_markup=_cancel_confirm_kb(lang_code),
        )

@router.callback_query(F.data == CB_SUB_CANCEL_CONFIRM)
async def sub_cancel_confirm(
    c: CallbackQuery,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    user = await _fetch_user(session, c.from_user.id)
    lang_code = _lang_of(user, c, fallback=lang)

    ok = await _cancel_subscription(session, c.from_user.id)

    await c.answer()
    if not c.message:
        return

    if not ok:
        await c.message.answer(
            {
                "ru": "–£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ üôÇ",
                "uk": "–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–æ—ó –ø—ñ–¥–ø–∏—Å–∫–∏ üôÇ",
                "en": "You have no active subscription üôÇ",
            }.get(lang_code, "No active subscription üôÇ")
        )
        return

    await c.message.answer(
        {
            "ru": "‚úÖ –ê–≤—Ç–æ–ø—Ä–æ–¥–ª–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ. –ü—Ä–µ–º–∏—É–º –¥–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ –∫–æ–Ω—Ü–∞ –æ–ø–ª–∞—á–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞.",
            "uk": "‚úÖ –ê–≤—Ç–æ–ø—Ä–æ–¥–æ–≤–∂–µ–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω–æ. –ü—Ä–µ–º—ñ—É–º –¥—ñ—î –¥–æ –∫—ñ–Ω—Ü—è –æ–ø–ª–∞—á–µ–Ω–æ–≥–æ –ø–µ—Ä—ñ–æ–¥—É.",
            "en": "‚úÖ Auto-renew is off. Premium stays active until the end of the paid period.",
        }.get(lang_code, "‚úÖ Done"),
        reply_markup=InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(text="üíé –ü—Ä–µ–º–∏—É–º", callback_data=CB_OPEN_PREMIUM)]
            ]
        )
    )


@router.message(Command("premium_reset"))
async def premium_reset(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    # ‚úÖ –µ–¥–∏–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω–∞
    if not is_admin_tg(m.from_user.id):
        await m.answer("–î–æ—Å—Ç—É–ø –∫ —Å–±—Ä–æ—Å—É –ø—Ä–µ–º–∏—É–º–∞ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ —É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        return

    parts = (m.text or "").split()
    target_id = m.from_user.id
    hard = False

    for p in parts[1:]:
        if p.lower() == "hard":
            hard = True
        elif p.lstrip("+-").isdigit():
            target_id = int(p)

    await _ensure_user_columns(session)

    if hard:
        sql = (
            "UPDATE users SET is_premium=0, premium_until=NULL, premium_trial_given=0 "
            "WHERE tg_id=:tg"
        )
    else:
        sql = "UPDATE users SET is_premium=0, premium_until=NULL WHERE tg_id=:tg"

    await session.execute(sql_text(sql), {"tg": target_id})
    await session.commit()

    if target_id == m.from_user.id:
        msg = (
            "–ü—Ä–µ–º–∏—É–º –∏ —Ç—Ä–∏–∞–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–æ—à–µ–Ω—ã –¥–ª—è —Ç–≤–æ–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞."
            if hard
            else "–ü—Ä–µ–º–∏—É–º —Å–±—Ä–æ—à–µ–Ω."
        )
    else:
        msg = (
            f"–ü—Ä–µ–º–∏—É–º –∏ —Ç—Ä–∏–∞–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–æ—à–µ–Ω—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id}."
            if hard
            else f"–ü—Ä–µ–º–∏—É–º —Å–±—Ä–æ—à–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id}."
        )

    await m.answer(msg)


def is_premium_btn(text: str) -> bool:
    if not text:
        return False
    t_ = text.strip()
    return t_ in (
        "üíé –ü—Ä–µ–º–∏—É–º",
        "üíé –ü—Ä–µ–º—ñ—É–º",
        "üíé Premium",
        "–ü—Ä–µ–º–∏—É–º",
        "–ü—Ä–µ–º—ñ—É–º",
        "Premium",
    )


@router.message(F.text.func(lambda s: s and is_premium_btn(s)))
async def premium_button(
    m: Message,
    session: AsyncSession,
    lang: Optional[str] = None,
) -> None:
    await cmd_premium(m, session, lang)


# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä –∫–Ω–æ–ø–æ–∫ (–µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å)
try:
    router.message.register(
        cmd_premium,
        StateFilter("*"),
        Btn("btn_premium"),  # type: ignore
    )
    router.message.register(
        cmd_premium,
        StateFilter("*"),
        Btn("menu_premium"),  # type: ignore
    )
except Exception:
    pass


@router.message(Command("remind_run"))
async def remind_run(m: Message, session: AsyncSession):
    if not is_admin_tg(m.from_user.id):
        await m.answer("–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω.")
        return
    await run_renewal_reminders(m.bot, session)
    await m.answer("‚úÖ Reminders job –≤—ã–ø–æ–ª–Ω–µ–Ω.")