from __future__ import annotations

import asyncio
import logging
from datetime import datetime, time, timezone, timedelta
from typing import Optional

from sqlalchemy import select, or_
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker

from app.models.user import User

log = logging.getLogger(__name__)

SEND_WINDOW = timedelta(hours=2)  # —à–ª—ë–º —Ç–æ–ª—å–∫–æ –≤ —Ç–µ—á–µ–Ω–∏–µ 2 —á–∞—Å–æ–≤ –ø–æ—Å–ª–µ due


def _parse_hhmm(v: Optional[str]) -> Optional[time]:
    if not v:
        return None
    try:
        hh, mm = v.strip().split(":", 1)
        return time(int(hh), int(mm))
    except Exception:
        return None


def _user_tz(user: User):
    try:
        from zoneinfo import ZoneInfo
        return ZoneInfo(getattr(user, "tz", None) or "Europe/Kyiv")
    except Exception:
        return timezone.utc


def _same_local_day(last_sent: datetime, now_utc: datetime, tz) -> bool:
    if last_sent.tzinfo is None:
        last_sent = last_sent.replace(tzinfo=timezone.utc)
    if now_utc.tzinfo is None:
        now_utc = now_utc.replace(tzinfo=timezone.utc)
    return last_sent.astimezone(tz).date() == now_utc.astimezone(tz).date()


def _in_send_window(now_local: datetime, due_local: datetime) -> bool:
    return due_local <= now_local <= (due_local + SEND_WINDOW)


def _norm_lang(v: Optional[str]) -> str:
    if not v:
        return "ru"
    s = (v or "").strip().lower()
    if s.startswith("uk"):
        return "uk"
    if s.startswith("en"):
        return "en"
    if s.startswith("ru"):
        return "ru"
    return "ru"


def _get_lang(u: User) -> str:
    # –µ—Å–ª–∏ –≤ User –µ—Å—Ç—å lang/language ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º; –∏–Ω–∞—á–µ ru
    return _norm_lang(getattr(u, "lang", None) or getattr(u, "language", None) or "ru")


def _briefing_text(lang: str) -> str:
    lang = _norm_lang(lang)
    if lang == "uk":
        return (
            "üåÖ –†–∞–Ω–æ–∫ ‚Äî –∫–æ—Ä–æ—Ç–∫–∏–π —Å—Ç–∞—Ä—Ç\n\n"
            "üéØ –©–æ —Å—å–æ–≥–æ–¥–Ω—ñ –≥–æ–ª–æ–≤–Ω–µ? (1 —Ä—ñ—á)\n"
            "üë£ –Ø–∫—ñ 3 –ø—Ä–æ—Å—Ç—ñ –∫—Ä–æ–∫–∏?\n"
            "‚ö° –ó —á–æ–≥–æ –ø–æ—á–Ω–µ—à –ø—Ä—è–º–æ –∑–∞—Ä–∞–∑? (2 —Ö–≤–∏–ª–∏–Ω–∏)\n\n"
            "–í—ñ–¥–ø–æ–≤—ñ–¥–∞–π –æ–¥–Ω—ñ—î—é —Å—Ç—Ä–æ–∫–æ—é: —â–æ –≥–æ–ª–æ–≤–Ω–µ?"
        )
    if lang == "en":
        return (
            "üåÖ Morning ‚Äî quick start\n\n"
            "üéØ What‚Äôs the one main thing today?\n"
            "üë£ What 3 simple steps move you forward?\n"
            "‚ö° What‚Äôs your 2-minute start right now?\n\n"
            "Reply in one line: what‚Äôs the main thing?"
        )
    return (
        "üåÖ –£—Ç—Ä–æ ‚Äî –∫–æ—Ä–æ—Ç–∫–∏–π —Å—Ç–∞—Ä—Ç\n\n"
        "üéØ –ß—Ç–æ —Å–µ–≥–æ–¥–Ω—è –≥–ª–∞–≤–Ω–æ–µ? (1 –≤–µ—â—å)\n"
        "üë£ –ö–∞–∫–∏–µ 3 –ø—Ä–æ—Å—Ç—ã—Ö —à–∞–≥–∞?\n"
        "‚ö° –° —á–µ–≥–æ –Ω–∞—á–Ω—ë—à—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å? (2 –º–∏–Ω—É—Ç—ã)\n\n"
        "–û—Ç–≤–µ—Ç—å –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π: —á—Ç–æ –≥–ª–∞–≤–Ω–æ–µ?"
    )


def _checkin_text(lang: str) -> str:
    lang = _norm_lang(lang)
    if lang == "uk":
        return (
            "üåô –í–µ—á—ñ—Ä ‚Äî –∑–∞–∫—Ä–∏–≤–∞—î–º–æ –¥–µ–Ω—å\n\n"
            "üî≠ –Ø–∫ –ø—Ä–æ–π—à–æ–≤ –¥–µ–Ω—å? (1 —Ñ—Ä–∞–∑–∞)\n"
            "üèÜ –©–æ —Å—å–æ–≥–æ–¥–Ω—ñ –≤–∏–π—à–ª–æ?\n"
            "üìò –Ø–∫–∏–π —É—Ä–æ–∫ / –≤–∏—Å–Ω–æ–≤–æ–∫?\n\n"
            "–í—ñ–¥–ø–æ–≤—ñ–¥—å —Ñ–æ—Ä–º–∞—Ç–æ–º: –¥–µ–Ω—å: ... / –ø–µ—Ä–µ–º–æ–≥–∞: ... / —É—Ä–æ–∫: ..."
        )
    if lang == "en":
        return (
            "üåô Evening ‚Äî close the day\n\n"
            "üî≠ How was your day? (1 sentence)\n"
            "üèÜ What worked today?\n"
            "üìò What‚Äôs the lesson?\n\n"
            "Reply as: day: ... / win: ... / lesson: ..."
        )
    return (
        "üåô –í–µ—á–µ—Ä ‚Äî –∑–∞–∫—Ä—ã–≤–∞–µ–º –¥–µ–Ω—å\n\n"
        "üî≠ –ö–∞–∫ –ø—Ä–æ—à—ë–ª –¥–µ–Ω—å? (1 —Ñ—Ä–∞–∑–∞)\n"
        "üèÜ –ß—Ç–æ —Å–µ–≥–æ–¥–Ω—è –ø–æ–ª—É—á–∏–ª–æ—Å—å?\n"
        "üìò –ö–∞–∫–æ–π —É—Ä–æ–∫ / –≤—ã–≤–æ–¥?\n\n"
        "–û—Ç–≤–µ—Ç—å —Ñ–æ—Ä–º–∞—Ç–æ–º: –¥–µ–Ω—å: ... / –ø–æ–±–µ–¥–∞: ... / —É—Ä–æ–∫: ..."
    )


async def proactive_loop(bot, Session: async_sessionmaker[AsyncSession]):
    while True:
        try:
            async with Session() as s:
                now_utc = datetime.now(timezone.utc)

                users = (
                    await s.execute(
                        select(User).where(
                            or_(User.morning_auto.is_(True), User.evening_auto.is_(True))
                        )
                    )
                ).scalars().all()

                changed = False

                for u in users:
                    tg_id = getattr(u, "tg_id", None)
                    if not tg_id:
                        continue

                    tz = _user_tz(u)
                    now_local = now_utc.astimezone(tz)
                    lang = _get_lang(u)

                    # ----- MORNING -----
                    if bool(getattr(u, "morning_auto", False)):
                        t = getattr(u, "morning_time", None)
                        if isinstance(t, str):
                            t = _parse_hhmm(t)
                        if isinstance(t, time):
                            due = now_local.replace(hour=t.hour, minute=t.minute, second=0, microsecond=0)
                            last = getattr(u, "morning_last_sent_at", None)

                            should_send = _in_send_window(now_local, due)
                            if last:
                                should_send = should_send and not _same_local_day(last, now_utc, tz)

                            if should_send:
                                try:
                                    await bot.send_message(tg_id, _briefing_text(lang), parse_mode=None)
                                    u.morning_last_sent_at = now_utc
                                    changed = True
                                except Exception:
                                    log.exception("proactive morning send failed (tg_id=%s)", tg_id)

                    # ----- EVENING -----
                    if bool(getattr(u, "evening_auto", False)):
                        t = getattr(u, "evening_time", None)
                        if isinstance(t, str):
                            t = _parse_hhmm(t)
                        if isinstance(t, time):
                            due = now_local.replace(hour=t.hour, minute=t.minute, second=0, microsecond=0)
                            last = getattr(u, "evening_last_sent_at", None)

                            should_send = _in_send_window(now_local, due)
                            if last:
                                should_send = should_send and not _same_local_day(last, now_utc, tz)

                            if should_send:
                                try:
                                    await bot.send_message(tg_id, _checkin_text(lang), parse_mode=None)
                                    u.evening_last_sent_at = now_utc
                                    changed = True
                                except Exception:
                                    log.exception("proactive evening send failed (tg_id=%s)", tg_id)

                if changed:
                    await s.commit()

        except Exception:
            log.exception("proactive_loop error")

        await asyncio.sleep(45)
