### app/handlers/assistant.py

from __future__ import annotations

import asyncio
import io
import re
from datetime import datetime, timezone
from typing import Any, Optional, Dict, List, Tuple

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.bot import bot
from app.keyboards import (
    get_main_kb,

    # root
    is_root_assistant_btn,
    is_root_journal_btn, is_root_reminders_btn, is_root_calories_btn, is_root_stats_btn,
    is_root_media_btn, is_root_premium_btn, is_root_settings_btn, is_root_proactive_btn,
    is_report_bug_btn, is_admin_btn,

    # journal submenu
    is_journal_today_btn, is_journal_week_btn, is_journal_history_btn,
    is_journal_search_btn, is_journal_range_btn,
    is_journal_btn,

    # media submenu
    is_meditation_btn, is_music_btn,

    # premium submenu
    is_premium_info_btn, is_premium_card_btn, is_premium_stars_btn,

    # settings submenu
    is_language_btn, is_privacy_btn,
    is_data_privacy_btn,

    # shared
    is_back_btn,
)
from app.models.user import User
from app.services.assistant import run_assistant

# admin check (best-effort)
try:
    from app.handlers.admin import is_admin_tg  # type: ignore
except Exception:  # pragma: no cover
    def is_admin_tg(_: int) -> bool:
        return False


router = Router(name="assistant")


# ===== media poster extraction (optional) =====

_POSTER_RE = re.compile(r"(?m)^\s*üñº\s+(https?://\S+)\s*$")
_MEDIA_KNOBS_LINE = "\n–ö–Ω–æ–ø–∫–∏: ‚úÖ –≠—Ç–æ –æ–Ω–æ / üîÅ –î—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã / üß© –£—Ç–æ—á–Ω–∏—Ç—å"

def _extract_poster_url(text: str) -> tuple[Optional[str], str]:
    if not text:
        return None, text
    m = _POSTER_RE.search(text)
    if not m:
        return None, text
    url = (m.group(1) or "").strip()
    cleaned = _POSTER_RE.sub("", text).strip()
    cleaned = re.sub(r"\n{3,}", "\n\n", cleaned).strip()
    return (url or None), cleaned


def _media_inline_kb():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –≠—Ç–æ –æ–Ω–æ", callback_data="media:ok")
    kb.button(text="üîÅ –î—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã", callback_data="media:alts")
    kb.button(text="üß© –£—Ç–æ—á–Ω–∏—Ç—å", callback_data="media:hint")
    kb.adjust(2, 1)
    return kb.as_markup()


class AssistantFSM(StatesGroup):
    waiting_question = State()


async def _typing_loop(chat_id: int, *, interval: float = 4.0) -> None:
    try:
        while True:
            try:
                await bot.send_chat_action(chat_id=chat_id, action="typing")
            except Exception:
                pass
            await asyncio.sleep(interval)
    except asyncio.CancelledError:
        return


def _normalize_lang(code: Optional[str]) -> str:
    s = (code or "ru").strip().lower()
    if s.startswith(("ua", "uk")):
        return "uk"
    if s.startswith("en"):
        return "en"
    return "ru"


async def _get_user(session: AsyncSession, tg_id: int) -> Optional[User]:
    res = await session.execute(select(User).where(User.tg_id == tg_id))
    return res.scalar_one_or_none()


def _detect_lang(user: Optional[User], m: Message) -> str:
    return _normalize_lang(
        (getattr(user, "locale", None) if user else None)
        or (getattr(user, "lang", None) if user else None)
        or (getattr(getattr(m, "from_user", None), "language_code", None))
        or "ru"
    )


def _has_premium(user: Optional[User]) -> bool:
    if not user:
        return False

    now = datetime.now(timezone.utc)

    pu = getattr(user, "premium_until", None)
    if pu is not None:
        try:
            if pu.tzinfo is None:
                pu = pu.replace(tzinfo=timezone.utc)
            return pu > now
        except Exception:
            return False

    if bool(getattr(user, "is_premium", False)):
        return True

    return bool(getattr(user, "has_premium", False))


def _looks_like_media_text(text: str) -> bool:
    t = (text or "").lower()
    keys = (
        "—Ñ–∏–ª—å–º", "—Å–µ—Ä–∏–∞–ª", "–∫–∏–Ω–æ", "–º—É–ª—å—Ç", "–º—É–ª—å—Ç–∏–∫",
        "–∫–∞–¥—Ä", "–æ—Ç–∫—É–¥–∞ –∫–∞–¥—Ä", "–ø–æ –∫–∞–¥—Ä—É",
        "–∫–∞–∫ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è", "—á—Ç–æ –∑–∞ —Ñ–∏–ª—å–º", "—á—Ç–æ –∑–∞ —Å–µ—Ä–∏–∞–ª", "—á—Ç–æ –∑–∞ –º—É–ª—å—Ç–∏–∫",
        "–Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞", "–Ω–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–∏–∞–ª–∞",
        "–≤ –≥–ª–∞–≤–Ω–æ–π —Ä–æ–ª–∏", "–≥–ª–∞–≤–Ω—É—é —Ä–æ–ª—å –∏–≥—Ä–∞–µ—Ç", "—Å –∞–∫—Ç—ë—Ä–æ–º", "—Å –∞–∫—Ç–µ—Ä–æ–º",
        "–ø—Ä–æ —Ñ–∏–ª—å–º –≥–¥–µ", "–ø—Ä–æ —Å–µ—Ä–∏–∞–ª –≥–¥–µ",
        "season", "episode", "movie", "series", "tv",
        "–∞–∫—Ç—ë—Ä", "–∞–∫—Ç–µ—Ä", "–∞–∫—Ç—Ä–∏—Å–∞", "—Ä–µ–∂–∏—Å—Å–µ—Ä", "—Ä–µ–∂–∏—Å—Å—ë—Ä",
    )
    return any(k in t for k in keys)


def _is_noise_msg(text: str) -> bool:
    t = (text or "").strip()
    if not t or len(t) <= 2:
        return True
    if " " not in t and len(t) <= 3:
        return True
    return False


def _is_menu_click(text: str) -> bool:
    return any(fn(text) for fn in (
        # root
        is_root_journal_btn, is_root_reminders_btn, is_root_calories_btn, is_root_stats_btn,
        is_root_assistant_btn, is_root_media_btn, is_root_premium_btn, is_root_settings_btn, is_root_proactive_btn,
        is_report_bug_btn, is_admin_btn,

        # journal submenu
        is_journal_btn,
        is_journal_today_btn, is_journal_week_btn, is_journal_history_btn,
        is_journal_search_btn, is_journal_range_btn,

        # media submenu
        is_meditation_btn, is_music_btn,

        # premium submenu
        is_premium_info_btn, is_premium_card_btn, is_premium_stars_btn,

        # settings submenu
        is_language_btn, is_privacy_btn, is_data_privacy_btn,

        # shared
        is_back_btn,
    ))


async def _ack_media_search_once(m: Message, state: FSMContext) -> None:
    try:
        data = await state.get_data()
        if data.get("_media_ack_sent"):
            return
        await state.update_data(_media_ack_sent=True)
    except Exception:
        pass

    try:
        await m.answer("–û–∫–µ–π, —â–∞—Å –≥–ª—è–Ω—É –∏ –Ω–∞–π–¥—É. ‚è≥")
    except Exception:
        pass


async def _reset_media_ack(state: FSMContext) -> None:
    try:
        await state.update_data(_media_ack_sent=False)
    except Exception:
        pass


# =============== ENTRY ===============

@router.message(F.text.func(is_root_assistant_btn))
async def assistant_entry(m: Message, state: FSMContext, session: AsyncSession) -> None:
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    lang = _detect_lang(user, m)
    is_admin = is_admin_tg(m.from_user.id)

    if not _has_premium(user):
        await state.clear()
        await m.answer(
            "ü§ñ –ü–æ–º–æ—â–Ω–∏–∫ ‚Äî —ç—Ç–æ —Ç–≤–æ–π **—É–º–Ω—ã–π —Ä–µ–∂–∏–º** –≤ –¥–Ω–µ–≤–Ω–∏–∫–µ.\n\n"
            "–ß—Ç–æ –æ–Ω –¥–µ–ª–∞–µ—Ç:\n"
            "‚Ä¢ üß† —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ—Ç –º—ã—Å–ª–∏ –ø–æ –ø–æ–ª–æ—á–∫–∞–º\n"
            "‚Ä¢ üéØ –ø–æ–º–æ–≥–∞–µ—Ç –Ω–∞–π—Ç–∏ —Ñ–∏–ª—å–º, –∏–¥–µ—é, —Ä–µ—à–µ–Ω–∏–µ\n"
            "‚Ä¢ üåä —Å–Ω–∏–∂–∞–µ—Ç —à—É–º –≤ –≥–æ–ª–æ–≤–µ –∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ\n\n"
            "üíé –î–æ—Å—Ç—É–ø–µ–Ω –≤ Premium. –ù–∞–∂–º–∏ **–ü—Ä–µ–º–∏—É–º** –≤ –º–µ–Ω—é –Ω–∏–∂–µ.",
            reply_markup=get_main_kb(lang, is_premium=False, is_admin=is_admin),
            parse_mode="Markdown",
        )
        return

    await state.set_state(AssistantFSM.waiting_question)
    await m.answer(
        "ü§ñ –†–µ–∂–∏–º –ø–æ–º–æ—â–Ω–∏–∫–∞ –≤–∫–ª—é—á—ë–Ω.\n"
        "–ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å —Ç–µ–∫—Å—Ç –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ.\n\n"
        "–ß—Ç–æ–±—ã –≤—ã–π—Ç–∏ ‚Äî –Ω–∞–ø–∏—à–∏ ¬´—Å—Ç–æ–ø¬ª –∏–ª–∏ /cancel.",
        reply_markup=get_main_kb(lang, is_premium=True, is_admin=is_admin),
    )


# =============== EXIT ===============


@router.message(AssistantFSM.waiting_question, F.text.casefold().in_(("—Å—Ç–æ–ø", "stop", "/cancel")))
async def assistant_exit(m: Message, state: FSMContext, session: AsyncSession) -> None:
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    lang = _detect_lang(user, m)


# --- TAIL ---

    from app.services.assistant import _assistant_plan, run_assistant_vision

    plan = _assistant_plan(user)
    if plan != "pro":
        await m.answer("Photo search is available in PRO plan.")
        return

    photos = m.photo or []
    if not photos:
        await m.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ñ–æ—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë —Ä–∞–∑.")
        return

    ph = photos[-2] if len(photos) >= 2 else photos[-1]

    buf = io.BytesIO()
    await bot.download(ph, destination=buf)
    img_bytes = buf.getvalue()

    await _ack_media_search_once(m, state)
    typing_task = asyncio.create_task(_typing_loop(m.chat.id, interval=4.0))
    try:
        reply = await run_assistant_vision(user, img_bytes, caption, lang, session=session)
    finally:
        await _reset_media_ack(state)
        typing_task.cancel()
        try:
            await typing_task
        except Exception:
            pass

    if isinstance(reply, str) and "–ö–Ω–æ–ø–∫–∏:" in reply:
        clean = reply.replace(_MEDIA_KNOBS_LINE, "")
        poster_url, clean2 = _extract_poster_url(clean)
        if poster_url:
            await m.answer_photo(poster_url, caption=clean2, reply_markup=_media_inline_kb(), parse_mode=None)
        else:
            await m.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)
    else:
        await m.answer(str(reply))

@router.message(
    AssistantFSM.waiting_question,
    F.text
    & ~F.photo
    & ~F.text.func(_is_menu_click)
    & ~F.text.startswith("/")
)
@router.message(
    AssistantFSM.waiting_question,
    F.text
    & ~F.photo
    & ~F.text.func(_is_menu_click)
    & ~F.text.startswith("/")
)
async def assistant_dialog(m: Message, state: FSMContext, session: AsyncSession) -> None:
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    lang = _detect_lang(user, m)

    if not _has_premium(user):
        await state.clear()
        await m.answer(
            "ü§ñ –ü–æ–º–æ—â–Ω–∏–∫ –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –≤ Premium.\n–û—Ç–∫—Ä–æ–π üíé –ü—Ä–µ–º–∏—É–º –≤ –º–µ–Ω—é.",
            reply_markup=get_main_kb(lang, is_premium=False, is_admin=is_admin_tg(m.from_user.id)),
        )
        return

    text = (m.text or "").strip()
    if not text or _is_noise_msg(text):
        return

    # if we are waiting for a clarification, merge it with last query
    try:
        data = await state.get_data()
    except Exception:
        data = {}

    if data.get("_media_waiting_hint"):
        last_q = (data.get("_media_last_query") or "").strip()
        if last_q:
            text = f"{last_q}\n\n–£—Ç–æ—á–Ω–µ–Ω–∏–µ: {text}"
        try:
            await state.update_data(_media_waiting_hint=False)
        except Exception:
            pass

    # save last query for media buttons
    try:
        await state.update_data(_media_last_query=text, _media_last_lang=lang)
    except Exception:
        pass

    is_media_like = _looks_like_media_text(text)
    if user:
        now_utc = datetime.now(timezone.utc)
        mode = getattr(user, "assistant_mode", None)
        until = getattr(user, "assistant_mode_until", None)
        if mode == "media" and until and until > now_utc:
            is_media_like = True

    typing_task = None
    if is_media_like:
        await _ack_media_search_once(m, state)
        typing_task = asyncio.create_task(_typing_loop(m.chat.id, interval=4.0))

    try:
        reply = await run_assistant(user, text, lang, session=session)
    finally:
        await _reset_media_ack(state)
        if typing_task:
            typing_task.cancel()
            try:
                await typing_task
            except Exception:
                pass

    if isinstance(reply, str) and "–ö–Ω–æ–ø–∫–∏:" in reply:
        clean = reply.replace(_MEDIA_KNOBS_LINE, "")
        poster_url, clean2 = _extract_poster_url(clean)
        if poster_url:
            await m.answer_photo(poster_url, caption=clean2, reply_markup=_media_inline_kb(), parse_mode=None)
        else:
            await m.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)
    else:
        await m.answer(str(reply))

@router.callback_query(F.data == "media:ok")
async def media_ok(call: CallbackQuery, state: FSMContext) -> None:
    # user confirmed the result
    try:
        if call.message:
            await call.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass
    await call.answer("‚úÖ –û–∫, –ø—Ä–∏–Ω—è—Ç–æ.")


@router.callback_query(F.data == "media:alts")
async def media_alts(call: CallbackQuery, state: FSMContext, session: AsyncSession) -> None:
    # ask assistant for alternative variants based on last query
    try:
        data = await state.get_data()
    except Exception:
        data = {}

    last_q = (data.get("_media_last_query") or "").strip()
    lang = (data.get("_media_last_lang") or "ru").strip()

    if not last_q:
        await call.answer("–ù–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞. –ù–∞–ø–∏—à–∏ –∑–∞–ø—Ä–æ—Å –µ—â—ë —Ä–∞–∑ üôè", show_alert=False)
        return

    user = await session.scalar(select(User).where(User.tg_id == call.from_user.id))
    if not user:
        await call.answer("–Æ–∑–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=False)
        return

    # typing loop (optional)
    typing_task = asyncio.create_task(_typing_loop(call.message.chat.id, interval=4.0)) if call.message else None
    try:
        prompt = f"{last_q}\n\n–î–∞–π –¥—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã. 3‚Äì5 —à—Ç—É–∫. –ö–æ—Ä–æ—Ç–∫–æ."
        reply = await run_assistant(user, prompt, lang, session=session)
    finally:
        if typing_task:
            typing_task.cancel()
            try:
                await typing_task
            except Exception:
                pass

    if not call.message:
        await call.answer()
        return

    if isinstance(reply, str) and "–ö–Ω–æ–ø–∫–∏:" in reply:
        clean = reply.replace(_MEDIA_KNOBS_LINE, "")
        poster_url, clean2 = _extract_poster_url(clean)
        try:
            await state.update_data(_media_last_query=prompt, _media_last_lang=lang)
        except Exception:
            pass

        if poster_url:
            await call.message.answer_photo(poster_url, caption=clean2, reply_markup=_media_inline_kb(), parse_mode=None)
        else:
            await call.message.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)
    else:
        await call.message.answer(str(reply))

    await call.answer()


@router.callback_query(F.data == "media:hint")
async def media_hint(call: CallbackQuery, state: FSMContext) -> None:
    # ask user for clarification; next text message will be merged with last query
    try:
        await state.update_data(_media_waiting_hint=True)
    except Exception:
        pass

    if call.message:
        await call.message.answer(
            "üß© –û–∫, —É—Ç–æ—á–Ω–∏ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º:\n"
            "‚Ä¢ –∞–∫—Ç—ë—Ä/–∞–∫—Ç—Ä–∏—Å–∞?\n"
            "‚Ä¢ –ø—Ä–∏–º–µ—Ä–Ω—ã–π –≥–æ–¥?\n"
            "‚Ä¢ —Å—Ç—Ä–∞–Ω–∞/–∂–∞–Ω—Ä?\n"
            "‚Ä¢ —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏–ª–æ –≤ —Å—Ü–µ–Ω–µ?\n"
        )
    await call.answer()


# --- FALLBACK PHOTO HANDLER (–µ—Å–ª–∏ FSM –ø–æ—á–µ–º—É-—Ç–æ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω) ---
@router.message(F.photo)
async def assistant_photo_fallback(m: Message, state: FSMContext, session: AsyncSession) -> None:
    st = await state.get_state()
    if st != AssistantFSM.waiting_question.state:
        return
    await assistant_photo(m, state, session)


# --- ROUTER HANDLERS (decorators + bodies) ---

@router.message(F.text.func(is_root_assistant_btn))
async def assistant_entry(m: Message, state: FSMContext, session: AsyncSession) -> None:
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    lang = _detect_lang(user, m)
    is_admin = is_admin_tg(m.from_user.id)

    if not _has_premium(user):
        await state.clear()
        await m.answer(
            "ü§ñ –ü–æ–º–æ—â–Ω–∏–∫ ‚Äî —ç—Ç–æ —Ç–≤–æ–π **—É–º–Ω—ã–π —Ä–µ–∂–∏–º** –≤ –¥–Ω–µ–≤–Ω–∏–∫–µ.\n\n"
            "–ß—Ç–æ –æ–Ω –¥–µ–ª–∞–µ—Ç:\n"
            "‚Ä¢ üß† —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ—Ç –º—ã—Å–ª–∏ –ø–æ –ø–æ–ª–æ—á–∫–∞–º\n"
            "‚Ä¢ üéØ –ø–æ–º–æ–≥–∞–µ—Ç –Ω–∞–π—Ç–∏ —Ñ–∏–ª—å–º, –∏–¥–µ—é, —Ä–µ—à–µ–Ω–∏–µ\n"
            "‚Ä¢ üåä —Å–Ω–∏–∂–∞–µ—Ç —à—É–º –≤ –≥–æ–ª–æ–≤–µ –∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ\n\n"
            "üíé –î–æ—Å—Ç—É–ø–µ–Ω –≤ Premium. –ù–∞–∂–º–∏ **–ü—Ä–µ–º–∏—É–º** –≤ –º–µ–Ω—é –Ω–∏–∂–µ.",
            reply_markup=get_main_kb(lang, is_premium=False, is_admin=is_admin),
            parse_mode="Markdown",
        )
        return

    await state.set_state(AssistantFSM.waiting_question)
    await m.answer(
        "ü§ñ –†–µ–∂–∏–º –ø–æ–º–æ—â–Ω–∏–∫–∞ –≤–∫–ª—é—á—ë–Ω.\n"
        "–ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å —Ç–µ–∫—Å—Ç –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ.\n\n"
        "–ß—Ç–æ–±—ã –≤—ã–π—Ç–∏ ‚Äî –Ω–∞–ø–∏—à–∏ ¬´—Å—Ç–æ–ø¬ª –∏–ª–∏ /cancel.",
        reply_markup=get_main_kb(lang, is_premium=True, is_admin=is_admin),
    )


# =============== EXIT ===============



@router.message(AssistantFSM.waiting_question, F.text.casefold().in_(("—Å—Ç–æ–ø", "stop", "/cancel")))
async def assistant_exit(m: Message, state: FSMContext, session: AsyncSession) -> None:
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    lang = _detect_lang(user, m)
    is_admin = is_admin_tg(m.from_user.id)

    await state.clear()
    await m.answer(
        "–û–∫, —Ä–µ–∂–∏–º –ø–æ–º–æ—â–Ω–∏–∫–∞ –≤—ã–∫–ª—é—á–µ–Ω.",
        reply_markup=get_main_kb(lang, is_premium=_has_premium(user), is_admin=is_admin),
    )



@router.message(AssistantFSM.waiting_question, F.text.func(_is_menu_click))
async def assistant_menu_exit(m: Message, state: FSMContext) -> None:
    await state.clear()


# =============== PHOTO (PRO) ===============


@router.message(AssistantFSM.waiting_question, F.photo)
async def assistant_photo(m: Message, state: FSMContext, session: AsyncSession) -> None:
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    lang = _detect_lang(user, m)
    caption = (m.caption or "").strip()

    # save last media context for buttons
    try:
        q = caption or "<photo>"
        await state.update_data(_media_last_query=q, _media_last_lang=lang)
    except Exception:
        pass

    if not _has_premium(user):
        await state.clear()
        await m.answer(
            "Assistant is Premium-only. Open Premium in menu.",
            reply_markup=get_main_kb(lang, is_premium=False, is_admin=is_admin_tg(m.from_user.id)),
        )
        return

    from app.services.assistant import _assistant_plan, run_assistant_vision

    plan = _assistant_plan(user)
    if plan != "pro":
        await m.answer("Photo search is available in PRO plan.")
        return

    photos = m.photo or []
    if not photos:
        await m.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ñ–æ—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë —Ä–∞–∑.")
        return

    ph = photos[-2] if len(photos) >= 2 else photos[-1]

    buf = io.BytesIO()
    await bot.download(ph, destination=buf)
    img_bytes = buf.getvalue()

    await _ack_media_search_once(m, state)
    typing_task = asyncio.create_task(_typing_loop(m.chat.id, interval=4.0))
    try:
        reply = await run_assistant_vision(user, img_bytes, caption, lang, session=session)
    finally:
        await _reset_media_ack(state)
        typing_task.cancel()
        try:
            await typing_task
        except Exception:
            pass

    if isinstance(reply, str) and "–ö–Ω–æ–ø–∫–∏:" in reply:
        clean = reply.replace(_MEDIA_KNOBS_LINE, "")
        poster_url, clean2 = _extract_poster_url(clean)
        if poster_url:
            await m.answer_photo(poster_url, caption=clean2, reply_markup=_media_inline_kb(), parse_mode=None)
        else:
            await m.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)
    else:
        await m.answer(str(reply))


@router.callback_query(F.data == "media:ok")
async def media_ok(call: CallbackQuery, state: FSMContext) -> None:
    # user confirmed the result
    try:
        if call.message:
            await call.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass
    await call.answer("‚úÖ –û–∫, –ø—Ä–∏–Ω—è—Ç–æ.")



@router.callback_query(F.data == "media:alts")
async def media_alts(call: CallbackQuery, state: FSMContext, session: AsyncSession) -> None:
    # ask assistant for alternative variants based on last query
    try:
        data = await state.get_data()
    except Exception:
        data = {}

    last_q = (data.get("_media_last_query") or "").strip()
    lang = (data.get("_media_last_lang") or "ru").strip()

    if not last_q:
        await call.answer("–ù–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞. –ù–∞–ø–∏—à–∏ –∑–∞–ø—Ä–æ—Å –µ—â—ë —Ä–∞–∑ üôè", show_alert=False)
        return

    user = await session.scalar(select(User).where(User.tg_id == call.from_user.id))
    if not user:
        await call.answer("–Æ–∑–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=False)
        return

    # typing loop (optional)
    typing_task = asyncio.create_task(_typing_loop(call.message.chat.id, interval=4.0)) if call.message else None
    try:
        prompt = f"{last_q}\n\n–î–∞–π –¥—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã. 3‚Äì5 —à—Ç—É–∫. –ö–æ—Ä–æ—Ç–∫–æ."
        reply = await run_assistant(user, prompt, lang, session=session)
    finally:
        if typing_task:
            typing_task.cancel()
            try:
                await typing_task
            except Exception:
                pass

    if not call.message:
        await call.answer()
        return

    if isinstance(reply, str) and "–ö–Ω–æ–ø–∫–∏:" in reply:
        clean = reply.replace(_MEDIA_KNOBS_LINE, "")
        poster_url, clean2 = _extract_poster_url(clean)
        try:
            await state.update_data(_media_last_query=prompt, _media_last_lang=lang)
        except Exception:
            pass

        if poster_url:
            await call.message.answer_photo(poster_url, caption=clean2, reply_markup=_media_inline_kb(), parse_mode=None)
        else:
            await call.message.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)
    else:
        await call.message.answer(str(reply))

    await call.answer()



@router.callback_query(F.data == "media:hint")
async def media_hint(call: CallbackQuery, state: FSMContext) -> None:
    # ask user for clarification; next text message will be merged with last query
    try:
        await state.update_data(_media_waiting_hint=True)
    except Exception:
        pass

    if call.message:
        await call.message.answer(
            "üß© –û–∫, —É—Ç–æ—á–Ω–∏ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º:\n"
            "‚Ä¢ –∞–∫—Ç—ë—Ä/–∞–∫—Ç—Ä–∏—Å–∞?\n"
            "‚Ä¢ –ø—Ä–∏–º–µ—Ä–Ω—ã–π –≥–æ–¥?\n"
            "‚Ä¢ —Å—Ç—Ä–∞–Ω–∞/–∂–∞–Ω—Ä?\n"
            "‚Ä¢ —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏–ª–æ –≤ —Å—Ü–µ–Ω–µ?\n"
        )
    await call.answer()


# --- FALLBACK PHOTO HANDLER (–µ—Å–ª–∏ FSM –ø–æ—á–µ–º—É-—Ç–æ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω) ---

@router.message(F.photo)
async def assistant_photo_fallback(m: Message, state: FSMContext, session: AsyncSession) -> None:
    st = await state.get_state()
    if st != AssistantFSM.waiting_question.state:
        return
    await assistant_photo(m, state, session)


# --- BLOCK: class AssistantFSM ---

class AssistantFSM(StatesGroup):
    waiting_question = State()




# --- BLOCK: async def assistant_entry ---

async def assistant_entry(m: Message, state: FSMContext, session: AsyncSession) -> None:
    if not m.from_user:
        return

    user = await _get_user(session, m.from_user.id)
    lang = _detect_lang(user, m)
    is_admin = is_admin_tg(m.from_user.id)

    if not _has_premium(user):
        await state.clear()
        await m.answer(
            "ü§ñ –ü–æ–º–æ—â–Ω–∏–∫ ‚Äî —ç—Ç–æ —Ç–≤–æ–π **—É–º–Ω—ã–π —Ä–µ–∂–∏–º** –≤ –¥–Ω–µ–≤–Ω–∏–∫–µ.\n\n"
            "–ß—Ç–æ –æ–Ω –¥–µ–ª–∞–µ—Ç:\n"
            "‚Ä¢ üß† —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ—Ç –º—ã—Å–ª–∏ –ø–æ –ø–æ–ª–æ—á–∫–∞–º\n"
            "‚Ä¢ üéØ –ø–æ–º–æ–≥–∞–µ—Ç –Ω–∞–π—Ç–∏ —Ñ–∏–ª—å–º, –∏–¥–µ—é, —Ä–µ—à–µ–Ω–∏–µ\n"
            "‚Ä¢ üåä —Å–Ω–∏–∂–∞–µ—Ç —à—É–º –≤ –≥–æ–ª–æ–≤–µ –∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ\n\n"
            "üíé –î–æ—Å—Ç—É–ø–µ–Ω –≤ Premium. –ù–∞–∂–º–∏ **–ü—Ä–µ–º–∏—É–º** –≤ –º–µ–Ω—é –Ω–∏–∂–µ.",
            reply_markup=get_main_kb(lang, is_premium=False, is_admin=is_admin),
            parse_mode="Markdown",
        )
        return

    await state.set_state(AssistantFSM.waiting_question)
    await m.answer(
        "ü§ñ –†–µ–∂–∏–º –ø–æ–º–æ—â–Ω–∏–∫–∞ –≤–∫–ª—é—á—ë–Ω.\n"
        "–ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å —Ç–µ–∫—Å—Ç –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ.\n\n"
        "–ß—Ç–æ–±—ã –≤—ã–π—Ç–∏ ‚Äî –Ω–∞–ø–∏—à–∏ ¬´—Å—Ç–æ–ø¬ª –∏–ª–∏ /cancel.",
        reply_markup=get_main_kb(lang, is_premium=True, is_admin=is_admin),
    )


# =============== EXIT ===============


@router.message(AssistantFSM.waiting_question, F.text.casefold().in_(("—Å—Ç–æ–ø", "stop", "/cancel")))


==========================================================================================

### app/handlers/menus.py

from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Optional, Dict, List, Tuple

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.dispatcher.event.bases import SkipHandler
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.user import User
from app.keyboards import (
    get_main_kb,
    get_journal_menu_kb,
    get_media_menu_kb,
    get_settings_menu_kb,
    get_premium_menu_kb,
    is_root_journal_btn,
    is_root_media_btn,
    is_root_settings_btn,
    is_root_proactive_btn,
    is_root_premium_btn,
    is_back_btn,
)
from app.services.analytics_helpers import log_ui
from app.services.assistant import run_assistant


from app.handlers.assistant import _media_inline_kb
router = Router(name="menus")


async def _get_user(session: AsyncSession, tg_id: int) -> Optional[User]:
    return (await session.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()


def _user_lang(user: Optional[User], tg_lang: Optional[str]) -> str:
    loc = (getattr(user, "locale", None) or getattr(user, "lang", None) or tg_lang or "ru").lower()
    if loc.startswith(("ua", "uk")):
        return "uk"
    if loc.startswith("en"):
        return "en"
    return "ru"


def _is_premium_user(user: Optional[User]) -> bool:
    if not user:
        return False
    if bool(getattr(user, "has_premium", False) or getattr(user, "is_premium", False)):
        return True
    pu = getattr(user, "premium_until", None)
    if pu:
        try:
            now = datetime.now(timezone.utc)
            if pu.tzinfo is None:
                pu = pu.replace(tzinfo=timezone.utc)
            return pu > now
        except Exception:
            return False
    return False


def _is_admin_user(user: Optional[User], tg_id: int) -> bool:
    if user and bool(getattr(user, "is_admin", False)):
        return True
    try:
        from app.handlers.admin import is_admin
        return bool(is_admin(tg_id, user))
    except Exception:
        return False


async def _log(session: AsyncSession, user: Optional[User], tg_lang: Optional[str], event: str, source: str) -> None:
    await log_ui(
        session,
        user=user,
        user_id=(user.id if user else None),
        event=event,
        source=source,
        tg_lang=tg_lang,
    )
    await session.commit()


@router.message(F.text.func(is_root_journal_btn))
async def open_journal_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_journal_menu", "menu")
    await m.answer("üìì –ñ—É—Ä–Ω–∞–ª", reply_markup=get_journal_menu_kb(lang))


@router.message(F.text.func(is_root_media_btn))
async def open_media_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_media_menu", "menu")
    await m.answer("üßò –ú–µ–¥–∏–∞", reply_markup=get_media_menu_kb(lang))


@router.message(F.text.func(is_root_settings_btn))
async def open_settings_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_settings_menu", "menu")
    await m.answer("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", reply_markup=get_settings_menu_kb(lang))


@router.message(F.text.func(is_root_proactive_btn))
async def open_proactive_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_proactive_menu", "menu")

    from app.handlers.proactive import show_proactive_screen
    await show_proactive_screen(m, session, lang)


@router.message(F.text.func(is_root_premium_btn))
async def open_premium_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)
    is_premium = _is_premium_user(user)

    await _log(session, user, tg_lang, "premium_click", "menu")

    from aiogram.types import ReplyKeyboardRemove
    await m.answer("üíé –ü—Ä–µ–º–∏—É–º", reply_markup=ReplyKeyboardRemove())
    await m.answer("üíé –ü—Ä–µ–º–∏—É–º", reply_markup=get_premium_menu_kb(lang, is_premium=is_premium))


@router.callback_query(F.data == "menu:home")
async def cb_back_to_main(call: CallbackQuery, session: AsyncSession, state: FSMContext) -> None:
    await state.clear()

    user = await _get_user(session, call.from_user.id)
    lang = _user_lang(user, getattr(call.from_user, "language_code", None))

    await call.message.answer(
        "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=get_main_kb(
            lang,
            is_premium=_is_premium_user(user),
            is_admin=_is_admin_user(user, call.from_user.id),
        ),
    )

    try:
        await call.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass

    await call.answer()


@router.message(F.text.func(is_back_btn))
async def back_to_main(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "back_to_main", "button")

    await m.answer(
        "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=get_main_kb(
            lang,
            is_premium=_is_premium_user(user),
            is_admin=_is_admin_user(user, m.from_user.id),
        ),
    )

@router.message(F.text & ~F.text.startswith("/"))
async def media_mode_text_router(message: Message, session: AsyncSession, state: FSMContext):
    # ‚úÖ –µ—Å–ª–∏ –≤ –ª—é–±–æ–º FSM (–∂—É—Ä–Ω–∞–ª/–∫–∞–ª–æ—Ä–∏–∏/–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç/–∏ —Ç.–¥.) ‚Äî –ù–ï –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ
    st = None
    try:
        st = await state.get_state()
    except Exception:
        st = None

    if st:
        raise SkipHandler()

    if not getattr(message, "from_user", None):
        raise SkipHandler()

    # –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω assistant_mode == 'media', —Ç–æ –ª—é–±–æ–π —Ç–µ–∫—Å—Ç —É—Ö–æ–¥–∏—Ç –≤ run_assistant.
    # –ï—Å–ª–∏ media mode –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ.
    user = await session.scalar(select(User).where(User.tg_id == message.from_user.id))
    if not user or getattr(user, "assistant_mode", None) != "media":
        raise SkipHandler()

    try:
        now = datetime.now(timezone.utc)
    except Exception:
        now = datetime.utcnow().replace(tzinfo=timezone.utc)

    until = getattr(user, "assistant_mode_until", None)
    if until is not None and until <= now:
        raise SkipHandler()

    lang = getattr(user, "lang", None) or "ru"
    text = (message.text or "").strip()
    if not text:
        raise SkipHandler()

    reply = await run_assistant(user, text, lang, session=session)
    if reply:
        clean = reply.replace("\n–ö–Ω–æ–ø–∫–∏: ‚úÖ –≠—Ç–æ –æ–Ω–æ / üîÅ –î—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã / üß© –£—Ç–æ—á–Ω–∏—Ç—å", "")
        await message.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)


# --- TAIL ---

from app.services.analytics_helpers import log_ui
from app.services.assistant import run_assistant


from app.handlers.assistant import _media_inline_kb
router = Router(name="menus")


async def _get_user(session: AsyncSession, tg_id: int) -> Optional[User]:
    return (await session.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()


def _user_lang(user: Optional[User], tg_lang: Optional[str]) -> str:
    loc = (getattr(user, "locale", None) or getattr(user, "lang", None) or tg_lang or "ru").lower()
    if loc.startswith(("ua", "uk")):
        return "uk"
    if loc.startswith("en"):
        return "en"
    return "ru"


def _is_premium_user(user: Optional[User]) -> bool:
    if not user:
        return False
    if bool(getattr(user, "has_premium", False) or getattr(user, "is_premium", False)):
        return True
    pu = getattr(user, "premium_until", None)
    if pu:
        try:
            now = datetime.now(timezone.utc)
            if pu.tzinfo is None:
                pu = pu.replace(tzinfo=timezone.utc)
            return pu > now
        except Exception:
            return False
    return False


def _is_admin_user(user: Optional[User], tg_id: int) -> bool:
    if user and bool(getattr(user, "is_admin", False)):
        return True
    try:
        from app.handlers.admin import is_admin
        return bool(is_admin(tg_id, user))
    except Exception:
        return False


async def _log(session: AsyncSession, user: Optional[User], tg_lang: Optional[str], event: str, source: str) -> None:
    await log_ui(
        session,
        user=user,
        user_id=(user.id if user else None),
        event=event,
        source=source,
        tg_lang=tg_lang,
    )
    await session.commit()


@router.message(F.text.func(is_root_journal_btn))
async def open_journal_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_journal_menu", "menu")
    await m.answer("üìì –ñ—É—Ä–Ω–∞–ª", reply_markup=get_journal_menu_kb(lang))


@router.message(F.text.func(is_root_media_btn))
async def open_media_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_media_menu", "menu")
    await m.answer("üßò –ú–µ–¥–∏–∞", reply_markup=get_media_menu_kb(lang))


@router.message(F.text.func(is_root_settings_btn))
async def open_settings_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_settings_menu", "menu")
    await m.answer("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", reply_markup=get_settings_menu_kb(lang))


@router.message(F.text.func(is_root_proactive_btn))
async def open_proactive_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_proactive_menu", "menu")

    from app.handlers.proactive import show_proactive_screen
    await show_proactive_screen(m, session, lang)


@router.message(F.text.func(is_root_premium_btn))
async def open_premium_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)
    is_premium = _is_premium_user(user)

    await _log(session, user, tg_lang, "premium_click", "menu")

    from aiogram.types import ReplyKeyboardRemove
    await m.answer("üíé –ü—Ä–µ–º–∏—É–º", reply_markup=ReplyKeyboardRemove())
    await m.answer("üíé –ü—Ä–µ–º–∏—É–º", reply_markup=get_premium_menu_kb(lang, is_premium=is_premium))


@router.callback_query(F.data == "menu:home")
async def cb_back_to_main(call: CallbackQuery, session: AsyncSession, state: FSMContext) -> None:
    await state.clear()

    user = await _get_user(session, call.from_user.id)
    lang = _user_lang(user, getattr(call.from_user, "language_code", None))

    await call.message.answer(
        "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=get_main_kb(
            lang,
            is_premium=_is_premium_user(user),
            is_admin=_is_admin_user(user, call.from_user.id),
        ),
    )

    try:
        await call.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass

    await call.answer()


@router.message(F.text.func(is_back_btn))
async def back_to_main(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "back_to_main", "button")

    await m.answer(
        "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=get_main_kb(
            lang,
            is_premium=_is_premium_user(user),
            is_admin=_is_admin_user(user, m.from_user.id),
        ),
    )

@router.message(F.text & ~F.text.startswith("/"))
async def media_mode_text_router(message: Message, session: AsyncSession, state: FSMContext):
    # ‚úÖ –µ—Å–ª–∏ –≤ –ª—é–±–æ–º FSM (–∂—É—Ä–Ω–∞–ª/–∫–∞–ª–æ—Ä–∏–∏/–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç/–∏ —Ç.–¥.) ‚Äî –ù–ï –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ
    st = None
    try:
        st = await state.get_state()
    except Exception:
        st = None

    if st:
        raise SkipHandler()

    if not getattr(message, "from_user", None):
        raise SkipHandler()

    # –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω assistant_mode == 'media', —Ç–æ –ª—é–±–æ–π —Ç–µ–∫—Å—Ç —É—Ö–æ–¥–∏—Ç –≤ run_assistant.
    # –ï—Å–ª–∏ media mode –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ.
    user = await session.scalar(select(User).where(User.tg_id == message.from_user.id))
    if not user or getattr(user, "assistant_mode", None) != "media":
        raise SkipHandler()

    try:
        now = datetime.now(timezone.utc)
    except Exception:
        now = datetime.utcnow().replace(tzinfo=timezone.utc)

    until = getattr(user, "assistant_mode_until", None)
    if until is not None and until <= now:
        raise SkipHandler()

    lang = getattr(user, "lang", None) or "ru"
    text = (message.text or "").strip()
    if not text:
        raise SkipHandler()

    reply = await run_assistant(user, text, lang, session=session)
    if reply:
        clean = reply.replace("\n–ö–Ω–æ–ø–∫–∏: ‚úÖ –≠—Ç–æ –æ–Ω–æ / üîÅ –î—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã / üß© –£—Ç–æ—á–Ω–∏—Ç—å", "")
        await message.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)


# --- ROUTER HANDLERS (decorators + bodies) ---

@router.message(F.text.func(is_root_journal_btn))
async def open_journal_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_journal_menu", "menu")
    await m.answer("üìì –ñ—É—Ä–Ω–∞–ª", reply_markup=get_journal_menu_kb(lang))



@router.message(F.text.func(is_root_media_btn))
async def open_media_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_media_menu", "menu")
    await m.answer("üßò –ú–µ–¥–∏–∞", reply_markup=get_media_menu_kb(lang))



@router.message(F.text.func(is_root_settings_btn))
async def open_settings_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_settings_menu", "menu")
    await m.answer("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", reply_markup=get_settings_menu_kb(lang))



@router.message(F.text.func(is_root_proactive_btn))
async def open_proactive_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "open_proactive_menu", "menu")

    from app.handlers.proactive import show_proactive_screen
    await show_proactive_screen(m, session, lang)



@router.message(F.text.func(is_root_premium_btn))
async def open_premium_menu(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)
    is_premium = _is_premium_user(user)

    await _log(session, user, tg_lang, "premium_click", "menu")

    from aiogram.types import ReplyKeyboardRemove
    await m.answer("üíé –ü—Ä–µ–º–∏—É–º", reply_markup=ReplyKeyboardRemove())
    await m.answer("üíé –ü—Ä–µ–º–∏—É–º", reply_markup=get_premium_menu_kb(lang, is_premium=is_premium))



@router.callback_query(F.data == "menu:home")
async def cb_back_to_main(call: CallbackQuery, session: AsyncSession, state: FSMContext) -> None:
    await state.clear()

    user = await _get_user(session, call.from_user.id)
    lang = _user_lang(user, getattr(call.from_user, "language_code", None))

    await call.message.answer(
        "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=get_main_kb(
            lang,
            is_premium=_is_premium_user(user),
            is_admin=_is_admin_user(user, call.from_user.id),
        ),
    )

    try:
        await call.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass

    await call.answer()



@router.message(F.text.func(is_back_btn))
async def back_to_main(m: Message, session: AsyncSession, state: FSMContext) -> None:
    if not m.from_user:
        return
    await state.clear()

    user = await _get_user(session, m.from_user.id)
    tg_lang = getattr(m.from_user, "language_code", None)
    lang = _user_lang(user, tg_lang)

    await _log(session, user, tg_lang, "back_to_main", "button")

    await m.answer(
        "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        reply_markup=get_main_kb(
            lang,
            is_premium=_is_premium_user(user),
            is_admin=_is_admin_user(user, m.from_user.id),
        ),
    )


@router.message(F.text & ~F.text.startswith("/"))
async def media_mode_text_router(message: Message, session: AsyncSession, state: FSMContext):
    # ‚úÖ –µ—Å–ª–∏ –≤ –ª—é–±–æ–º FSM (–∂—É—Ä–Ω–∞–ª/–∫–∞–ª–æ—Ä–∏–∏/–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç/–∏ —Ç.–¥.) ‚Äî –ù–ï –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ
    st = None
    try:
        st = await state.get_state()
    except Exception:
        st = None

    if st:
        raise SkipHandler()

    if not getattr(message, "from_user", None):
        raise SkipHandler()

    # –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω assistant_mode == 'media', —Ç–æ –ª—é–±–æ–π —Ç–µ–∫—Å—Ç —É—Ö–æ–¥–∏—Ç –≤ run_assistant.
    # –ï—Å–ª–∏ media mode –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ.
    user = await session.scalar(select(User).where(User.tg_id == message.from_user.id))
    if not user or getattr(user, "assistant_mode", None) != "media":
        raise SkipHandler()

    try:
        now = datetime.now(timezone.utc)
    except Exception:
        now = datetime.utcnow().replace(tzinfo=timezone.utc)

    until = getattr(user, "assistant_mode_until", None)
    if until is not None and until <= now:
        raise SkipHandler()

    lang = getattr(user, "lang", None) or "ru"
    text = (message.text or "").strip()
    if not text:
        raise SkipHandler()

    reply = await run_assistant(user, text, lang, session=session)
    if reply:
        clean = reply.replace("\n–ö–Ω–æ–ø–∫–∏: ‚úÖ –≠—Ç–æ –æ–Ω–æ / üîÅ –î—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã / üß© –£—Ç–æ—á–Ω–∏—Ç—å", "")
        await message.answer(clean, reply_markup=_media_inline_kb(), parse_mode=None)


==========================================================================================

### app/services/assistant.py

from __future__ import annotations
import time
# app/services/assistant.py
import os
import re
from datetime import datetime, timedelta, timezone
from typing import Any, Optional, cast
from zoneinfo import ZoneInfo

from sqlalchemy import desc, select

from app.models.journal import JournalEntry
from app.models.user import User
from app.services.intent_router import Intent, detect_intent
from app.services.media.formatting import (
    MEDIA_NOT_FOUND_REPLY_RU,
    MEDIA_VIDEO_STUB_REPLY_RU,
    _format_media_pick,
    _format_media_ranked,
    build_media_context,
)
from app.services.media.lens import (
    _lens_bad_candidate,
    _pick_best_lens_candidates,
)

# --- Optional OpenAI import (server may not have it) ---
# --- Anti-hallucination prefix (local-only; do not import) ---
# --- media helpers split (auto) ---
from app.services.media.logging import _d
from app.services.media.pipeline_tmdb import _tmdb_best_effort
from app.services.media.query import (
    _clean_media_search_query,
    _clean_tmdb_query,
    _extract_media_kind_marker,
    _good_tmdb_cand,
    _is_asking_for_title,
    _is_bad_media_query,
    _is_generic_media_caption,
    _looks_like_freeform_media_query,
    _normalize_tmdb_query,
    _parse_media_hints,
    _tmdb_sanitize_query,
)
from app.services.media.safety import (
    _scrub_media_items,
)
from app.services.media.session import (
    _MEDIA_SESSIONS,
    _looks_like_choice,
    _looks_like_year_or_hint,
    _media_get,
    _media_set,
    _media_uid,
)
from app.services.media.vision_parse import (
    _build_tmdb_queries_from_media_json,
    _extract_media_json_from_model_text,
    _extract_search_query_from_text,
    _extract_title_like_from_model_text,
)

ANTI_HALLUCINATION_PREFIX: str = ""

try:
    from openai import AsyncOpenAI
except ModuleNotFoundError:
    AsyncOpenAI = None  # type: ignore

# --- Models (imported at top) ---

# --- Project-level constants (fallbacks) ---
# Used by _is_generic_media_caption
# _GENERIC_MEDIA_CAPTIONS moved to app/services/media/query.py
# --- restored media helpers (from assistant.py.bak2) ---




# --- restored helpers (from assistant.py.bak2) ---



# --- vision cache (screenshot -> result) ---
_VISION_IMG_CACHE: dict[str, tuple[float, str]] = {}
_VISION_IMG_CACHE_TTL_SEC = 30 * 60  # 30 minutes

def _vision_cache_get(key: str) -> str | None:
    try:
        v = _VISION_IMG_CACHE.get(key)
        if not v:
            return None
        ts, reply = v
        if (time.time() - ts) > _VISION_IMG_CACHE_TTL_SEC:
            _VISION_IMG_CACHE.pop(key, None)
            return None
        return reply
    except Exception:
        return None

def _vision_cache_set(key: str, reply: str) -> None:
    try:
        if key and reply:
            _VISION_IMG_CACHE[key] = (time.time(), reply)
    except Exception:
        pass

# --- safety: scrub explicit overviews (TMDb sometimes returns NSFW text even with include_adult=false) ---









# --- Services imports (try real, otherwise safe stubs) ---
try:
    from app.services.media_search import tmdb_search_multi  # expected existing
except Exception:  # pragma: no cover

    async def tmdb_search_multi(*args: Any, **kwargs: Any) -> list[dict]:
        return []


try:
    from app.services.media_web_pipeline import (
        web_to_tmdb_candidates,  # expected existing
    )
except Exception:  # pragma: no cover

    async def web_to_tmdb_candidates(
        *args: Any, **kwargs: Any
    ) -> tuple[list[str], str]:
        return ([], "web_stub")


try:
    from app.services.media_web_pipeline import (
        image_bytes_to_tmdb_candidates,
    )  # expected existing
except Exception:  # pragma: no cover

    async def image_bytes_to_tmdb_candidates(
        *args: Any, **kwargs: Any
    ) -> tuple[list[str], str]:
        return ([], "lens_stub")


try:
    from app.services.media_id import trace_moe_identify  # expected existing
except Exception:  # pragma: no cover

    async def trace_moe_identify(*args: Any, **kwargs: Any) -> Optional[dict]:
        return None


try:
    from app.services.llm_usage import log_llm_usage  # expected existing
except Exception:  # pragma: no cover

    async def log_llm_usage(*args: Any, **kwargs: Any) -> None:
        return None


# --- Optional project prompts (safe fallback for workers/tests) ---

# --- TMDB query sanitizer: TMDB hates long "scene description" queries ---






























def _media_confident(item: dict) -> bool:
    """Conservative confidence heuristic for Vision results."""
    try:
        pop = float(item.get("popularity") or 0)
        va = float(item.get("vote_average") or 0)
    except Exception:
        return False
    return (pop >= 25 and va >= 6.8) or (pop >= 60) or (va >= 7.6)

















# --- BAD OCR / GENERIC QUERY FILTER FOR MEDIA SEARCH ---


# --- media query cleaning: turn human phrasing into search-friendly query ---







# --- media session cache (in-memory, no DB migrations) ---























def _env(name: str, default: str = "") -> str:


# --- TAIL ---

        if result:
            sim = float(result.get("similarity", 0) or 0)
            if sim >= 0.9:
                return (
                    "üé¨ –≠—Ç–æ –∫–∞–¥—Ä –∏–∑ –∞–Ω–∏–º–µ.\n\n"
                    f"–ù–∞–∑–≤–∞–Ω–∏–µ: {result.get('title')}\n"
                    f"–°–µ—Ä–∏—è: {result.get('episode')}\n"
                    f"–°–æ–≤–ø–∞–¥–µ–Ω–∏–µ: {sim:.1%}"
                )
    # –∏–Ω–∞—á–µ ‚Äî –Ω–µ –ª–æ–º–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –ø–æ—Ç–æ–∫, –ø—Ä–æ—Å—Ç–æ –∏–¥—ë–º –¥–∞–ª—å—à–µ (TMDb)

    # --- Lens (bytes -> Spaces -> Google Lens -> candidates -> TMDb) ---
    # NOTE: works only if image_bytes is a real JPG/PNG; dummy bytes will produce empty cands.
    try:
        lens_cands, lens_tag = await image_bytes_to_tmdb_candidates(
            image_bytes,
            ext="jpg",
            use_serpapi_lens=True,
            hl=("ru" if (lang or "ru") == "ru" else "en"),
            prefix="frames",
        )
    except Exception:
        lens_cands, lens_tag = [], "lens_fail"
    _d(
        "vision.lens", lens_tag=lens_tag, lens_cands=(lens_cands or [])[:8]
    )  # DBG_VISION_LENS_V2
    best_lens_fallback: list[str] = []

    if lens_cands:
        try:
            items = []
            used_cand = ""

            ordered = _pick_best_lens_candidates(lens_cands, limit=12)
            ordered = (ordered or [])[:5]  # hard cap: 3‚Äì5 clean candidates

            best_lens_fallback = ordered[:8]
            _d("vision.lens.pick", ordered=ordered[:10])

            for cand in ordered:
                cand0 = _norm_lens_candidate(cand)
                if not cand0:
                    continue
                # hard drop obvious junk BEFORE touching TMDb
                if _lens_bad_candidate(cand0):
                    continue

                cand0 = _normalize_tmdb_query(_clean_tmdb_query(cand0))
                if not cand0 or len(cand0) < 3:
                    continue
                if _is_bad_media_query(cand0):
                    continue

                cand0 = _tmdb_sanitize_query(_normalize_tmdb_query(cand0))
                if not _good_tmdb_cand(cand0):
                    continue
                items = await _tmdb_best_effort(cand0, limit=5)
                if items:
                    used_cand = cand0
                    break

        except Exception:
            items = []
            used_cand = ""

        if items:
            if user is not None:
                setattr(user, "assistant_mode", "media")
                setattr(user, "assistant_mode_until", now + timedelta(minutes=10))
                if session:
                    await session.commit()

            uid = _media_uid(user)
            if uid and used_cand:
                _media_set(uid, used_cand, items)
            reply = _format_media_ranked(used_cand, items, year_hint=_parse_media_hints(used_cand).get('year'), lang=lang, source='tmdb')
            if img_key:
                _vision_cache_set(img_key, reply)
            return reply


    # Vision ‚Üí TMDb candidates (robust)

    # Vision ‚Üí TMDb candidates (robust)
    caption_str = (caption or "").strip()


    _d(
        "vision.model_out",
        caption=caption_str[:120],
        out_text=(out_text or "")[:250],
        is_generic_caption=_is_generic_media_caption(caption_str),
    )  # DBG_VISION_MODEL_OUT_V2
    # Prefer explicit SEARCH_QUERY from model, then title extracted from the explanation.
    search_q = _normalize_tmdb_query(_extract_search_query_from_text(out_text))
    title_from_text = _normalize_tmdb_query(
        _extract_title_like_from_model_text(out_text)
    )
    _d(
        "vision.extract", search_q=search_q, title_from_text=title_from_text
    )  # DBG_VISION_EXTRACT_V2

    # CAND_LIST_JSON_PRIORITY_V1
    try:
        mj = _extract_media_json_from_model_text(out_text)
        json_queries = _build_tmdb_queries_from_media_json(mj)
        _d("vision.json", json_queries=(json_queries or [])[:10])
    except Exception as e:
        _d("vision.json.fail", err=type(e).__name__, msg=str(e)[:200])
        json_queries = []

    # Build candidate list in priority order (JSON -> model text)
    # Build candidate list in priority order:
    # 1) Vision JSON (actors/title_hints/keywords)
    # 2) Model SEARCH_QUERY / title extracted from text
    # 3) Caption (only if not generic)
    # 4) Lens fallback (only after Vision sources)
    cand_list: list[str] = []

    for c in (json_queries or []):
        c = _tmdb_sanitize_query(_normalize_tmdb_query(c))
        if c and _good_tmdb_cand(c) and c not in cand_list:
            cand_list.append(c)

    for c in (search_q, title_from_text):
        c = _tmdb_sanitize_query(_normalize_tmdb_query(c))
        if c and _good_tmdb_cand(c) and c not in cand_list:
            cand_list.append(c)

    # Caption is used ONLY if it is not a generic phrase like "–û—Ç–∫—É–¥–∞ –∫–∞–¥—Ä?"
    if caption_str and (not _is_generic_media_caption(caption_str)):
        c = _tmdb_sanitize_query(_normalize_tmdb_query(caption_str))
        if c and _good_tmdb_cand(c) and c not in cand_list:
            cand_list.append(c)

    # Lens fallback goes LAST (weak source)
    for c in (best_lens_fallback or [])[:8]:
        c = _tmdb_sanitize_query(_normalize_tmdb_query(c))
        if c and _good_tmdb_cand(c) and c not in cand_list:
            cand_list.append(c)

    _d("vision.cand_list", cand_list=cand_list[:15])  # DBG_VISION_CAND_LIST_V3

    if not cand_list:
        return MEDIA_NOT_FOUND_REPLY_RU

    items: list[dict] = []
    used_query = ""

    # Try TMDb for each candidate
    for q in cand_list:
        if not _good_tmdb_cand(q):
            continue
        _d("vision.tmdb.try", q=q)  # DBG_VISION_TMBD_TRY_V2

        try:
            q = _normalize_tmdb_query(q)
            items = await _tmdb_best_effort(q, limit=5)
            items = [i for i in items if not i.get("adult")]
        except Exception:
            items = []
        if items:
            used_query = q
            try:
                top = items[0]
                _d(
                    "vision.tmdb.hit",
                    used_query=used_query,
                    top_title=(top.get("title") or top.get("name")),
                    top_year=top.get("year"),
                    top_type=top.get("media_type"),
                )
            except Exception:
                pass
            break

    # WEB fallback (only if still empty)
    if (not items) and cand_list:
        try:
            q0 = cand_list[0]
            use_serp = bool(os.getenv("SERPAPI_API_KEY") or os.getenv("SERPAPI_KEY"))
            cands, tag = await web_to_tmdb_candidates(q0, use_serpapi=use_serp)

            for c in cands:
                if _is_bad_media_query(c):
                    continue
                c = _tmdb_sanitize_query(_normalize_tmdb_query(c))
                c = _normalize_tmdb_query(c)
                if not _good_tmdb_cand(c):
                    continue
                items = await _tmdb_best_effort(c, limit=5)
                items = [i for i in items if not i.get("adult")]
                if items:
                    used_query = c
                    break
        except Exception:
            items = []

    if items:
        if user is not None:
            setattr(user, "assistant_mode", "media")
            setattr(user, "assistant_mode_until", now + timedelta(minutes=10))
            if session:
                await session.commit()

        uid = _media_uid(user)
        if uid:
            _media_set(uid, used_query or (cand_list[0] if cand_list else ""), items)

        # Default: return title directly if confident (or single result)
        top = items[0]
        reply = _format_media_ranked(used_query or (cand_list[0] if cand_list else ''), items, year_hint=_parse_media_hints(used_query or (cand_list[0] if cand_list else '')).get('year'), lang=lang, source='tmdb')
        if img_key:
            _vision_cache_set(img_key, reply)
        return reply
    # --- Failsafe: Vision must always return text ---
    final_text = (out_text or "").strip()
    if final_text:
        return final_text
    return MEDIA_NOT_FOUND_REPLY_RU


# --- ROUTER HANDLERS (decorators + bodies) ---




# --- BLOCK: async def run_assistant ---

async def run_assistant(
    user: Optional[User],
    text: str,
    lang: str,
    *,
    session: Any = None,
    has_media: bool = False,
) -> str:
    if AsyncOpenAI is None:
        return "ü§ñ –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (—Å–µ—Ä–≤–µ—Ä –±–µ–∑ openai).\n–ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."

    api_key = _env("OPENAI_API_KEY")
    if not api_key:
        return {
            "uk": "‚ùå –ù–µ –∑–∞–¥–∞–Ω–æ OPENAI_API_KEY. –î–æ–¥–∞–π –∫–ª—é—á —É .env / –∑–º—ñ–Ω–Ω—ñ —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞.",
            "en": "‚ùå OPENAI_API_KEY is missing. Add it to env/.env.",
            "ru": "‚ùå –ù–µ –∑–∞–¥–∞–Ω OPENAI_API_KEY. –î–æ–±–∞–≤—å –∫–ª—é—á –≤ .env / –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.",
        }.get(lang, "‚ùå OPENAI_API_KEY missing.")

    client = AsyncOpenAI(api_key=api_key)
    model = _pick_model()
    plan = _assistant_plan(user)

    kind_marker = _extract_media_kind_marker(text)
    if kind_marker:
        return MEDIA_VIDEO_STUB_REPLY_RU

    now = datetime.now(timezone.utc)

    # --- MEDIA state (DB + in-memory fallback) ---
    uid = _media_uid(user)
    st = _media_get(uid)  # in-memory session, survives even if session=None

    sticky_media_db = False
    if user:
        mode = getattr(user, "assistant_mode", None)
        until = getattr(user, "assistant_mode_until", None)
        if mode == "media" and until and until > now:
            sticky_media_db = True

    # --- INTENT gate (prevents media context from leaking into other topics) ---
    intent_res = detect_intent((text or '').strip() if text else None, has_media=bool(has_media))
    intent = getattr(intent_res, 'intent', None) or intent_res
    is_intent_media = intent in (Intent.MEDIA_IMAGE, Intent.MEDIA_TEXT)

    # If user message is NOT media-related, we must drop sticky media (DB + memory)
    if not is_intent_media:
        if uid:
            try:
                _MEDIA_SESSIONS.pop(uid, None)
            except Exception:
                pass
        if user is not None:
            try:
                mode = getattr(user, 'assistant_mode', None)
                if mode == 'media':
                    setattr(user, 'assistant_mode', None)
                    setattr(user, 'assistant_mode_until', now - timedelta(seconds=1))
                    if session:
                        await session.commit()
            except Exception:
                pass    # IMPORTANT: media mode should trigger ONLY for media intents (or real media message)
    # st/sticky are allowed to keep follow-ups ONLY when current intent is media.
    is_media = bool(has_media) or bool(is_intent_media) or (sticky_media_db and bool(is_intent_media)) or (bool(st) and bool(is_intent_media))


    if is_media:
        _d(
            "media.enter",
            is_media=is_media,
            sticky_media_db=sticky_media_db,
            has_st=bool(st),
            uid=uid,
        )  # DBG_MEDIA_RUN_ASSISTANT_V1
        raw_text = (text or "").strip()

        # 1) User picked an option number: "1", "2", ...
        if st and _looks_like_choice(raw_text):
            idx = int(raw_text) - 1
            opts = st.get("items") or []
            if 0 <= idx < len(opts):
                picked = opts[idx]
                return (
                    _format_media_pick(picked)
                    + "\n\n–•–æ—á–µ—à—å ‚Äî –Ω–∞–ø–∏—à–∏ –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ/–æ–ø–∏—Å–∞–Ω–∏–µ, —è –ø–æ–∏—â—É –µ—â—ë."
                )

        # 1.5) "–ö–∞–∫ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è/–∫–∞–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ" ‚Äî —ç—Ç–æ –Ω–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–∞—Ä–∏–∞–Ω—Ç—ã
        if st and _is_asking_for_title(raw_text):
            opts = st.get("items") or []
            if not opts:
                return MEDIA_NOT_FOUND_REPLY_RU
            return build_media_context(opts) + "\n\nüëâ –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É: ‚úÖ –≠—Ç–æ –æ–Ω–æ / üîÅ –î—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã / üß© –£—Ç–æ—á–Ω–∏—Ç—å.\n–ï—Å–ª–∏ –∫–Ω–æ–ø–æ–∫ –Ω–µ—Ç ‚Äî –æ—Ç–≤–µ—Ç—å —Ü–∏—Ñ—Ä–æ–π."
        # 2) Build query (new query vs follow-up hint)# 2) Merge —É—Ç–æ—á–Ω–µ–Ω–∏–µ with previous query
        # 2) Build query (new query vs follow-up hint)
        raw = raw_text
        prev_q = ((st.get("query") if st else "") or "").strip()

        # –Ω–µ –¥–∞—ë–º "—è–¥–æ–≤–∏—Ç—ã–º" —Ñ—Ä–∞–∑–∞–º –ø–æ—Ä—Ç–∏—Ç—å –ø–æ–∏—Å–∫–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
        if st and re.search(
            r"(?i)\b(–Ω–µ\s*—Ç–æ|–Ω–µ\s*–ø–æ–¥—Ö–æ–¥–∏—Ç|–Ω–∏—á–µ–≥–æ\s*–Ω–µ|—Ç–∞–∫–æ–≥–æ\s*—Ñ–∏–ª—å–º–∞|–Ω–µ\s*—Å—É—â–µ—Å—Ç–≤—É–µ—Ç)\b",
            raw,
        ):
            return MEDIA_NOT_FOUND_REPLY_RU

        # –∫–æ—Ä–æ—Ç–∫–æ–µ —É—Ç–æ—á–Ω–µ–Ω–∏–µ (–≥–æ–¥/–∞–∫—Ç—ë—Ä/—Å—Ç—Ä–∞–Ω–∞/—è–∑—ã–∫/—Å–µ—Ä–∏—è/—ç–ø–∏–∑–æ–¥) ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º –∫ –ø—Ä–æ—à–ª–æ–º—É –∑–∞–ø—Ä–æ—Å—É
        raw = _normalize_tmdb_query(raw)
        if st and prev_q and _looks_like_year_or_hint(raw) and len(raw) <= 60:
            query = _tmdb_sanitize_query(_normalize_tmdb_query(f"{prev_q} {raw}"))
        else:
            query = _tmdb_sanitize_query(_clean_media_search_query(raw))
        _d("media.built_query", prev_q=prev_q, raw=raw, query=query)

        # 3) Too generic ‚Üí ask 1 detail
        if len(query) < 6 and ("—Ñ–∏–ª—å–º" in query.lower() or "—á—Ç–æ –∑–∞" in query.lower()):
            # keep media mode alive for follow-ups even without DB session
            if user is not None:
                setattr(user, "assistant_mode", "media")
                setattr(user, "assistant_mode_until", now + timedelta(minutes=10))
                if session:
                    await session.commit()
            return MEDIA_NOT_FOUND_REPLY_RU

        # 4) Best-effort TMDb search (ru first, fallback en, year filter, dedupe, sort)
        cleaned = _normalize_tmdb_query(query)
        query = _tmdb_sanitize_query(_normalize_tmdb_query(cleaned or query))

        try:
            items = []

            # üîπ First try direct search by model/caption query
            items = await _tmdb_best_effort(query, limit=5)
            items = _scrub_media_items(items)
            _d(
                "media.tmdb.primary",
                q=query,
                n=len(items or []),
                top=((items or [{}])[0].get("title") or (items or [{}])[0].get("name"))
                if items
                else None,
            )

            # üîπ If nothing found ‚Äî use parsed hints
            hints = _parse_media_hints(query)
            if (not items) and hints.get("keywords"):
                items = await _tmdb_best_effort(hints["keywords"], limit=5)

            if not items and hints.get("cast"):
                from app.services.media_search import (
                    tmdb_discover_with_people,
                    tmdb_search_person,
                )

                for actor in hints["cast"]:
                    pid = await tmdb_search_person(actor)
                    if pid:
                        items = await tmdb_discover_with_people(
                            pid,
                            year=hints.get("year"),
                            kind=hints.get("kind"),
                        )
                        if items:
                            break

        except Exception:
            items = []

        # If user sent a long free-form scene description, TMDb guesses are often noisy.
        # In that case, force WEB pipeline to extract the real title.
        try:
            if items and raw and _looks_like_freeform_media_query(raw):
                items = []
        except Exception:
            pass

        # --- WEB fallback (cheap -> expensive) ---
        # –ø–æ—Ä—è–¥–æ–∫:
        # 1) wiki/brave (–±–µ–∑ SerpAPI)
        # 2) SerpAPI —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –∫–ª—é—á
        if not items and query:
            query = _normalize_tmdb_query(query)
            async def _try_cands(cands: list[str]) -> list[dict]:
                out: list[dict] = []
                for c in (cands or [])[:15]:
                    if _is_bad_media_query(c):
                        continue
                    c = _tmdb_sanitize_query(_normalize_tmdb_query(c))
                    if not _good_tmdb_cand(c):
                        continue
                    out = await _tmdb_best_effort(c, limit=5)
                    if out:
                        return out
                return out

            try:
                # --- media refinement guard ---
                # If user sends non-digit while media session is active, treat it as query refinement.
                if is_intent_media and (st or sticky_media_db) and text:
                    t = text.strip()
                    if t and (not re.fullmatch(r"\d+", t)) and (not t.startswith("/")):
                        query = t
                        items = []
                # --- end guard ---
                cands, tag = await web_to_tmdb_candidates(query, use_serpapi=False)
                _d(
                    "media.web.cands",
                    use_serpapi=False,
                    tag=tag,
                    n=len(cands or []),
                    sample=(cands or [])[:5],
                )
                items = await _try_cands(cands)
            except Exception:
                items = []

            # SerpAPI ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—Å—ë –µ—â—ë –ø—É—Å—Ç–æ –∏ —Ä–µ–∞–ª—å–Ω–æ –µ—Å—Ç—å –∫–ª—é—á
            if (not items) and (
                os.getenv("SERPAPI_API_KEY") or os.getenv("SERPAPI_KEY")
            ):
                try:
                    cands, tag = await web_to_tmdb_candidates(query, use_serpapi=True)
                    _d(
                        "media.web.cands_serp",
                        use_serpapi=True,
                        tag=tag,
                        n=len(cands or []),
                        sample=(cands or [])[:5],
                    )
                    items = await _try_cands(cands)
                except Exception:
                    pass

        # keep sticky media mode (DB if possible)
        if user is not None:
            setattr(user, "assistant_mode", "media")
            setattr(user, "assistant_mode_until", now + timedelta(minutes=10))
            if session:
                await session.commit()

        if not items:
            # keep last query in memory so next hint still treated as media
            if uid:
                _media_set(uid, query, [])
            return MEDIA_NOT_FOUND_REPLY_RU

        items = _scrub_media_items(items)
        if uid:
            _media_set(uid, query, items)
        return _format_media_ranked(query, items, year_hint=_parse_media_hints(query).get('year'), lang=lang, source='tmdb')

    # ---- Normal assistant (non-media) ----
    ctx = await build_context(session, user, lang, plan)

    prev_id = getattr(user, "assistant_prev_response_id", None) if user else None
    if user:
        last_used = getattr(user, "assistant_last_used_at", None)
        if last_used and (datetime.now(timezone.utc) - last_used) > timedelta(hours=24):
            prev_id = None

    prompt = f"Context:\n{ctx}\n\nUser message:\n" + (text or "") + "\n"

    resp = await client.responses.create(
        previous_response_id=prev_id,
        model=model,
        instructions=_instructions(lang, plan),
        input=prompt,
        max_output_tokens=(260 if plan == "basic" else 650),
    )

    if session:
        await log_llm_usage(
            session,
            user_id=getattr(user, "id", None) if user else None,
            feature="assistant",
            model=model,
            plan=plan,
            resp=resp,
            meta={"lang": lang},
        )

    out_text = (getattr(resp, "output_text", None) or "").strip()

    resp_id = getattr(resp, "id", None)
    if session and user and resp_id:
        changed = False
        if user.assistant_prev_response_id != str(resp_id):
            user.assistant_prev_response_id = str(resp_id)
            changed = True
        user.assistant_last_used_at = datetime.now(timezone.utc)
        changed = True

        if changed:
            await session.commit()

    if out_text:
        return out_text

    try:
        return str(getattr(resp, "output", "")).strip() or "‚ö†Ô∏è Empty response."
    except Exception:
        return "‚ö†Ô∏è –ù–µ —Å–º–æ–≥ –ø—Ä–æ—á–∏—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏."








# --- BLOCK: def run_assistant ---

async def run_assistant(
    user: Optional[User],
    text: str,
    lang: str,
    *,
    session: Any = None,
    has_media: bool = False,
) -> str:
    if AsyncOpenAI is None:
        return "ü§ñ –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (—Å–µ—Ä–≤–µ—Ä –±–µ–∑ openai).\n–ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."

    api_key = _env("OPENAI_API_KEY")
    if not api_key:
        return {
            "uk": "‚ùå –ù–µ –∑–∞–¥–∞–Ω–æ OPENAI_API_KEY. –î–æ–¥–∞–π –∫–ª—é—á —É .env / –∑–º—ñ–Ω–Ω—ñ —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞.",
            "en": "‚ùå OPENAI_API_KEY is missing. Add it to env/.env.",
            "ru": "‚ùå –ù–µ –∑–∞–¥–∞–Ω OPENAI_API_KEY. –î–æ–±–∞–≤—å –∫–ª—é—á –≤ .env / –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.",
        }.get(lang, "‚ùå OPENAI_API_KEY missing.")

    client = AsyncOpenAI(api_key=api_key)
    model = _pick_model()
    plan = _assistant_plan(user)

    kind_marker = _extract_media_kind_marker(text)
    if kind_marker:
        return MEDIA_VIDEO_STUB_REPLY_RU

    now = datetime.now(timezone.utc)

    # --- MEDIA state (DB + in-memory fallback) ---
    uid = _media_uid(user)
    st = _media_get(uid)  # in-memory session, survives even if session=None

    sticky_media_db = False
    if user:
        mode = getattr(user, "assistant_mode", None)
        until = getattr(user, "assistant_mode_until", None)
        if mode == "media" and until and until > now:
            sticky_media_db = True

    # --- INTENT gate (prevents media context from leaking into other topics) ---
    intent_res = detect_intent((text or '').strip() if text else None, has_media=bool(has_media))
    intent = getattr(intent_res, 'intent', None) or intent_res
    is_intent_media = intent in (Intent.MEDIA_IMAGE, Intent.MEDIA_TEXT)

    # If user message is NOT media-related, we must drop sticky media (DB + memory)
    if not is_intent_media:
        if uid:
            try:
                _MEDIA_SESSIONS.pop(uid, None)
            except Exception:
                pass
        if user is not None:
            try:
                mode = getattr(user, 'assistant_mode', None)
                if mode == 'media':
                    setattr(user, 'assistant_mode', None)
                    setattr(user, 'assistant_mode_until', now - timedelta(seconds=1))
                    if session:
                        await session.commit()
            except Exception:
                pass    # IMPORTANT: media mode should trigger ONLY for media intents (or real media message)
    # st/sticky are allowed to keep follow-ups ONLY when current intent is media.
    is_media = bool(has_media) or bool(is_intent_media) or (sticky_media_db and bool(is_intent_media)) or (bool(st) and bool(is_intent_media))


    if is_media:
        _d(
            "media.enter",
            is_media=is_media,
            sticky_media_db=sticky_media_db,
            has_st=bool(st),
            uid=uid,
        )  # DBG_MEDIA_RUN_ASSISTANT_V1
        raw_text = (text or "").strip()

        # 1) User picked an option number: "1", "2", ...
        if st and _looks_like_choice(raw_text):
            idx = int(raw_text) - 1
            opts = st.get("items") or []
            if 0 <= idx < len(opts):
                picked = opts[idx]
                return (
                    _format_media_pick(picked)
                    + "\n\n–•–æ—á–µ—à—å ‚Äî –Ω–∞–ø–∏—à–∏ –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ/–æ–ø–∏—Å–∞–Ω–∏–µ, —è –ø–æ–∏—â—É –µ—â—ë."
                )

        # 1.5) "–ö–∞–∫ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è/–∫–∞–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ" ‚Äî —ç—Ç–æ –Ω–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–∞—Ä–∏–∞–Ω—Ç—ã
        if st and _is_asking_for_title(raw_text):
            opts = st.get("items") or []
            if not opts:
                return MEDIA_NOT_FOUND_REPLY_RU
            return build_media_context(opts) + "\n\nüëâ –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É: ‚úÖ –≠—Ç–æ –æ–Ω–æ / üîÅ –î—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã / üß© –£—Ç–æ—á–Ω–∏—Ç—å.\n–ï—Å–ª–∏ –∫–Ω–æ–ø–æ–∫ –Ω–µ—Ç ‚Äî –æ—Ç–≤–µ—Ç—å —Ü–∏—Ñ—Ä–æ–π."
        # 2) Build query (new query vs follow-up hint)# 2) Merge —É—Ç–æ—á–Ω–µ–Ω–∏–µ with previous query
        # 2) Build query (new query vs follow-up hint)
        raw = raw_text
        prev_q = ((st.get("query") if st else "") or "").strip()

        # –Ω–µ –¥–∞—ë–º "—è–¥–æ–≤–∏—Ç—ã–º" —Ñ—Ä–∞–∑–∞–º –ø–æ—Ä—Ç–∏—Ç—å –ø–æ–∏—Å–∫–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
        if st and re.search(
            r"(?i)\b(–Ω–µ\s*—Ç–æ|–Ω–µ\s*–ø–æ–¥—Ö–æ–¥–∏—Ç|–Ω–∏—á–µ–≥–æ\s*–Ω–µ|—Ç–∞–∫–æ–≥–æ\s*—Ñ–∏–ª—å–º–∞|–Ω–µ\s*—Å—É—â–µ—Å—Ç–≤—É–µ—Ç)\b",
            raw,
        ):
            return MEDIA_NOT_FOUND_REPLY_RU

        # –∫–æ—Ä–æ—Ç–∫–æ–µ —É—Ç–æ—á–Ω–µ–Ω–∏–µ (–≥–æ–¥/–∞–∫—Ç—ë—Ä/—Å—Ç—Ä–∞–Ω–∞/—è–∑—ã–∫/—Å–µ—Ä–∏—è/—ç–ø–∏–∑–æ–¥) ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º –∫ –ø—Ä–æ—à–ª–æ–º—É –∑–∞–ø—Ä–æ—Å—É
        raw = _normalize_tmdb_query(raw)
        if st and prev_q and _looks_like_year_or_hint(raw) and len(raw) <= 60:
            query = _tmdb_sanitize_query(_normalize_tmdb_query(f"{prev_q} {raw}"))
        else:
            query = _tmdb_sanitize_query(_clean_media_search_query(raw))
        _d("media.built_query", prev_q=prev_q, raw=raw, query=query)

        # 3) Too generic ‚Üí ask 1 detail
        if len(query) < 6 and ("—Ñ–∏–ª—å–º" in query.lower() or "—á—Ç–æ –∑–∞" in query.lower()):
            # keep media mode alive for follow-ups even without DB session
            if user is not None:
                setattr(user, "assistant_mode", "media")
                setattr(user, "assistant_mode_until", now + timedelta(minutes=10))
                if session:
                    await session.commit()
            return MEDIA_NOT_FOUND_REPLY_RU

        # 4) Best-effort TMDb search (ru first, fallback en, year filter, dedupe, sort)
        cleaned = _normalize_tmdb_query(query)
        query = _tmdb_sanitize_query(_normalize_tmdb_query(cleaned or query))

        try:
            items = []

            # üîπ First try direct search by model/caption query
            items = await _tmdb_best_effort(query, limit=5)
            items = _scrub_media_items(items)
            _d(
                "media.tmdb.primary",
                q=query,
                n=len(items or []),
                top=((items or [{}])[0].get("title") or (items or [{}])[0].get("name"))
                if items
                else None,
            )

            # üîπ If nothing found ‚Äî use parsed hints
            hints = _parse_media_hints(query)
            if (not items) and hints.get("keywords"):
                items = await _tmdb_best_effort(hints["keywords"], limit=5)

            if not items and hints.get("cast"):
                from app.services.media_search import (
                    tmdb_discover_with_people,
                    tmdb_search_person,
                )

                for actor in hints["cast"]:
                    pid = await tmdb_search_person(actor)
                    if pid:
                        items = await tmdb_discover_with_people(
                            pid,
                            year=hints.get("year"),
                            kind=hints.get("kind"),
                        )
                        if items:
                            break

        except Exception:
            items = []

        # If user sent a long free-form scene description, TMDb guesses are often noisy.
        # In that case, force WEB pipeline to extract the real title.
        try:
            if items and raw and _looks_like_freeform_media_query(raw):
                items = []
        except Exception:
            pass

        # --- WEB fallback (cheap -> expensive) ---
        # –ø–æ—Ä—è–¥–æ–∫:
        # 1) wiki/brave (–±–µ–∑ SerpAPI)
        # 2) SerpAPI —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –∫–ª—é—á
        if not items and query:
            query = _normalize_tmdb_query(query)
            async def _try_cands(cands: list[str]) -> list[dict]:
                out: list[dict] = []
                for c in (cands or [])[:15]:
                    if _is_bad_media_query(c):
                        continue
                    c = _tmdb_sanitize_query(_normalize_tmdb_query(c))
                    if not _good_tmdb_cand(c):
                        continue
                    out = await _tmdb_best_effort(c, limit=5)
                    if out:
                        return out
                return out

            try:
                # --- media refinement guard ---
                # If user sends non-digit while media session is active, treat it as query refinement.
                if is_intent_media and (st or sticky_media_db) and text:
                    t = text.strip()
                    if t and (not re.fullmatch(r"\d+", t)) and (not t.startswith("/")):
                        query = t
                        items = []
                # --- end guard ---
                cands, tag = await web_to_tmdb_candidates(query, use_serpapi=False)
                _d(
                    "media.web.cands",
                    use_serpapi=False,
                    tag=tag,
                    n=len(cands or []),
                    sample=(cands or [])[:5],
                )
                items = await _try_cands(cands)
            except Exception:
                items = []

            # SerpAPI ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—Å—ë –µ—â—ë –ø—É—Å—Ç–æ –∏ —Ä–µ–∞–ª—å–Ω–æ –µ—Å—Ç—å –∫–ª—é—á
            if (not items) and (
                os.getenv("SERPAPI_API_KEY") or os.getenv("SERPAPI_KEY")
            ):
                try:
                    cands, tag = await web_to_tmdb_candidates(query, use_serpapi=True)
                    _d(
                        "media.web.cands_serp",
                        use_serpapi=True,
                        tag=tag,
                        n=len(cands or []),
                        sample=(cands or [])[:5],
                    )
                    items = await _try_cands(cands)
                except Exception:
                    pass

        # keep sticky media mode (DB if possible)
        if user is not None:
            setattr(user, "assistant_mode", "media")
            setattr(user, "assistant_mode_until", now + timedelta(minutes=10))
            if session:
                await session.commit()

        if not items:
            # keep last query in memory so next hint still treated as media
            if uid:
                _media_set(uid, query, [])
            return MEDIA_NOT_FOUND_REPLY_RU

        items = _scrub_media_items(items)
        if uid:
            _media_set(uid, query, items)
        return _format_media_ranked(query, items, year_hint=_parse_media_hints(query).get('year'), lang=lang, source='tmdb')

    # ---- Normal assistant (non-media) ----
    ctx = await build_context(session, user, lang, plan)

    prev_id = getattr(user, "assistant_prev_response_id", None) if user else None
    if user:
        last_used = getattr(user, "assistant_last_used_at", None)
        if last_used and (datetime.now(timezone.utc) - last_used) > timedelta(hours=24):
            prev_id = None

    prompt = f"Context:\n{ctx}\n\nUser message:\n" + (text or "") + "\n"

    resp = await client.responses.create(
        previous_response_id=prev_id,
        model=model,
        instructions=_instructions(lang, plan),
        input=prompt,
        max_output_tokens=(260 if plan == "basic" else 650),
    )

    if session:
        await log_llm_usage(
            session,
            user_id=getattr(user, "id", None) if user else None,
            feature="assistant",
            model=model,
            plan=plan,
            resp=resp,
            meta={"lang": lang},
        )

    out_text = (getattr(resp, "output_text", None) or "").strip()

    resp_id = getattr(resp, "id", None)
    if session and user and resp_id:
        changed = False
        if user.assistant_prev_response_id != str(resp_id):
            user.assistant_prev_response_id = str(resp_id)
            changed = True
        user.assistant_last_used_at = datetime.now(timezone.utc)
        changed = True

        if changed:
            await session.commit()

    if out_text:
        return out_text

    try:
        return str(getattr(resp, "output", "")).strip() or "‚ö†Ô∏è Empty response."
    except Exception:
        return "‚ö†Ô∏è –ù–µ —Å–º–æ–≥ –ø—Ä–æ—á–∏—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏."








==========================================================================================

