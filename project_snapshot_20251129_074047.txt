# Project snapshot @ 2025-11-29 07:40:47
PWD: /Users/sverepov/Desktop/Projects/diary-bot

## Files (87):
.backup_20251114153210/app/handlers/language.py
.backup_20251114153210/app/handlers/premium.py
.backup_20251114153210/app/keyboards.py
.backup_20251114153210/app/services/nlp.py
.backup_20251114153210/app/services/reminders.py
.env
alembic.ini
app.py
app/__init__.py
app/api.py
app/api/__init__.py
app/api/coinbase.py
app/bot.py
app/commands.py
app/config.py
app/db/__init__.py
app/db/core.py
app/db/session.py
app/db_conflict.py
app/features/__init__.py
app/features/calories.py
app/features/chat_mode.py
app/features/meditation.py
app/features/music.py
app/filters/buttons.py
app/handlers/__init__.py
app/handlers/common.py
app/handlers/erase.py
app/handlers/export.py
app/handlers/journal.py
app/handlers/language.py
app/handlers/premium.py
app/handlers/premium_reset.py
app/handlers/privacy.py
app/handlers/reminders.py
app/handlers/report.py
app/handlers/start.py
app/hooks.py
app/http.py
app/i18n.py
app/i18n/en.json
app/i18n/ru.json
app/i18n/uk.json
app/keyboards.py
app/main.py
app/middlewares/lang.py
app/models.py
app/models/__init__.py
app/models/bug_report.py
app/models/journal.py
app/models/mixins.py
app/models/payment.py
app/models/reminder.py
app/models/user.py
app/payments/__init__.py
app/payments/coinbase_webhook.py
app/payments/now.py
app/payments/nowp.py
app/payments/nowpayments.py
app/scheduler.py
app/services/__init__.py
app/services/exporter.py
app/services/i18n.py
app/services/nlp.py
app/services/payments.py
app/services/payments/__init__.py
app/services/payments/coinbase.py
app/services/reminders.py
app/texts.py
app/urls.py
app/web.py
app/webhooks/__init__.py
app/webhooks/coinbase.py
backups_1764378738/main.py
backups_1764378738/premium.py
locales/ru.json
locales/uk.json
migrations/env.py
migrations/versions/b0b54fc02dab_payments_table.py
project_snapshot_20251129_012749.txt
README.md
requirements.txt
scripts/dev.env
scripts_msgfmt.py
storage/music/319145673/index.json
storage/music/377555215/index.json
storage/music/6657238126/index.json

==========================================================================================
# .backup_20251114153210/app/handlers/language.py
==========================================================================================
# app/handlers/language.py
from __future__ import annotations

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.keyboards import get_main_kb, LANGUAGE_LABELS
from app.models.user import User

router = Router()

# –†–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ –∫–æ–¥—ã (–≤–≤–æ–¥ RU/UK/UA/EN -> —Å–æ—Ö—Ä–∞–Ω—è–µ–º ru/uk/en)
LANGS = {"RU": "ru", "UK": "uk", "UA": "uk", "EN": "en"}

PROMPTS = {
    "ru": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫: RU / UK / EN (–æ—Ç–ø—Ä–∞–≤—å –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º)",
    "uk": "–í–∏–±–µ—Ä–∏ –º–æ–≤—É: RU / UK / EN (–≤—ñ–¥–ø—Ä–∞–≤ –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º)",
    "en": "Choose language: RU / UK / EN (send one word)",
}

def _pick_locale(user: User | None) -> str:
    loc = (user.locale if user and getattr(user, "locale", None) else "ru")
    return loc if loc in PROMPTS else "ru"

async def _get_or_create_user(session: AsyncSession, tg_id: int) -> User:
    user = (await session.execute(
        select(User).where(User.tg_id == tg_id)
    )).scalar_one_or_none()
    if not user:
        user = User(tg_id=tg_id, locale="ru")
        session.add(user)
        await session.flush()
    return user

# –û—Ç–∫—Ä—ã—Ç—å –≤—ã–±–æ—Ä —è–∑—ã–∫–∞: /language
@router.message(Command("language"))
async def language_cmd(m: Message, session: AsyncSession):
    user = await _get_or_create_user(session, m.from_user.id)
    await m.answer(PROMPTS[_pick_locale(user)], reply_markup=None)

# –û—Ç–∫—Ä—ã—Ç—å –≤—ã–±–æ—Ä —è–∑—ã–∫–∞: –ø–æ –∫–Ω–æ–ø–∫–µ –∏–∑ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é (—Å —ç–º–æ–¥–∑–∏)
@router.message(F.text.in_(LANGUAGE_LABELS))
async def language_btn(m: Message, session: AsyncSession):
    user = await _get_or_create_user(session, m.from_user.id)
    await m.answer(PROMPTS[_pick_locale(user)], reply_markup=None)

# –û—Ç–∫—Ä—ã—Ç—å –≤—ã–±–æ—Ä —è–∑—ã–∫–∞: –µ—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –≤—Ä—É—á–Ω—É—é –Ω–∞–ø–∏—Å–∞–ª "language|—è–∑—ã–∫|–º–æ–≤–∞"
@router.message(F.text.regexp(r"(?i)^\s*(language|—è–∑—ã–∫|–º–æ–≤–∞)\s*$"))
async def language_word(m: Message, session: AsyncSession):
    user = await _get_or_create_user(session, m.from_user.id)
    await m.answer(PROMPTS[_pick_locale(user)], reply_markup=None)

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —è–∑—ã–∫–∞ –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º: RU/UK/UA/EN (—Ä–µ–≥–∏—Å—Ç—Ä –Ω–µ–≤–∞–∂–µ–Ω)
@router.message(F.text.regexp(r"(?i)^\s*(ru|uk|ua|en)\s*$"))
async def language_set(m: Message, session: AsyncSession):
    code = LANGS.get(m.text.strip().upper(), "ru")

    user = await _get_or_create_user(session, m.from_user.id)
    if user.locale != code:
        user.locale = code
        session.add(user)
        await session.commit()

    msg = {
        "ru": "–ì–æ—Ç–æ–≤–æ. –Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª—ë–Ω.",
        "uk": "–ì–æ—Ç–æ–≤–æ. –ú–æ–≤—É –æ–Ω–æ–≤–ª–µ–Ω–æ.",
        "en": "Done. Language updated.",
    }.get(code, "Done.")
    await m.answer(msg, reply_markup=get_main_kb(code))
==========================================================================================
# .backup_20251114153210/app/handlers/premium.py
==========================================================================================
# app/handlers/premium.py
from aiogram import Router
from aiogram.filters import Command
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo

from app.models.user import User
from app.models.journal import JournalEntry
from app.models.reminder import Reminder
from app.config import settings

from app.services.payments.coinbase import create_coinbase_charge, build_pay_kb

router = Router()

TEXTS = {
    "ru": {
        "trial_on":  "üéÅ –ü–æ–¥–∞—Ä–æ–∫: {hours} —á –ü—Ä–µ–º–∏—É–º–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã! –î–æ—Å—Ç—É–ø–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã.",
        "status_on": "üíé –ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {until} ({tz}). –¶–µ–Ω–∞ –ø–æ—Å–ª–µ ‚Äî ${price}/–º–µ—Å.",
        "status_off":"–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. ${price}/–º–µ—Å. –û—Ç–∫—Ä–æ—é—Ç—Å—è —ç–∫—Å–ø–æ—Ä—Ç –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã.",
        "start":     "/start",
    },
    "uk": {
        "trial_on":  "üéÅ –ü–æ–¥–∞—Ä—É–Ω–æ–∫: –ü—Ä–µ–º—ñ—É–º –Ω–∞ {hours} –≥–æ–¥ –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ! –î–æ—Å—Ç—É–ø–Ω—ñ –µ–∫—Å–ø–æ—Ä—Ç —ñ —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ –∑–≤—ñ—Ç–∏.",
        "status_on": "üíé –ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {until} ({tz}). –î–∞–ª—ñ ‚Äî ${price}/–º—ñ—Å.",
        "status_off":"–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. ${price}/–º—ñ—Å. –í—ñ–¥–∫—Ä–∏—é—Ç—å—Å—è –µ–∫—Å–ø–æ—Ä—Ç —ñ —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ –∑–≤—ñ—Ç–∏.",
        "start":     "/start",
    },
    "en": {
        "trial_on":  "üéÅ Gift: Premium for {hours}h activated! Export & advanced reports unlocked.",
        "status_on": "üíé Premium is active until {until} ({tz}). After that ‚Äî ${price}/mo.",
        "status_off":"Premium is inactive. ${price}/mo. Export & advanced reports will be available.",
        "start":     "/start",
    },
}

def _t(lang: str, key: str, **kw) -> str:
    return TEXTS.get(lang, TEXTS["ru"]).get(key, key).format(**kw)

def _pick_lang(user: User | None, fallback: str = None) -> str:
    loc = (getattr(user, "locale", None) or fallback or settings.default_locale or "ru").lower()
    return loc if loc in TEXTS else "ru"

def is_premium_active(user: User, now: datetime | None = None) -> bool:
    now = now or datetime.now(timezone.utc)
    return bool(user.premium_until and user.premium_until > now)

async def maybe_grant_trial(session: AsyncSession, user: User, bot) -> None:
    """
    –î–∞—ë–º —Ç—Ä–∏–∞–ª 1 —Ä–∞–∑, –∫–æ–≥–¥–∞ —É —é–∑–µ—Ä–∞ ‚â•2 –∑–∞–ø–∏—Å–µ–π –∏ ‚â•1 –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.
    –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–µ—Ä—ë—Ç—Å—è –∏–∑ settings.premium_trial_hours.
    """
    if user.premium_trial_granted:
        return

    j_count = (await session.execute(
        select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
    )).scalar() or 0

    r_count = (await session.execute(
        select(func.count()).select_from(Reminder).where(Reminder.user_id == user.id)
    )).scalar() or 0

    if j_count < 2 or r_count < 1:
        return

    user.premium_trial_granted = True
    user.premium_until = datetime.now(timezone.utc) + timedelta(hours=settings.premium_trial_hours)
    session.add(user)
    await session.commit()

    lang = _pick_lang(user)
    try:
        await bot.send_message(
            user.tg_id,
            _t(lang, "trial_on", hours=settings.premium_trial_hours),
        )
    except Exception:
        pass

@router.message(Command("premium"))
async def premium_status(m: Message, session: AsyncSession, lang: str | None = None):
    res = await session.execute(select(User).where(User.tg_id == m.from_user.id))
    user = res.scalar_one_or_none()
    if not user:
        return await m.answer(_t("ru", "start"))

    lang = lang or _pick_lang(user)

    if is_premium_active(user):
        try:
            tz = ZoneInfo(user.tz or settings.default_tz)
        except Exception:
            tz = ZoneInfo(settings.default_tz)
        local_until = user.premium_until.astimezone(tz)
        await m.answer(
            _t(
                lang,
                "status_on",
                until=local_until.strftime("%Y-%m-%d %H:%M"),
                tz=(user.tz or settings.default_tz),
                price=settings.premium_price_usd,
            )
        )
    else:
        await m.answer(_t(lang, "status_off", price=settings.premium_price_usd))

def _tr(lang: str, ru: str, uk: str, en: str) -> str:
    if lang == "uk":
        return uk
    if lang == "en":
        return en
    return ru

from sqlalchemy import select
from app.models.user import User

@router.message(Command("buy"))
async def premium_buy(m: Message, session: AsyncSession, lang: str | None = None):
    user = (await session.execute(select(User).where(User.tg_id == m.from_user.id))).scalar_one_or_none()
    if not user:
        return await m.answer("/start")
    lang = lang or (getattr(user, "locale", None) or "ru")
    price = settings.premium_price_usd
    try:
        pay, hosted = await create_coinbase_charge(session=session, user=user, plan="monthly", amount_usd=price, description="Diary Assistant Premium ‚Äî 1 month")
    except Exception:
        return await m.answer(_tr(lang, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á—ë—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", "–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ —Ä–∞—Ö—É–Ω–∫—É. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.", "Failed to create invoice. Try again later."))
    await m.answer(_tr(lang, f"–ü—Ä–µ–º–∏—É–º –Ω–∞ 30 –¥–Ω–µ–π ‚Äî ${price}. –ù–∞–∂–º–∏, —á—Ç–æ–±—ã –æ–ø–ª–∞—Ç–∏—Ç—å:", f"–ü—Ä–µ–º—ñ—É–º –Ω–∞ 30 –¥–Ω—ñ–≤ ‚Äî ${price}. –ù–∞—Ç–∏—Å–Ω–∏, —â–æ–± –æ–ø–ª–∞—Ç–∏—Ç–∏:", f"Premium for 30 days ‚Äî ${price}. Tap to pay:"), reply_markup=build_pay_kb(hosted))

==========================================================================================
# .backup_20251114153210/app/keyboards.py
==========================================================================================
# app/keyboards.py
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

# –¢–µ–∫—Å—Ç—ã –∫–Ω–æ–ø–æ–∫ –ø–æ –ª–æ–∫–∞–ª—è–º
_LOCALE_TEXTS = {
    "ru": {
        "language": "üåê –Ø–∑—ã–∫",
        "privacy":  "üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
        "report":   "üõ†Ô∏è –°–æ–æ–±—â–∏—Ç—å –æ–± –æ—à–∏–±–∫–µ",
        "premium":  "üíé –ü—Ä–µ–º–∏—É–º",
        "journal":  "üìù –ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å",
        "reminder": "‚è∞ –°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ",
        "stats":    "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        "placeholder": "–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ‚Ä¶",
    },
    "uk": {
        "language": "üåê –ú–æ–≤–∞",
        "privacy":  "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
        "report":   "üõ†Ô∏è –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
        "premium":  "üíé –ü—Ä–µ–º—ñ—É–º",
        "journal":  "üìù –ù–æ–≤–∏–π –∑–∞–ø–∏—Å",
        "reminder": "‚è∞ –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è",
        "stats":    "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        "placeholder": "–ù–∞–ø–∏—à—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è‚Ä¶",
    },
    "en": {
        "language": "üåê Language",
        "privacy":  "üîí Privacy",
        "report":   "üõ†Ô∏è Report bug",
        "premium":  "üíé Premium",
        "journal":  "üìù New entry",
        "reminder": "‚è∞ Create reminder",
        "stats":    "üìä Stats",
        "placeholder": "Write a message‚Ä¶",
    },
}

def _build_kb(loc: str) -> ReplyKeyboardMarkup:
    t = _LOCALE_TEXTS.get(loc, _LOCALE_TEXTS["ru"])
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=t["journal"]), KeyboardButton(text=t["reminder"])],
            [KeyboardButton(text=t["stats"]),   KeyboardButton(text=t["premium"])],
            [KeyboardButton(text=t["language"]), KeyboardButton(text=t["privacy"])],
            [KeyboardButton(text=t["report"])],
        ],
        resize_keyboard=True,
        input_field_placeholder=t["placeholder"],
    )

def get_main_kb(locale: str | None):
    """–í–µ—Ä–Ω—É—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –ø–æ –ª–æ–∫–∞–ª–∏ ('ru'|'uk'|'en')."""
    loc = (locale or "ru").lower()
    return _build_kb(loc)

# –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∏–º–ø–æ—Ä—Ç–æ–º
get_main_kb = get_main_kb

# –ù–∞–±–æ—Ä—ã –ª–µ–π–±–ª–æ–≤ (–¥–ª—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö)
PRIVACY_LABELS  = { _LOCALE_TEXTS[k]["privacy"]  for k in _LOCALE_TEXTS }
LANGUAGE_LABELS = { _LOCALE_TEXTS[k]["language"] for k in _LOCALE_TEXTS }
REPORT_LABELS   = { _LOCALE_TEXTS[k]["report"]   for k in _LOCALE_TEXTS }
PREMIUM_LABELS  = { _LOCALE_TEXTS[k]["premium"]  for k in _LOCALE_TEXTS }
JOURNAL_LABELS  = { _LOCALE_TEXTS[k]["journal"]  for k in _LOCALE_TEXTS }
REMINDER_LABELS = { _LOCALE_TEXTS[k]["reminder"] for k in _LOCALE_TEXTS }
STATS_LABELS    = { _LOCALE_TEXTS[k]["stats"]    for k in _LOCALE_TEXTS }

# –£–¥–æ–±–Ω—ã–µ —Ö–µ–ª–ø–µ—Ä—ã
def is_privacy_btn(text: str)  -> bool: return (text or "").strip() in PRIVACY_LABELS
def is_language_btn(text: str) -> bool: return (text or "").strip() in LANGUAGE_LABELS
def is_report_btn(text: str)   -> bool: return (text or "").strip() in REPORT_LABELS
def is_premium_btn(text: str)  -> bool: return (text or "").strip() in PREMIUM_LABELS
def is_journal_btn(text: str)  -> bool: return (text or "").strip() in JOURNAL_LABELS
def is_reminder_btn(text: str) -> bool: return (text or "").strip() in REMINDER_LABELS
def is_stats_btn(text: str)    -> bool: return (text or "").strip() in STATS_LABELS
==========================================================================================
# .backup_20251114153210/app/services/nlp.py
==========================================================================================
from __future__ import annotations

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, time
from typing import Optional, Literal, List
from zoneinfo import ZoneInfo

# =======================
# Public API
# =======================

@dataclass
class ParsedReminder:
    """
    –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ–∑–¥–∞–Ω–∏—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.
    - –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ: next_run_utc –∑–∞–ø–æ–ª–Ω–µ–Ω
    - –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–µ—Å—è: cron –∑–∞–ø–æ–ª–Ω–µ–Ω (—Ñ–æ—Ä–º–∞—Ç CRON: "m h d * dow")
    """
    what: str
    raw_when: str
    next_run_utc: Optional[datetime] = None
    cron: Optional[str] = None


@dataclass
class ToggleRequest:
    """
    –ó–∞–ø—Ä–æ—Å –Ω–∞ –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.
    - action: 'enable' | 'disable'
    - query: —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è (case-insensitive), –µ—Å–ª–∏ –∞–¥—Ä–µ—Å–Ω–æ–µ
    - all: true, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∫–æ –≤—Å–µ–º
    """
    action: Literal["enable", "disable"]
    query: Optional[str] = None
    all: bool = False


@dataclass
class ParseResult:
    """
    –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ª—é–±–æ–π NLP-–∫–æ–º–∞–Ω–¥—ã:
      - intent: 'create' | 'enable' | 'disable'
      - reminder: –¥–ª—è intent='create'
      - toggle:   –¥–ª—è intent in {'enable','disable'}
    """
    intent: Literal["create", "enable", "disable"]
    reminder: Optional[ParsedReminder] = None
    toggle: Optional[ToggleRequest] = None


def parse_any(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParseResult]:
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å:
      1) –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ (enable/disable)
      2) —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (create)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ParseResult –∏–ª–∏ None.
    """
    tgl = parse_toggle(text)
    if tgl:
        return ParseResult(intent=tgl.action, toggle=tgl)

    rem = parse_remind(text, user_tz=user_tz, now=now)
    if rem:
        return ParseResult(intent="create", reminder=rem)

    return None


# =======================
# Reminder create (RU/UK/EN)
# =======================

def parse_remind(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParsedReminder]:
    """
    –ü–æ–Ω–∏–º–∞–µ—Ç:
      RU:  "–Ω–∞–ø–æ–º–Ω–∏ –ø–æ–∑–≤–æ–Ω–∏—Ç—å –º–∞–º–µ —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç"
           "–Ω–∞–ø–æ–º–Ω–∏ –æ–ø–ª–∞—Ç–∏—Ç—å —Å—á–µ—Ç –∑–∞–≤—Ç—Ä–∞ –≤ 09:30"
           "–Ω–∞–ø–æ–º–Ω–∏ —Ç—Ä–µ–Ω—é –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 7:00"
           "–Ω–∞–ø–æ–º–Ω–∏ –≤–æ–¥—É –ø–æ –±—É–¥–Ω—è–º –≤ 10"
           "–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç –∫–∞–∂–¥—É—é —Å—Ä–µ–¥—É –≤ 18:30"
           "–Ω–∞–ø–æ–º–Ω–∏ —É–±–æ—Ä–∫—É –ø–æ –≤—ã—Ö–æ–¥–Ω—ã–º –≤ 12"
           "–Ω–∞–ø–æ–º–Ω–∏ –ø–ª–∞—Ç–µ–∂ –∫–∞–∂–¥–æ–≥–æ 5-–≥–æ —á–∏—Å–ª–∞ –≤ 10"
      UK:  "–Ω–∞–≥–∞–¥–∞–π –º–µ–Ω—ñ –≤–æ–¥—É —â–æ–¥–Ω—è –æ 9", "—É –≤–∏—Ö—ñ–¥–Ω—ñ –æ 12", "—â–æ–º—ñ—Å—è—Ü—è 5 —á–∏—Å–ª–∞ –æ 10"
      EN:  "remind me to call mom in 2 hours", "every wednesday at 6:30pm",
           "weekends at noon", "every month on the 5th at 10"
    """
    tz = ZoneInfo(user_tz)
    now = now or datetime.now(tz)

    text_norm = _normalize(text)

    # –°–Ω–∞—á–∞–ª–∞ ‚Äî –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è (cron)
    cron = _parse_recurring_cron(text_norm)
    if cron:
        what = _extract_what(text_norm, recurring=True)
        if not what:
            return None
        return ParsedReminder(what=what, raw_when=text.strip(), cron=cron)

    # –û–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–µ
    dt = _parse_once_datetime(text_norm, now, tz)
    if dt:
        what = _extract_what(text_norm, recurring=False)
        if not what:
            return None
        return ParsedReminder(
            what=what,
            raw_when=text.strip(),
            next_run_utc=dt.astimezone(ZoneInfo("UTC")),
        )

    return None


# =======================
# Toggle (enable/disable)
# =======================

_TOGGLE_ON_WORDS  = r"(?:–≤–∫–ª—é—á–∏|–≤–∫–ª|—É–≤—ñ–º–∫–Ω–∏|—É–≤—ñ–º–∫|on|enable)"
_TOGGLE_OFF_WORDS = r"(?:–≤—ã–∫–ª—é—á–∏|–≤—ã–∫–ª|–≤—ñ–¥–∫–ª—é—á–∏|–≤–∏–º–∫–Ω–∏|–≤–∏–º–∫|off|disable)"
_REMINDER_WORDS = r"(?:–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏(?:–µ|—è)|–Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è|reminder(?:s)?)"
_ALL_WORDS = r"(?:–≤—Å–µ|—É—Å—ñ|–≤—Å—ñ|all)"

_RE_TOGGLE = re.compile(
    rf"(?i)\b(?P<act>{_TOGGLE_ON_WORDS}|{_TOGGLE_OFF_WORDS})\b"
    rf"(?:\s+{_REMINDER_WORDS})?"
    rf"(?:\s+(?:–ø—Ä–æ|–Ω–∞|–ø–æ|about|for))?"
    rf"(?:\s+(?P<all>{_ALL_WORDS}))?"
    rf"(?:\s*(?P<query>.+))?$"
)

def parse_toggle(text: str) -> Optional[ToggleRequest]:
    """–ü–∞—Ä—Å–∏—Ç –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π (RU/UK/EN)."""
    s = _normalize(text)
    m = _RE_TOGGLE.match(s)
    if not m:
        return None

    act = m.group("act")
    action: Literal["enable", "disable"] = "enable" if re.search(rf"^{_TOGGLE_ON_WORDS}$", act, flags=re.I) else "disable"

    is_all = bool(m.group("all") and m.group("all").strip())
    query = (m.group("query") or "").strip()

    if is_all:
        return ToggleRequest(action=action, query=None, all=True)
    if not query:
        return ToggleRequest(action=action, query=None, all=True)

    return ToggleRequest(action=action, query=query, all=False)


# =======================
# Internals
# =======================

# –¢—Ä–∏–≥–≥–µ—Ä—ã —Å–æ–∑–¥–∞–Ω–∏—è
_TRIGGERS = r"(?:–Ω–∞–ø–æ–º–Ω–∏|–Ω–∞–≥–∞–¥–∞–π|remind(?:\s+me\s+to)?)"

# –°–ª—É–∂–µ–±–Ω—ã–µ ¬´—Å—Ü–µ–ø–∫–∏¬ª
_RE_IN = r"(?:—á–µ—Ä–µ–∑|–∑–∞|in)"
_RE_AT = r"(?:–≤|–æ|at|on)"  # 'on' –¥–ª—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π 'on Monday at 6pm'
_RE_TODAY = r"(?:—Å–µ–≥–æ–¥–Ω—è|—Å—å–æ–≥–æ–¥–Ω—ñ|today)"
_RE_TOMORROW = r"(?:–∑–∞–≤—Ç—Ä–∞|tomorrow)"
_RE_EVERY = r"(?:–∫–∞–∂–¥\w+|—â–æ–¥–Ω—è|—â–æ—Ç–∏–∂–Ω—è|—â–æ—Å\w+|every|weekdays|daily|–µ–∂–µ–¥–Ω–µ–≤–Ω–æ)"

# –î–Ω–∏ –Ω–µ–¥–µ–ª–∏
_DOW_MAP = {
    # RU
    "–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫": 1, "–≤—Ç–æ—Ä–Ω–∏–∫": 2, "—Å—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä–≥": 4, "–ø—è—Ç–Ω–∏—Ü–∞": 5, "—Å—É–±–±–æ—Ç–∞": 6, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ": 0, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω–∏–µ": 0,
    # UK
    "–ø–æ–Ω–µ–¥—ñ–ª–æ–∫": 1, "–≤—ñ–≤—Ç–æ—Ä–æ–∫": 2, "—Å–µ—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä": 4, "–ø º—è—Ç–Ω–∏—Ü—è": 5, "–ø'—è—Ç–Ω–∏—Ü—è": 5, "—Å—É–±–æ—Ç–∞": 6, "–Ω–µ–¥—ñ–ª—è": 0,
    # EN
    "monday": 1, "tuesday": 2, "wednesday": 3, "thursday": 4, "friday": 5, "saturday": 6, "sunday": 0,
}
_WEEKDAY_SET = set(_DOW_MAP.keys())

# –í—Ä–µ–º—è: "9", "9:05", "21:30", "6pm", "6:30pm", "–ø–æ–ª–Ω–æ—á—å", "–ø–æ–ª–¥–µ–Ω—å"
_RE_TIME = re.compile(r"\b(?P<h>\d{1,2})(?::(?P<m>\d{2}))?\s*(?P<ampm>am|pm)?\b", re.I)
_SPECIAL_TIME = {
    "–ø–æ–ª–¥–µ–Ω—å": (12, 0),
    "–ø–æ–ª—É–¥–µ–Ω—å": (12, 0),
    "noon": (12, 0),
    "–ø–æ–ª–Ω–æ—á—å": (0, 0),
    "–æ–ø—ñ–≤–Ω–æ—á—ñ": (0, 0),
    "midnight": (0, 0),
}

# –î–∞—Ç—ã
_RE_DATE_DOT = re.compile(r"\b(?P<d>\d{1,2})\.(?P<m>\d{1,2})(?:\.(?P<y>\d{4}))?\b")
_RE_DATE_ISO = re.compile(r"\b(?P<y>\d{4})-(?P<m>\d{1,2})-(?P<d>\d{1,2})\b")

# –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
_RE_REL = re.compile(
    rf"\b{_RE_IN}\s+"
    r"(?:(?P<hours>\d+)\s*(?:—á–∞—Å(?:–∞|–æ–≤)?|–≥–æ–¥(?:–∏–Ω–∏)?|h|hours?)\s*)?"
    r"(?:(?P<minutes>\d+)\s*(?:–º–∏–Ω—É—Ç(?:—ã)?|—Ö–≤(?:–∏–ª–∏–Ω)?|m|mins?|minutes?)\s*)?"
    r"(?:(?P<days>\d+)\s*(?:–¥–Ω(?:—è|–µ–π|—ñ–≤)?|days?)\s*)?"
    r"(?:(?P<weeks>\d+)\s*(?:–Ω–µ–¥–µ–ª(?:—è|–∏|—å)|—Ç–∏–∂–Ω(?:—ñ|—ñ–≤)|weeks?)\s*)?"
    r"\b",
    re.I,
)

# –ï–∂–µ–º–µ—Å—è—á–Ω—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏: "–∫–∞–∂–¥–æ–≥–æ 5-–≥–æ (—á–∏—Å–ª–∞) –≤ 10", "every month on the 5th at 10"
_RE_MONTHLY = re.compile(
    r"""(?ix)
    \b(?:
        –∫–∞–∂–¥—ã–π\s+–º–µ—Å—è—Ü|–∫–∞–∂–¥–æ–≥–æ\s+–º–µ—Å—è—Ü–∞|—â–æ–º—ñ—Å—è—Ü—è|every\s+month
    )\b
    (?:\s+(?:–Ω–∞|on))?
    (?:\s*(?:\b(?P<dom1>\d{1,2})(?:-?(?:–≥–æ|–µ|th|st|nd|rd))?\b|\b(?P<dom2>\d{1,2})\s+—á–∏—Å–ª–∞\b))?
    """,
)

# Weekends: "–ø–æ –≤—ã—Ö–æ–¥–Ω—ã–º", "–Ω–∞ –≤—ã—Ö–æ–¥–Ω—ã—Ö", "—É –≤–∏—Ö—ñ–¥–Ω—ñ", "–Ω–∞ –≤–∏—Ö—ñ–¥–Ω–∏—Ö", "weekends"
_RE_WEEKENDS = re.compile(r"\b(?:–ø–æ\s+–≤—ã—Ö–æ–¥–Ω(?:—ã–º|—ã—Ö)|–Ω–∞\s+–≤—ã—Ö–æ–¥–Ω—ã—Ö|—É\s+–≤–∏—Ö—ñ–¥–Ω—ñ|–Ω–∞\s+–≤–∏—Ö—ñ–¥–Ω–∏—Ö|weekends?)\b", re.I)

def _normalize(text: str) -> str:
    t = text.strip().lower()
    t = re.sub(r"\s+", " ", t)
    t = t.replace("‚Äô", "'")
    return t

def _extract_what(text_norm: str, recurring: bool) -> Optional[str]:
    """
    –ë–µ—Ä—ë–º –≤—Å—ë –ø–æ—Å–ª–µ —Ç—Ä–∏–≥–≥–µ—Ä–∞ –¥–æ –º–∞—Ä–∫–µ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏/–ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç–∏.
    """
    markers = [
        r"\b" + _RE_IN + r"\b",
        r"\b" + _RE_AT + r"\b",
        r"\b" + _RE_TODAY + r"\b",
        r"\b" + _RE_TOMORROW + r"\b",
        r"\b" + _RE_EVERY + r"\b",
        r"\b" + "|".join(map(re.escape, _WEEKDAY_SET)) + r"\b",
        r"\b–ø–æ –±—É–¥–Ω—è–º\b",
        r"\bweekdays\b",
        r"\bdaily\b",
        r"\b—â–æ–¥–Ω—è\b",
        r"\bweekends?\b",
        r"\b–ø–æ –≤—ã—Ö–æ–¥–Ω(?:—ã–º|—ã—Ö)\b",
        r"\b—â–æ–º—ñ—Å—è—Ü—è\b",
        r"\b–∫–∞–∂–¥—ã–π –º–µ—Å—è—Ü\b",
        r"\bevery month\b",
    ]
    m = re.search(rf"{_TRIGGERS}\s+(?:me\s+to\s+)?", text_norm)
    if not m:
        return None
    start = m.end()

    end = len(text_norm)
    for mk in markers:
        mm = re.search(mk, text_norm[start:])
        if mm:
            end = min(end, start + mm.start())

    what = text_norm[start:end].strip(" ,.;:‚Äî-\"'¬´¬ª")
    return what or None

def _parse_time_fragment(s: str) -> Optional[time]:
    # —Å–ø–µ—Ü-—Å–ª–æ–≤–∞
    for key, (hh, mm) in _SPECIAL_TIME.items():
        if re.search(rf"\b{re.escape(key)}\b", s, flags=re.I):
            return time(hour=hh, minute=mm)

    m = _RE_TIME.search(s)
    if not m:
        return None
    h = int(m.group("h"))
    mnt = int(m.group("m") or 0)
    ampm = (m.group("ampm") or "").lower()
    if ampm == "pm" and 1 <= h <= 11:
        h += 12
    if ampm == "am" and h == 12:
        h = 0
    if not (0 <= h <= 23 and 0 <= mnt <= 59):
        return None
    return time(hour=h, minute=mnt)

def _apply_time(base: datetime, t: time) -> datetime:
    return base.replace(hour=t.hour, minute=t.minute, second=0, microsecond=0)

def _parse_once_datetime(text_norm: str, now: datetime, tz: ZoneInfo) -> Optional[datetime]:
    # "—á–µ—Ä–µ–∑ X ..."
    m = _RE_REL.search(text_norm)
    if m and any(m.group(g) for g in ("minutes", "hours", "days", "weeks")):
        dt = now
        if m.group("minutes"): dt += timedelta(minutes=int(m.group("minutes")))
        if m.group("hours"):   dt += timedelta(hours=int(m.group("hours")))
        if m.group("days"):    dt += timedelta(days=int(m.group("days")))
        if m.group("weeks"):   dt += timedelta(weeks=int(m.group("weeks")))
        return dt

    # –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –¥–∞—Ç–∞
    date_dt = None
    mi = _RE_DATE_ISO.search(text_norm)
    md = _RE_DATE_DOT.search(text_norm)
    if mi:
        y, mo, d = int(mi.group("y")), int(mi.group("m")), int(mi.group("d"))
        date_dt = datetime(y, mo, d, tzinfo=tz)
    elif md:
        d, mo = int(md.group("d")), int(md.group("m"))
        y = int(md.group("y")) if md.group("y") else now.year
        date_dt = datetime(y, mo, d, tzinfo=tz)

    tm = _parse_time_fragment(text_norm)
    if date_dt:
        dt = _apply_time(date_dt, tm or time(9, 0))
        return dt

    # today / tomorrow
    if re.search(rf"\b{_RE_TODAY}\b", text_norm):
        dt = _apply_time(now, tm or time(9, 0))
        if tm is None and dt < now:
            dt = dt + timedelta(hours=1)
        return dt

    if re.search(rf"\b{_RE_TOMORROW}\b", text_norm):
        base = (now + timedelta(days=1)).replace(hour=9, minute=0, second=0, microsecond=0)
        if tm:
            base = _apply_time(base, tm)
        return base

    # –ø—Ä–æ—Å—Ç–æ "–≤ 14:30" ‚Äî –±–ª–∏–∂–∞–π—à–µ–µ —Ç–∞–∫–æ–µ –≤—Ä–µ–º—è
    if tm:
        dt = _apply_time(now, tm)
        if dt <= now:
            dt += timedelta(days=1)
        return dt

    return None

def _parse_recurring_cron(text_norm: str) -> Optional[str]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç cron:
      - daily / –∫–∞–∂–¥—ã–π –¥–µ–Ω—å / —â–æ–¥–Ω—è / –µ–∂–µ–¥–Ω–µ–≤–Ω–æ  -> "m h * * *"
      - weekdays / –ø–æ –±—É–¥–Ω—è–º                      -> "m h * * 1-5"
      - weekends / –ø–æ –≤—ã—Ö–æ–¥–Ω—ã–º                    -> "m h * * 6,0"
      - specific weekday(s)                       -> "m h * * dow[,dow...]"
      - monthly day-of-month                      -> "m h d * *"
    –¢—Ä–µ–±—É–µ—Ç —É–∫–∞–∑–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏.
    """
    tm = _parse_time_fragment(text_norm)
    if not tm:
        return None
    minute = tm.minute
    hour = tm.hour

    # daily
    if re.search(r"\b(daily|—â–æ–¥–Ω—è|–∫–∞–∂–¥—ã–π –¥–µ–Ω—å|–µ–∂–µ–¥–Ω–µ–≤–Ω–æ)\b", text_norm):
        return f"{minute} {hour} * * *"

    # weekdays
    if re.search(r"\b(weekdays|–ø–æ –±—É–¥–Ω—è–º)\b", text_norm):
        return f"{minute} {hour} * * 1-5"

    # weekends
    if _RE_WEEKENDS.search(text_norm):
        return f"{minute} {hour} * * 6,0"

    # monthly (every month on Nth ...)
    mm = _RE_MONTHLY.search(text_norm)
    if mm:
        dom_raw = mm.group("dom1") or mm.group("dom2")
        if dom_raw:
            d = int(dom_raw)
            if 1 <= d <= 31:
                return f"{minute} {hour} {d} * *"
        # –µ—Å–ª–∏ –¥–µ–Ω—å –Ω–µ —É–∫–∞–∑–∞–Ω, –Ω–µ —Å—Ç—Ä–æ–∏–º –∫—Ä–æ–Ω (—á—Ç–æ–±—ã –Ω–µ –≥–∞–¥–∞—Ç—å)

    # every/–∫–∞–∂–¥—É—é/—â–æ—Å–µ—Ä–µ–¥–∏ + weekday(s)
    if re.search(r"\b(–∫–∞–∂–¥\w+|—â–æ—Å\w+|every|on)\b", text_norm):
        dows = _find_all_weekdays(text_norm)
        if dows:
            unique = sorted(set(dows))
            dow_str = ",".join(str(x) for x in unique)
            return f"{minute} {hour} * * {dow_str}"

    # –ø—Ä–æ—Å—Ç–æ ¬´—Å—Ä–µ–¥—É –≤ 18:00¬ª (–±–µ–∑ "–∫–∞–∂–¥—É—é"), –ª–∏–±–æ "monday at 9"
    dows = _find_all_weekdays(text_norm)
    if dows and re.search(rf"\b{_RE_AT}\b", text_norm):
        unique = sorted(set(dows))
        dow_str = ",".join(str(x) for x in unique)
        return f"{minute} {hour} * * {dow_str}"

    return None

def _find_weekday(text_norm: str) -> Optional[int]:
    pos = -1
    val = None
    for name, dow in _DOW_MAP.items():
        m = re.search(rf"\b{name}\b", text_norm)
        if m and m.start() > pos:
            pos = m.start()
            val = dow
    return val

def _find_all_weekdays(text_norm: str) -> List[int]:
    """–ù–∞—Ö–æ–¥–∏—Ç –≤—Å–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –¥–Ω–µ–π –Ω–µ–¥–µ–ª–∏ –≤ —Å—Ç—Ä–æ–∫–µ (–¥–ª—è '–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –∏ —Å—Ä–µ–¥—É')."""
    found: List[int] = []
    for name, dow in _DOW_MAP.items():
        if re.search(rf"\b{name}\b", text_norm):
            found.append(dow)
    return found


__all__ = [
    "ParsedReminder",
    "ToggleRequest",
    "ParseResult",
    "parse_any",
    "parse_remind",
    "parse_toggle",
]
==========================================================================================
# .backup_20251114153210/app/services/reminders.py
==========================================================================================
# app/services/reminders.py
from __future__ import annotations

import asyncio
import logging
from datetime import datetime, timezone
from typing import Optional, Sequence, Tuple

from aiogram import Bot
from croniter import croniter
from sqlalchemy import select, and_, update
from sqlalchemy.ext.asyncio import AsyncSession
from zoneinfo import ZoneInfo

from app.models.reminder import Reminder
from app.models.user import User

log = logging.getLogger("reminders")

# –°–∫–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏–π –º–∞–∫—Å–∏–º—É–º –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞ –æ–¥–∏–Ω —Ç–∏–∫
SEND_LIMIT_PER_TICK = 100
# –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏, —á—Ç–æ–±—ã –±–µ—Ä–µ–∂–Ω–æ –æ—Ç–Ω–æ—Å–∏—Ç—å—Å—è –∫ –ª–∏–º–∏—Ç–∞–º Telegram
SEND_SLEEP_SECONDS = 0.03


async def compute_next_run(
    cron: Optional[str],
    from_dt_utc: datetime,
    user_tz: Optional[str] = "UTC",
) -> Optional[datetime]:
    """
    –í–µ—Ä–Ω—ë—Ç –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è (UTC) –ø–æ cron-–≤—ã—Ä–∞–∂–µ–Ω–∏—é, –∑–∞–¥–∞–Ω–Ω–æ–º—É –≤ –õ–û–ö–ê–õ–¨–ù–û–ú –≤—Ä–µ–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    """
    if not cron:
        return None
    try:
        tz = ZoneInfo(user_tz or "UTC")
        base_local = from_dt_utc.astimezone(tz)
        it = croniter(cron, base_local)
        next_local = datetime.fromtimestamp(it.get_next(), tz=tz)
        return next_local.astimezone(timezone.utc)
    except Exception as e:
        log.warning("compute_next_run failed for cron=%r tz=%r: %s", cron, user_tz, e)
        return None


async def _seed_missing_next_runs(session: AsyncSession, now_utc: datetime) -> int:
    """
    –ü—Ä–æ—Å—Ç–∞–≤–ª—è–µ—Ç next_run –≤—Å–µ–º –∞–∫—Ç–∏–≤–Ω—ã–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è–º, –≥–¥–µ –æ–Ω –µ—â—ë –ø—É—Å—Ç.
    """
    q = (
        select(Reminder.id, Reminder.cron, User.tz)
        .join(User, User.id == Reminder.user_id)
        .where(
            and_(
                Reminder.is_active.is_(True),
                Reminder.cron.is_not(None),
                Reminder.next_run.is_(None),
            )
        )
        .limit(500)
    )
    res = await session.execute(q)
    rows: Sequence[Tuple[int, str, Optional[str]]] = res.all()

    updated = 0
    for rid, cron_expr, tz in rows:
        nxt = await compute_next_run(cron_expr, now_utc, tz)
        if nxt:
            await session.execute(
                update(Reminder).where(Reminder.id == rid).values(next_run=nxt)
            )
            updated += 1

    if updated:
        await session.commit()
    return updated


async def tick_reminders(session: AsyncSession, bot: Bot, now: Optional[datetime] = None):
    """
    –û—Å–Ω–æ–≤–Ω–æ–π —Ç–∏–∫–µ—Ä:
      1) –î–æ—Å–µ—è—Ç—å next_run —Ç–∞–º, –≥–¥–µ –µ–≥–æ –Ω–µ—Ç —É –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö.
      2) –ó–∞–±—Ä–∞—Ç—å due-–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π (skip locked), —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –≤–æ—Ä–∫–µ—Ä–∞—Ö.
      3) –û—Ç–ø—Ä–∞–≤–∏—Ç—å, –ø–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å (cron) –∏–ª–∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å (one-shot).
    """
    now_utc = now or datetime.now(timezone.utc)

    # 1) —Å–∏–¥–¥–∏–Ω–≥
    try:
        await _seed_missing_next_runs(session, now_utc)
    except Exception as e:
        log.exception("seed_missing_next_runs failed: %s", e)

    # 2) –∑–∞–±–∏—Ä–∞–µ–º due –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π
    q = (
        select(Reminder, User.tg_id, User.tz)
        .join(User, User.id == Reminder.user_id)
        .where(
            and_(
                Reminder.is_active.is_(True),
                Reminder.next_run.is_not(None),
                Reminder.next_run <= now_utc,
            )
        )
        .order_by(Reminder.next_run.asc())
        .limit(SEND_LIMIT_PER_TICK)
        .with_for_update(skip_locked=True)
    )

    # –Ω–∞—á–∏–Ω–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é, —á—Ç–æ–±—ã –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∏–º–µ–ª–∞ —Å–º—ã—Å–ª
    async with session.begin():
        res = await session.execute(q)
        due: Sequence[Tuple[Reminder, int, Optional[str]]] = res.all()

        if not due:
            return

        for r, chat_id, tz in due:
            try:
                await bot.send_message(chat_id, f"üîî {r.title}")
            except Exception as send_err:
                # –ù–µ —Ñ–µ–π–ª–∏–º –≤–µ—Å—å —Ç–∏–∫ ‚Äî –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º
                log.warning("Failed to send reminder id=%s to %s: %s", r.id, chat_id, send_err)

            # –ü–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ/–¥–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è
            if r.cron:
                nxt = await compute_next_run(r.cron, now_utc, tz)
                if nxt:
                    r.next_run = nxt
                else:
                    r.is_active = False
                    r.next_run = None
            else:
                # –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ ‚Äî –≤—ã–∫–ª—é—á–∞–µ–º –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
                r.is_active = False
                r.next_run = None

            session.add(r)
            await asyncio.sleep(SEND_SLEEP_SECONDS)
        # –ö–æ–º–º–∏—Ç –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –ø–æ –≤—ã—Ö–æ–¥—É –∏–∑ context manager
==========================================================================================
# .env
==========================================================================================
TG_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
TELEGRAM_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
PUBLIC_URL=https://ilda-comelier-pliantly.ngrok-free.dev

==========================================================================================
# alembic.ini
==========================================================================================
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the tzdata library which can be installed by adding
# `alembic[tz]` to the pip requirements.
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os


# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.
sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the module runner, against the "ruff" module
# hooks = ruff
# ruff.type = module
# ruff.module = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Alternatively, use the exec runner to execute a binary found on your PATH
# hooks = ruff
# ruff.type = exec
# ruff.executable = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

==========================================================================================
# app.py
==========================================================================================
import os, json, sqlite3, base64, requests
from datetime import datetime, date
from fastapi import FastAPI, Request, Header, HTTPException, Query
from fastapi.responses import RedirectResponse, HTMLResponse, PlainTextResponse, JSONResponse
from dotenv import load_dotenv
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.exceptions import InvalidSignature

load_dotenv(".env")
MONO_TOKEN = os.getenv("MONO_TOKEN")
PUBLIC_BASE_URL = os.getenv("PUBLIC_BASE_URL","https://your.domain")
SUB_PRICE_UAH = int(float(os.getenv("SUB_PRICE_UAH","99"))*100)
ADMIN_TOKEN = os.getenv("ADMIN_TOKEN","change-me-admin")
MONO_BASE = "https://api.monobank.ua"

con = sqlite3.connect("data/payments.sqlite3", check_same_thread=False)
con.execute("create table if not exists invoices(invoice_id text primary key, tg_id text, amount int, ccy int, reference text, status text, created_at text, paid_at text, refunded int default 0, refund_amount int default 0)")
con.execute("create table if not exists events(id integer primary key autoincrement, invoice_id text, kind text, payload text, created_at text)")
con.commit()

app = FastAPI()
_pubkey = None

def pubkey():
    global _pubkey
    if _pubkey is None:
        r = requests.get(f"{MONO_BASE}/api/merchant/pubkey", timeout=15)
        r.raise_for_status()
        _pubkey = serialization.load_pem_public_key(r.json()["key"].encode())
    return _pubkey

@app.get("/health")
def health(): return {"ok":True}

@app.get("/pay")
def pay(tg_id: str = Query(...)):
    return RedirectResponse(f"/pay/mono?tg_id={tg_id}", status_code=303)

@app.get("/pay/mono")
def pay_mono(tg_id: str = Query(...)):
    if not MONO_TOKEN: raise HTTPException(500, "MONO_TOKEN missing")
    amount = SUB_PRICE_UAH
    reference = f"sub_{tg_id}_{date.today():%Y-%m}"
    payload = {
        "amount": amount,
        "ccy": 980,
        "merchantPaymInfo": {"reference": reference, "destination": "FlowDiary Premium"},
        "redirectUrl": f"{PUBLIC_BASE_URL}/payments/mono/return",
        "successUrl":  f"{PUBLIC_BASE_URL}/payments/success",
        "failUrl":     f"{PUBLIC_BASE_URL}/payments/fail",
        "webHookUrl":  f"{PUBLIC_BASE_URL}/api/mono/webhook",
        "validity": 3600,
        "paymentType": "debit"
    }
    r = requests.post(f"{MONO_BASE}/api/merchant/invoice/create",
                      headers={"X-Token": MONO_TOKEN, "Content-Type":"application/json"},
                      json=payload, timeout=20)
    data = r.json()
    if r.status_code != 200 or "pageUrl" not in data:
        raise HTTPException(502, detail=data)
    con.execute("insert or replace into invoices(invoice_id,tg_id,amount,ccy,reference,status,created_at) values(?,?,?,?,?,?,?)",
                (data["invoiceId"], tg_id, amount, 980, reference, "created", datetime.utcnow().isoformat()))
    con.commit()
    return RedirectResponse(data["pageUrl"], status_code=303)

@app.post("/api/mono/webhook")
async def mono_webhook(request: Request, x_sign: str | None = Header(None)):
    raw = await request.body()
    if not x_sign: raise HTTPException(400, "X-Sign missing")
    try:
        pubkey().verify(base64.b64decode(x_sign), raw, ec.ECDSA(hashes.SHA256()))
    except (InvalidSignature, ValueError):
        raise HTTPException(403, "Bad signature")
    event = json.loads(raw.decode())
    invoice_id = event.get("invoiceId")
    status = event.get("status")
    con.execute("insert into events(invoice_id,kind,payload,created_at) values(?,?,?,?)",
                (invoice_id, "webhook", json.dumps(event, ensure_ascii=False), datetime.utcnow().isoformat()))
    if invoice_id and status:
        con.execute("update invoices set status=? where invoice_id=?", (status, invoice_id))
        if status == "success":
            con.execute("update invoices set paid_at=? where invoice_id=?", (datetime.utcnow().isoformat(), invoice_id))
        if status in ("reversed","refunded"):
            con.execute("update invoices set refunded=1 where invoice_id=?", (invoice_id,))
    con.commit()
    return PlainTextResponse("ok")

@app.get("/payments/mono/return")
def mono_return(): return HTMLResponse("<h3>–°–ø–∞—Å–∏–±–æ! –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–ª–∞—Ç—ë–∂‚Ä¶</h3>")

@app.get("/payments/success")
def success(): return HTMLResponse("<h3>–û–ø–ª–∞—Ç–∞ –ø—Ä–∏–Ω—è—Ç–∞. –ú–æ–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –≤–∫–ª–∞–¥–∫—É.</h3>")

@app.get("/payments/fail")
def fail(): return HTMLResponse("<h3>–û–ø–ª–∞—Ç–∞ –Ω–µ –ø—Ä–æ—à–ª–∞ –∏–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞.</h3>")

@app.post("/admin/mono/refund")
async def admin_refund(request: Request, x_admin_token: str | None = Header(None)):
    if x_admin_token != ADMIN_TOKEN: raise HTTPException(403, "forbidden")
    body = await request.json()
    invoice_id = body.get("invoiceId")
    amount = body.get("amount")
    if not invoice_id: raise HTTPException(400, "invoiceId required")
    payload = {"invoiceId": invoice_id}
    if amount is not None: payload["amount"] = int(amount)
    r = requests.post(f"{MONO_BASE}/api/merchant/return",
                      headers={"X-Token": MONO_TOKEN, "Content-Type":"application/json"},
                      json=payload, timeout=20)
    if r.status_code != 200:
        raise HTTPException(502, detail=r.json() if r.content else {})
    con.execute("update invoices set refunded=1, refund_amount=? where invoice_id=?",
                (payload.get("amount",0), invoice_id))
    con.commit()
    return JSONResponse({"ok":True, "data":r.json()})

@app.get("/admin/mono/status")
def admin_status(invoiceId: str, x_admin_token: str | None = Header(None)):
    if x_admin_token != ADMIN_TOKEN: raise HTTPException(403, "forbidden")
    r = requests.get(f"{MONO_BASE}/api/merchant/invoice/status",
                     params={"invoiceId": invoiceId},
                     headers={"X-Token": MONO_TOKEN}, timeout=15)
    return JSONResponse(r.json())

==========================================================================================
# app/__init__.py
==========================================================================================

==========================================================================================
# app/api.py
==========================================================================================
from fastapi import FastAPI
from app.webhooks.coinbase import router as coinbase_router

app = FastAPI()
app.include_router(coinbase_router)

@app.get('/healthz')
async def healthz():
    return {'ok': True}

==========================================================================================
# app/api/__init__.py
==========================================================================================

==========================================================================================
# app/api/coinbase.py
==========================================================================================
from fastapi import APIRouter, Request, HTTPException
from sqlalchemy import select
from datetime import datetime, timezone, timedelta
import hmac, hashlib, json

from app.config import settings
from app.db import async_session
from app.models.user import User
from app.models.payment import Payment

router = APIRouter(prefix="/payments/coinbase", tags=["payments"])

@router.post("/webhook")
async def coinbase_webhook(request: Request):
    raw = await request.body()
    sig = request.headers.get("X-CC-Webhook-Signature", "")
    calc = hmac.new(settings.coinbase_webhook_secret.encode(), raw, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(calc, sig):
        raise HTTPException(status_code=400, detail="bad signature")
    try:
        payload = json.loads(raw.decode("utf-8"))
    except Exception:
        raise HTTPException(status_code=400, detail="bad json")
    evt = payload.get("event") or {}
    if evt.get("type") != "charge:confirmed":
        return {"ok": True}
    data = evt.get("data") or {}
    metadata = data.get("metadata") or {}
    pricing_local = (data.get("pricing") or {}).get("local") or {}
    try:
        user_id = int(metadata["user_id"])
        ext_id = str(data["id"])
        amount_cents = int(round(float(pricing_local["amount"]) * 100))
        currency = str(pricing_local["currency"])
    except Exception:
        raise HTTPException(status_code=400, detail="bad payload")
    async with async_session() as session, session.begin():
        exists = await session.execute(select(Payment.id).where(Payment.external_id == ext_id))
        if exists.scalar_one_or_none():
            return {"ok": True}
        pay = Payment(
            user_id=user_id,
            provider="coinbase",
            plan="monthly",
            amount_cents=amount_cents,
            currency=currency,
            status="succeeded",
            external_id=ext_id,
            payload=json.dumps(payload, ensure_ascii=False),
            paid_at=datetime.now(timezone.utc),
        )
        session.add(pay)
        await _extend_premium(session, user_id, months=1)
    return {"ok": True}

async def _extend_premium(session, user_id: int, months: int = 1):
    res = await session.execute(select(User).where(User.id == user_id))
    user = res.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=404, detail="user not found")
    now = datetime.now(timezone.utc)
    base = user.premium_until if getattr(user, "premium_until", None) and user.premium_until > now else now
    user.premium_until = base + timedelta(days=30 * months)
    session.add(user)

==========================================================================================
# app/bot.py
==========================================================================================
# app/bot.py
from aiogram import Bot
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.client.session.aiohttp import AiohttpSession
from app.config import settings

def _default_props() -> DefaultBotProperties:
    try:
        return DefaultBotProperties(parse_mode=ParseMode.HTML, link_preview_is_disabled=True)
    except TypeError:
        return DefaultBotProperties(parse_mode=ParseMode.HTML)

# –í–ê–ñ–ù–û: timeout ‚Äî —ç—Ç–æ —á–∏—Å–ª–æ —Å–µ–∫—É–Ω–¥, –∞ –Ω–µ ClientTimeout
_session = AiohttpSession(timeout=25)

bot = Bot(
    token=settings.tg_token,
    session=_session,
    default=_default_props(),
)

__all__ = ["bot"]
==========================================================================================
# app/commands.py
==========================================================================================
from aiogram.types import BotCommand, BotCommandScopeDefault

EN = [
    BotCommand(command="start",     description="Start"),
    BotCommand(command="journal",   description="New journal entry"),
    BotCommand(command="stats",     description="Stats"),
    BotCommand(command="remind",    description="Create reminder"),
    BotCommand(command="premium",   description="Premium"),
    BotCommand(command="meditation",description="Meditation timer"),
    BotCommand(command="music",     description="My music / playlist"),
]

RU = [
    BotCommand(command="start",     description="–ù–∞—á–∞—Ç—å"),
    BotCommand(command="journal",   description="–ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å"),
    BotCommand(command="stats",     description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",    description="–°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"),
    BotCommand(command="premium",   description="–ü—Ä–µ–º–∏—É–º"),
    BotCommand(command="meditation",description="–ú–µ–¥–∏—Ç–∞—Ü–∏—è (—Ç–∞–π–º–µ—Ä)"),
    BotCommand(command="music",     description="–ú–æ—è –º—É–∑—ã–∫–∞ / –ø–ª–µ–π–ª–∏—Å—Ç"),
]

UK = [
    BotCommand(command="start",     description="–ü–æ—á–∞—Ç–∏"),
    BotCommand(command="journal",   description="–°—Ç–≤–æ—Ä–∏—Ç–∏ –∑–∞–ø–∏—Å"),
    BotCommand(command="stats",     description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",    description="–°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è"),
    BotCommand(command="premium",   description="–ü—Ä–µ–º—ñ—É–º"),
    BotCommand(command="meditation",description="–ú–µ–¥–∏—Ç–∞—Ü—ñ—è (—Ç–∞–π–º–µ—Ä)"),
    BotCommand(command="music",     description="–ú–æ—è –º—É–∑–∏–∫–∞ / –ø–ª–µ–π–ª–∏—Å—Ç"),
]

async def setup_bot_commands(bot):
    await bot.delete_my_commands(scope=BotCommandScopeDefault())
    try:
        await bot.delete_my_commands(language_code="ru")
    except:
        pass
    try:
        await bot.delete_my_commands(language_code="uk")
    except:
        pass
    await bot.set_my_commands(EN)
    await bot.set_my_commands(RU, language_code="ru")
    await bot.set_my_commands(UK, language_code="uk")

==========================================================================================
# app/config.py
==========================================================================================
# app/config.py
import os, json, time, subprocess, urllib.request
from typing import Optional

def _as_bool(v: Optional[str], default=False) -> bool:
    if v is None: return default
    return str(v).strip().lower() in {"1","true","yes","y","on"}

def _as_int(v: Optional[str], default: int) -> int:
    try: return int(str(v).strip())
    except Exception: return default

def _discover_ngrok_https() -> str:
    try:
        with urllib.request.urlopen("http://127.0.0.1:4040/api/tunnels", timeout=2) as r:
            data = json.load(r)
        for t in data.get("tunnels", []):
            u = t.get("public_url", "")
            if u.startswith("https://"):
                return u.rstrip("/")
    except Exception:
        pass
    return ""

class Settings:
    def __init__(self) -> None:
        self.tg_token = (
            os.getenv("TG_TOKEN") or os.getenv("TELEGRAM_TOKEN") or os.getenv("BOT_TOKEN")
            or os.getenv("TELEGRAM_BOT_TOKEN") or os.getenv("TOKEN") or ""
        )
        self._public_url = (os.getenv("PUBLIC_URL") or "").strip().rstrip("/")

        self.default_locale = (os.getenv("DEFAULT_LOCALE") or os.getenv("APP_DEFAULT_LOCALE") or "ru").strip().lower()
        if self.default_locale == "ua": self.default_locale = "uk"
        if self.default_locale not in {"ru","uk","en"}: self.default_locale = "ru"

        self.default_tz = (os.getenv("DEFAULT_TZ") or os.getenv("APP_DEFAULT_TZ") or "Europe/Kyiv").strip() or "Europe/Kyiv"
        self.premium_channel = (os.getenv("PREMIUM_CHANNEL") or "@NoticesDiarY").strip()

        self.music_focus_url = (os.getenv("MUSIC_FOCUS_URL") or "https://www.youtube.com/watch?v=jfKfPfyJRdk").strip()
        self.music_sleep_url = (os.getenv("MUSIC_SLEEP_URL") or "https://www.youtube.com/watch?v=5qap5aO4i9A").strip()

        self.reminder_tick_sec = _as_int(os.getenv("REMINDER_TICK_SEC"), 5)
        self.debug = _as_bool(os.getenv("DEBUG"), False)

    def ensure_public_url(self) -> str:
        if self._public_url: return self._public_url
        u = _discover_ngrok_https()
        if not u:
            try:
                subprocess.Popen(["ngrok","http","8000"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                time.sleep(2.5)
                u = _discover_ngrok_https()
            except Exception:
                u = ""
        if u:
            self._public_url = u
            os.environ["PUBLIC_URL"] = u
        return self._public_url

    @property
    def public_url(self) -> str:
        return self.ensure_public_url()

settings = Settings()
==========================================================================================
# app/db/__init__.py
==========================================================================================
from .core import engine, Base, init_db, async_session, Session

==========================================================================================
# app/db/core.py
==========================================================================================
import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base

def _normalize_url(u: str) -> str:
    if u.startswith("sqlite:///") and "+aiosqlite" not in u:
        return u.replace("sqlite://", "sqlite+aiosqlite://", 1)
    return u

DB_URL = _normalize_url(os.getenv("DB_URL", "sqlite:///dev.db"))

engine = create_async_engine(DB_URL, future=True, echo=False)
Base = declarative_base()
async_session = async_sessionmaker(bind=engine, expire_on_commit=False, class_=AsyncSession)
Session = async_session

async def init_db():
    async with engine.begin() as conn:
        # —Å–æ–∑–¥–∞–¥–∏–º ORM-—Ç–∞–±–ª–∏—Ü—ã, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
        await conn.run_sync(Base.metadata.create_all)
        # –∏ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Å–æ–∑–¥–∞–¥–∏–º –∫—Ä–∏—Ç–∏—á–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –¥–ª—è –±–æ—Ç–∞
        await conn.exec_driver_sql("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER UNIQUE,
            tz TEXT DEFAULT 'Europe/Kyiv'
        )""")
        await conn.exec_driver_sql("""
        CREATE TABLE IF NOT EXISTS reminder (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            title TEXT,
            cron TEXT,
            next_run TEXT,
            is_active INTEGER DEFAULT 1,
            FOREIGN KEY(user_id) REFERENCES users(id)
        )""")

==========================================================================================
# app/db/session.py
==========================================================================================
import os
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import DeclarativeBase

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./db.sqlite3")

class Base(DeclarativeBase):
    pass

engine = create_async_engine(DATABASE_URL, echo=False, future=True)
async_session = async_sessionmaker(bind=engine, expire_on_commit=False, class_=AsyncSession)

==========================================================================================
# app/db_conflict.py
==========================================================================================
from __future__ import annotations

from typing import AsyncIterator

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import DeclarativeBase
from app.config import settings


class Base(DeclarativeBase):
    pass


def _normalize_url(url: str) -> str:
    """–ü—Ä–∏–≤–æ–¥–∏–º URL –∫ async-–¥—Ä–∞–π–≤–µ—Ä–∞–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é."""
    if not url:
        return "sqlite+aiosqlite:///./dev.db"
    if url.startswith("postgres://"):
        url = url.replace("postgres://", "postgresql://", 1)
    if url.startswith("postgresql://"):
        url = url.replace("postgresql://", "postgresql+asyncpg://", 1)
    if url.startswith("sqlite:///") and "+aiosqlite" not in url:
        url = url.replace("sqlite:///", "sqlite+aiosqlite:///", 1)
    return url


DATABASE_URL = _normalize_url(settings.database_url)

engine = create_async_engine(
    DATABASE_URL,
    echo=bool(getattr(settings, "sqlalchemy_echo", False)),
    pool_pre_ping=True,
    future=True,
)

async_session_maker = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


def async_session() -> AsyncSession:
    """–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `async with async_session() as s:`"""
    return async_session_maker()


# –î–ª—è FastAPI Depends, –µ—Å–ª–∏ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è
async def get_session() -> AsyncIterator[AsyncSession]:
    async with async_session() as s:
        yield s


async def init_models() -> None:
    """
    –°–æ–∑–¥–∞—ë—Ç —Ç–∞–±–ª–∏—Ü—ã (–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ).
    –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥–µ–ª–∏, —á—Ç–æ–±—ã –æ–Ω–∏ –æ–∫–∞–∑–∞–ª–∏—Å—å –≤ Base.metadata.
    """
    try:
        # –ø–æ–¥—Ö–≤–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ –¥–µ–∫–ª–∞—Ä–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü
        from app.models import user as _user  # noqa: F401
        from app.models import payment as _payment  # noqa: F401
    except Exception:
        # –µ—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª–µ–π –∏–Ω–∞—è ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        pass

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


__all__ = [
    "Base",
    "engine",
    "async_session_maker",
    "async_session",
    "get_session",
    "init_models",
    "DATABASE_URL",
]
==========================================================================================
# app/features/__init__.py
==========================================================================================
from aiogram import Router
from .meditation import router as meditation_router
from .music import router as music_router

router = Router()
router.include_router(meditation_router)
router.include_router(music_router)

==========================================================================================
# app/features/calories.py
==========================================================================================
from __future__ import annotations
import os, re, httpx
from aiogram import Router, types, F
from aiogram.filters import Command
from app.i18n import tr, detect_lang
router = Router()
FALLBACK = {
    "–º–æ–ª–æ–∫–æ": dict(kcal=60, p=3.2, f=3.2, c=4.7),
    "–±–∞–Ω–∞–Ω": dict(kcal=89, p=1.1, f=0.3, c=23),
    "–∞—Ä–∞—Ö–∏—Å": dict(kcal=567, p=26, f=49, c=16),
    "–≥—Ä–µ—á–∫–∞": dict(kcal=343, p=13.3, f=3.4, c=71.5)
}
@router.message(Command("calories"))
async def cal_start(m: types.Message):
    lang = detect_lang(m.from_user.language_code)
    await m.answer(tr("cal_send", lang))
@router.message(F.text.regexp(r".+").as_("txt"))
async def cal_text(m: types.Message, txt: str):
    keys = ["–º–æ–ª–æ–∫–æ","–±–∞–Ω–∞–Ω","–∞—Ä–∞—Ö–∏—Å","–≥—Ä–µ—á","milk","banana","peanut","buckwheat"]
    if not any(w in txt.lower() for w in keys):
        return
    lang = detect_lang(m.from_user.language_code)
    res = await analyze_text(txt)
    await m.answer(tr("cal_total", lang, kcal=res["kcal"], p=res["p"], f=res["f"], c=res["c"]))
async def analyze_text(text: str) -> dict:
    key = os.getenv("NUTRITION_API_KEY")
    if key:
        try:
            async with httpx.AsyncClient(timeout=15) as cl:
                r = await cl.post("https://api.calorieninjas.com/v1/nutrition?query="+text, headers={"X-Api-Key": key})
                r.raise_for_status()
                items = r.json().get("items", [])
                kcal = sum(i.get("calories",0) for i in items)
                p = sum(i.get("protein_g",0) for i in items)
                f = sum(i.get("fat_total_g",0) for i in items)
                c = sum(i.get("carbohydrates_total_g",0) for i in items)
                return dict(kcal=round(kcal), p=round(p,1), f=round(f,1), c=round(c,1))
        except Exception:
            pass
    grams = []
    for name, meta in FALLBACK.items():
        m = re.search(rf"{name}\s*(\d+)\s*(–≥|g|–≥—Ä|ml|–º–ª)?", text.lower())
        if m:
            qty = int(m.group(1))
            unit = (m.group(2) or "g").lower()
            g = qty if unit in ["–≥","g","–≥—Ä"] else qty
            grams.append((g, meta))
    kcal=p=f=c=0.0
    for g, meta in grams:
        factor = g/100.0
        kcal += meta["kcal"]*factor
        p += meta["p"]*factor
        f += meta["f"]*factor
        c += meta["c"]*factor
    return dict(kcal=round(kcal), p=round(p,1), f=round(f,1), c=round(c,1))

==========================================================================================
# app/features/chat_mode.py
==========================================================================================
from __future__ import annotations
import json, pathlib
from aiogram import Router, types, F
from aiogram.filters import Command
from app.i18n import tr, detect_lang
router = Router()
STORE = pathlib.Path("data/user_flags.json")
def _load():
    if STORE.exists():
        return json.loads(STORE.read_text(encoding="utf-8"))
    return {}
def _save(d):
    STORE.write_text(json.dumps(d, ensure_ascii=False, indent=2), encoding="utf-8")
@router.message(Command("chat_on"))
async def chat_on(m: types.Message):
    lang = detect_lang(m.from_user.language_code)
    d = _load(); d[str(m.from_user.id)] = True; _save(d)
    await m.answer(tr("chat_on", lang) + "\n" + tr("chat_hint", lang))
@router.message(Command("chat_off"))
async def chat_off(m: types.Message):
    lang = detect_lang(m.from_user.language_code)
    d = _load(); d[str(m.from_user.id)] = False; _save(d)
    await m.answer(tr("chat_off", lang))
@router.message(F.content_type.in_({"text","photo"}))
async def smart_chat(m: types.Message):
    d = _load()
    if not d.get(str(m.from_user.id)):
        return
    lang = detect_lang(m.from_user.language_code)
    await m.reply(tr("chat_reply_generic", lang))

==========================================================================================
# app/features/meditation.py
==========================================================================================

from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

router = Router()

TXT = {
    "menu":   {"ru": "–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü–∏–∏:", "uk": "–í–∏–±–µ—Ä–∏ —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü—ñ—ó:", "en": "Choose meditation mode:"},
    "focus":  {"ru": "–§–æ–∫—É—Å", "uk": "–§–æ–∫—É—Å", "en": "Focus"},
    "calm":   {"ru": "–°–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ", "uk": "–°–ø–æ–∫—ñ–π", "en": "Calm"},
    "sleep":  {"ru": "–°–æ–Ω", "uk": "–°–æ–Ω", "en": "Sleep"},
    "open":   {"ru": "–û—Ç–∫—Ä—ã—Ç—å ‚ñ∂Ô∏è", "uk": "–í—ñ–¥–∫—Ä–∏—Ç–∏ ‚ñ∂Ô∏è", "en": "Open ‚ñ∂Ô∏è"},
    "back":   {"ru": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "uk": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "en": "‚¨ÖÔ∏è Back"},
    "dur":    {"ru": "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:", "uk": "–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å:", "en": "Duration:"},
    "d5":     {"ru": "5 –º–∏–Ω", "uk": "5 —Ö–≤", "en": "5 min"},
    "d10":    {"ru": "10 –º–∏–Ω", "uk": "10 —Ö–≤", "en": "10 min"},
    "d15":    {"ru": "15 –º–∏–Ω", "uk": "15 —Ö–≤", "en": "15 min"},
    "started":{"ru": "–°—Ç–∞—Ä—Ç. –°–µ—Å—Å–∏—è {dur} –≤ —Ä–µ–∂–∏–º–µ ¬´{mode}¬ª. –¢—Ä–µ–∫ –Ω–∏–∂–µ.", 
               "uk": "–°—Ç–∞—Ä—Ç. –°–µ—Å—ñ—è {dur} —É —Ä–µ–∂–∏–º—ñ ¬´{mode}¬ª. –¢—Ä–µ–∫ –Ω–∏–∂—á–µ.", 
               "en": "Started. {dur} session in ‚Äú{mode}‚Äù mode. Track below."}
}

MODES = ("focus","calm","sleep")
DURATIONS = {"d5": 5, "d10": 10, "d15": 15}

async def _lang(obj, session: AsyncSession) -> str:
    tg = getattr(getattr(obj,'from_user',None),'id',None)
    row = await session.execute(sql_text('SELECT lang FROM users WHERE tg_id=:tg'), {'tg': tg})
    code = row.scalar_one_or_none() or getattr(getattr(obj,'from_user',None),'language_code',None)
    code = (code or 'ru')[:2].lower()
    return code if code in {'ru','uk','en'} else 'ru'

def _urls():
    # –ø—Ä–æ—Å—Ç—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã, –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ settings/env
    focus = "https://www.youtube.com/watch?v=jfKfPfyJRdk"
    calm  = "https://www.youtube.com/watch?v=5qap5aO4i9A"
    sleep = "https://www.youtube.com/watch?v=lTRiuFIWV54"
    return {"focus": focus, "calm": calm, "sleep": sleep}

def _menu_kb(l: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text=TXT["focus"][l], callback_data="med:mode:focus"),
        InlineKeyboardButton(text=TXT["calm"][l],  callback_data="med:mode:calm"),
        InlineKeyboardButton(text=TXT["sleep"][l], callback_data="med:mode:sleep"),
    ]])

def _dur_kb(l: str, mode: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=TXT["dur"][l], callback_data="noop")],
        [
            InlineKeyboardButton(text=TXT["d5"][l],  callback_data=f"med:dur:{mode}:d5"),
            InlineKeyboardButton(text=TXT["d10"][l], callback_data=f"med:dur:{mode}:d10"),
            InlineKeyboardButton(text=TXT["d15"][l], callback_data=f"med:dur:{mode}:d15"),
        ],
        [InlineKeyboardButton(text=TXT["back"][l], callback_data="med:back")]
    ])

def _open_kb(l: str, mode: str) -> InlineKeyboardMarkup:
    url = _urls()[mode]
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text=TXT["open"][l], url=url),
    ]])

@router.message(Command("meditation"))
@router.message(F.text.lower().in_({"üßò meditation","üßò –º–µ–¥–∏—Ç–∞—Ü–∏—è","üßò –º–µ–¥–∏—Ç–∞—Ü—ñ—è","meditation","–º–µ–¥–∏—Ç–∞—Ü–∏—è","–º–µ–¥–∏—Ç–∞—Ü—ñ—è"}))
async def cmd_meditation(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    await m.answer(TXT["menu"][l], reply_markup=_menu_kb(l))

@router.callback_query(F.data.startswith("med:"))
async def on_med_choice(c: CallbackQuery, session: AsyncSession):
    l = await _lang(c, session)
    data = c.data.split(":")
    # –ù–ò–ß–ï–ì–û –Ω–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º ‚Äî —Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    if data[1] == "mode":
        mode = data[2]
        if mode not in MODES:
            await c.answer(); return
        await c.answer()
        await c.message.answer(TXT["dur"][l] + " " + {"focus":TXT["focus"][l],"calm":TXT["calm"][l],"sleep":TXT["sleep"][l]}[mode],
                               reply_markup=_dur_kb(l, mode))
        return
    if data[1] == "dur":
        mode, dkey = data[2], data[3]
        mins = DURATIONS.get(dkey, 5)
        mode_title = {"focus":TXT["focus"][l],"calm":TXT["calm"][l],"sleep":TXT["sleep"][l]}[mode]
        await c.answer()
        await c.message.answer(TXT["started"][l].format(dur=f"{mins} –º–∏–Ω" if l=='ru' else (f"{mins} —Ö–≤" if l=='uk' else f"{mins} min"),
                                                        mode=mode_title))
        await c.message.answer(TXT["open"][l], reply_markup=_open_kb(l, mode))
        return
    if data[1] == "back":
        await c.answer()
        await c.message.answer(TXT["menu"][l], reply_markup=_menu_kb(l))
        return

==========================================================================================
# app/features/music.py
==========================================================================================
from __future__ import annotations

import os
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import (
    Message, CallbackQuery,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.exceptions import TelegramBadRequest
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

router = Router()

SUPPORTED = {"ru", "uk", "en"}

TXT = {
    "menu": {
        "ru": "–í—ã–±–µ—Ä–∏ –ø–ª–µ–π–ª–∏—Å—Ç:",
        "uk": "–û–±–µ—Ä—ñ—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç:",
        "en": "Choose a playlist:",
    },
    "focus_btn": {"ru": "–§–æ–∫—É—Å", "uk": "–§–æ–∫—É—Å", "en": "Focus"},
    "sleep_btn": {"ru": "–°–æ–Ω", "uk": "–°–æ–Ω", "en": "Sleep"},
    "my_btn":    {"ru": "–ú–æ–π –ø–ª–µ–π–ª–∏—Å—Ç", "uk": "–ú—ñ–π –ø–ª–µ–π–ª–∏—Å—Ç", "en": "My playlist"},
    "add_btn":   {"ru": "–î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫", "uk": "–î–æ–¥–∞—Ç–∏ —Ç—Ä–µ–∫", "en": "Add a track"},
    "open_focus": {"ru": "–û—Ç–∫—Ä—ã—Ç—å Focus ‚ñ∂Ô∏è", "uk": "–í—ñ–¥–∫—Ä–∏—Ç–∏ Focus ‚ñ∂Ô∏è", "en": "Open Focus ‚ñ∂Ô∏è"},
    "open_sleep": {"ru": "–û—Ç–∫—Ä—ã—Ç—å Sleep ‚ñ∂Ô∏è", "uk": "–í—ñ–¥–∫—Ä–∏—Ç–∏ Sleep ‚ñ∂Ô∏è", "en": "Open Sleep ‚ñ∂Ô∏è"},
    "back": {"ru": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "uk": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "en": "‚¨ÖÔ∏è Back"},
    "send_audio_hint": {
        "ru": "–ü—Ä–∏—à–ª–∏ –º–Ω–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª(—ã) ‚Äî –¥–æ–±–∞–≤–ª—é –≤ —Ç–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç.",
        "uk": "–ù–∞–¥—ñ—à–ª–∏ –∞—É–¥—ñ–æ—Ñ–∞–π–ª(–∏) ‚Äî –¥–æ–¥–∞–º —É —Ç–≤—ñ–π –ø–ª–µ–π–ª–∏—Å—Ç.",
        "en": "Send me audio file(s) ‚Äî I will add them to your playlist.",
    },
    "saved": {"ru": "–°–æ—Ö—Ä–∞–Ω–∏–ª –≤ —Ç–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç ‚úÖ",
              "uk": "–ó–±–µ—Ä—ñ–≥ —É —Ç–≤—ñ–π –ø–ª–µ–π–ª–∏—Å—Ç ‚úÖ",
              "en": "Saved to your playlist ‚úÖ"},
    "empty": {"ru": "–ü–æ–∫–∞ –ø—É—Å—Ç–æ. ",
              "uk": "–ü–æ–∫–∏ –ø–æ—Ä–æ–∂–Ω—å–æ. ",
              "en": "No tracks yet. "},
    "your_tracks": {"ru": "–¢–≤–æ–∏ —Ç—Ä–µ–∫–∏:",
                    "uk": "–¢–≤–æ—ó —Ç—Ä–µ–∫–∏:",
                    "en": "Your tracks:"},
}

# ---------- i18n ----------
def _norm(l: str | None) -> str:
    l = (l or "ru")[:2].lower()
    return l if l in SUPPORTED else "ru"

async def _lang(m: Message | CallbackQuery, session: AsyncSession) -> str:
    if isinstance(m, Message):
        tg = getattr(getattr(m, "from_user", None), "id", None)
        code = getattr(getattr(m, "from_user", None), "language_code", None)
    else:
        tg = (getattr(getattr(m, "from_user", None), "id", None)
              or getattr(getattr(m.message, "from_user", None), "id", None))
        code = (getattr(getattr(m, "from_user", None), "language_code", None)
                or getattr(getattr(m.message, "from_user", None), "language_code", None))

    db_lang = None
    if tg is not None:
        try:
            res = await session.execute(
                sql_text("SELECT lang FROM users WHERE tg_id=:tg"), {"tg": tg}
            )
            db_lang = res.scalar_one_or_none()
        except Exception:
            db_lang = None
    return _norm(db_lang or code or "ru")

# ---------- URLs ----------
def _urls():
    try:
        from app.config import settings as cfg
    except Exception:
        cfg = None
    focus = (getattr(cfg, "music_focus_url", None)
             or os.getenv("MUSIC_FOCUS_URL")
             or "https://www.youtube.com/watch?v=jfKfPfyJRdk")
    sleep = (getattr(cfg, "music_sleep_url", None)
             or os.getenv("MUSIC_SLEEP_URL")
             or "https://www.youtube.com/watch?v=5qap5aO4i9A")
    return str(focus), str(sleep)

# ---------- Keyboards ----------
def _menu_kb(l: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text=TXT["focus_btn"][l], callback_data="music:focus"),
            InlineKeyboardButton(text=TXT["sleep_btn"][l], callback_data="music:sleep"),
        ],
        [
            InlineKeyboardButton(text=TXT["my_btn"][l],  callback_data="music:my"),
            InlineKeyboardButton(text=TXT["add_btn"][l], callback_data="music:add"),
        ],
    ])

def _open_kb(l: str, kind: str) -> InlineKeyboardMarkup:
    focus, sleep = _urls()
    url = focus if kind == "focus" else sleep
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=TXT[f"open_{kind}"][l], url=url)],
        [InlineKeyboardButton(text=TXT["back"][l], callback_data="music:back")],
    ])

def _numbers_kb(l: str, items: list[tuple[int, str]]) -> InlineKeyboardMarkup:
    # items: list of (id, title). –ù–∞ –∫–Ω–æ–ø–∫–∞—Ö ‚Äî 1..5..10
    row, kb = [], []
    for idx, (iid, _title) in enumerate(items, start=1):
        row.append(InlineKeyboardButton(text=str(idx), callback_data=f"music:play/{iid}"))
        if len(row) == 5:
            kb.append(row); row = []
    if row:
        kb.append(row)
    kb.append([InlineKeyboardButton(text=TXT["back"][l], callback_data="music:back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

# ---------- DB helpers ----------
async def _dialect(session: AsyncSession) -> str:
    try:
        return session.bind.sync_engine.dialect.name
    except Exception:
        return "sqlite"

async def _ensure_schema(session: AsyncSession):
    d = await _dialect(session)
    if d == "sqlite":
        ddl = """
        CREATE TABLE IF NOT EXISTS user_tracks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER NOT NULL,
            title TEXT,
            file_id TEXT NOT NULL,
            created_at TEXT DEFAULT (CURRENT_TIMESTAMP)
        );
        CREATE UNIQUE INDEX IF NOT EXISTS ux_user_tracks_tg_file
            ON user_tracks (tg_id, file_id);
        CREATE INDEX IF NOT EXISTS ix_user_tracks_tg_id
            ON user_tracks (tg_id);
        """
    else:  # postgres / etc.
        ddl = """
        CREATE TABLE IF NOT EXISTS user_tracks (
            id BIGSERIAL PRIMARY KEY,
            tg_id BIGINT NOT NULL,
            title TEXT,
            file_id TEXT NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
        CREATE UNIQUE INDEX IF NOT EXISTS ux_user_tracks_tg_file
            ON user_tracks (tg_id, file_id);
        CREATE INDEX IF NOT EXISTS ix_user_tracks_tg_id
            ON user_tracks (tg_id);
        """
    # –í—ã–ø–æ–ª–Ω–∏–º –±–ª–æ–∫–æ–º: SQLite ¬´–ø—Ä–æ–≥–ª–æ—Ç–∏—Ç¬ª –Ω–µ—Å–∫–æ–ª—å–∫–æ statement-–æ–≤, PG —Ç–æ–∂–µ –æ–∫
    for stmt in filter(None, (s.strip() for s in ddl.split(";"))):
        if stmt:
            await session.execute(sql_text(stmt))
    await session.commit()

async def _save_track(session: AsyncSession, tg: int, title: str, fid: str):
    await _ensure_schema(session)
    d = await _dialect(session)
    if d == "sqlite":
        q = "INSERT OR IGNORE INTO user_tracks (tg_id, title, file_id) VALUES (:tg, :t, :f)"
    else:
        q = ("INSERT INTO user_tracks (tg_id, title, file_id) VALUES (:tg, :t, :f) "
             "ON CONFLICT (tg_id, file_id) DO NOTHING")
    await session.execute(sql_text(q), {"tg": tg, "t": title, "f": fid})
    await session.commit()

async def _list_tracks(session: AsyncSession, tg: int, limit: int = 10) -> list[tuple[int, str]]:
    await _ensure_schema(session)
    res = await session.execute(
        sql_text("SELECT id, COALESCE(title,'Track') FROM user_tracks "
                 "WHERE tg_id=:tg ORDER BY id DESC LIMIT :lim"),
        {"tg": tg, "lim": limit}
    )
    return [(row[0], row[1]) for row in res.fetchall()]

async def _get_track(session: AsyncSession, tg: int, track_id: int) -> tuple[str, str] | None:
    await _ensure_schema(session)
    res = await session.execute(
        sql_text("SELECT file_id, COALESCE(title,'Track') "
                 "FROM user_tracks WHERE id=:i AND tg_id=:tg"),
        {"i": track_id, "tg": tg}
    )
    row = res.fetchone()
    return (row[0], row[1]) if row else None

# ---------- handlers ----------
@router.message(Command("music"))
@router.message(F.text.in_({"üéµ Music", "üéµ –ú—É–∑–∏–∫–∞", "üéµ –ú—É–∑—ã–∫–∞", "music", "–º—É–∑—ã–∫–∞", "–º—É–∑–∏–∫–∞"}))
async def cmd_music(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    await m.answer(TXT["menu"][l], reply_markup=_menu_kb(l))

@router.callback_query(F.data.startswith("music:"))
async def on_music_choice(c: CallbackQuery, session: AsyncSession):
    l = await _lang(c, session)
    kind = c.data.split(":", 1)[1]

    # –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º ¬´—á–∞—Å–∏–∫–∏¬ª
    try:
        await c.answer()
    except TelegramBadRequest:
        pass

    if kind == "back":
        await c.message.answer(TXT["menu"][l], reply_markup=_menu_kb(l))
        return

    if kind in {"focus", "sleep"}:
        await c.message.answer(TXT["menu"][l], reply_markup=_open_kb(l, kind))
        return

    if kind == "add":
        await c.message.answer(TXT["send_audio_hint"][l])
        return

    if kind == "my":
        tg = getattr(getattr(c, "from_user", None), "id", None)
        rows = await _list_tracks(session, tg) if tg else []
        if not rows:
            await c.message.answer(TXT["empty"][l] + TXT["send_audio_hint"][l])
        else:
            await c.message.answer(TXT["your_tracks"][l], reply_markup=_numbers_kb(l, rows))
        return

    if kind.startswith("play/"):
        _, sid = kind.split("/", 1)
        try:
            track_id = int(sid)
        except Exception:
            return
        tg = getattr(getattr(c, "from_user", None), "id", None)
        if tg is None:
            return
        got = await _get_track(session, tg, track_id)
        if got:
            fid, title = got
            await c.message.answer_audio(audio=fid, caption=title or None)
        return

@router.message(F.audio)
async def on_audio_inbox(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    tg = getattr(getattr(m, "from_user", None), "id", None)
    if tg is None:
        return
    title = (getattr(m.audio, "title", None)
             or getattr(m.audio, "file_name", None)
             or getattr(m.audio, "performer", None)
             or "Track")
    await _save_track(session, tg, title, m.audio.file_id)
    await m.answer(TXT["saved"][l])

# —Ç–∞–∫–∂–µ –ø—Ä–∏–º–µ–º mp3 –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç (—á–∞—Å—Ç–æ –ø—Ä–∏—Å—ã–ª–∞—é—Ç –∏–º–µ–Ω–Ω–æ —Ç–∞–∫)
@router.message(F.document.mime_type.startswith("audio/"))
async def on_audio_document(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    tg = getattr(getattr(m, "from_user", None), "id", None)
    if tg is None:
        return
    title = (getattr(m.document, "file_name", None) or "Track")
    await _save_track(session, tg, title, m.document.file_id)
    await m.answer(TXT["saved"][l])
==========================================================================================
# app/filters/buttons.py
==========================================================================================

from aiogram.filters import BaseFilter
from aiogram.types import Message
import re
from app.i18n import t

_rx = re.compile(r'[^a-zA-Z–∞-—è–ê-–Ø—ë–Å—ñ–Ü—ó–á—î–Ñ“ë“ê0-9]+', re.U)

def _norm(x: str) -> str:
    return _rx.sub('', (x or '').strip().lower())

class Btn(BaseFilter):
    def __init__(self, key: str):
        self.key = key

    async def __call__(self, message: Message) -> bool:
        txt = _norm(getattr(message, "text", "") or "")
        if not txt:
            return False
        variants = {
            _norm(t(self.key, "ru")),
            _norm(t(self.key, "uk")),
            _norm(t(self.key, "en")),
        }
        if self.key in {"btn_premium", "menu_premium"}:
            variants |= {"premium","–ø—Ä–µ–º–∏—É–º","–ø—Ä–µ–º—ñ—É–º"}
            if (message.text or "").lstrip().startswith("/premium"):
                return True
        return txt in variants

==========================================================================================
# app/handlers/__init__.py
==========================================================================================

==========================================================================================
# app/handlers/common.py
==========================================================================================
# app/handlers/cancel.py
from aiogram import Router
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from app.keyboards import get_main_kb  # —É–∂–µ –µ—Å—Ç—å —É –Ω–∞—Å

router = Router(name="cancel")

# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º /cancel –∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
_CANCEL_WORDS = {
    "ru": {"–æ—Ç–º–µ–Ω–∞", "—Å—Ç–æ–ø", "cancel", "/cancel"},
    "uk": {"—Å–∫–∞—Å—É–≤–∞—Ç–∏", "–≤—ñ–¥–º—ñ–Ω–∞", "cancel", "/cancel"},
    "en": {"cancel", "stop", "/cancel"},
}
_MSG = {
    "ru": "–û–∫, –æ—Ç–º–µ–Ω–∏–ª. –¢—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é.",
    "uk": "–û–∫, —Å–∫–∞—Å—É–≤–∞–≤. –¢–∏ –≤ –≥–æ–ª–æ–≤–Ω–æ–º—É –º–µ–Ω—é.",
    "en": "Okay, canceled. You're in the main menu.",
}

def _is_cancel_text(text: str) -> bool:
    t = text.strip().lower()
    # –æ–±—â–∏–π –ø—É–ª —Å–ª–æ–≤, —á—Ç–æ–±—ã –Ω–µ –≥–æ—Ä–æ–¥–∏—Ç—å –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
    universe = set().union(*_CANCEL_WORDS.values())
    return t in universe

@router.message(Command("cancel"))
@router.message(lambda m: m.text and _is_cancel_text(m.text))
async def cancel_any(m: Message, state: FSMContext, lang: str):
    # lang –ø—Ä–∏—Ö–æ–¥–∏—Ç –∏–∑ LangMiddleware (data["lang"])
    await state.clear()
    msg = _MSG.get(lang, _MSG["ru"])
    await m.answer(msg, reply_markup=get_main_kb(lang))
==========================================================================================
# app/handlers/erase.py
==========================================================================================
# app/handlers/erase.py
from __future__ import annotations

import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional

from aiogram import Router
from aiogram.filters import StateFilter, Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.types import Message
from sqlalchemy import select, delete, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.models.journal import JournalEntry
from app.models.reminder import Reminder
from app.models.bug_report import BugReport

router = Router()


class EraseFSM(StatesGroup):
    confirm = State()


_L10N = {
    "prompt": {
        "ru": "‚ùóÔ∏è–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–≤–æ–∏ –∑–∞–ø–∏—Å–∏/—Ä–µ–ø–æ—Ä—Ç—ã/–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è?\n\n–ù–∞–ø–∏—à–∏: <code>{phrase}</code>\n–ò–ª–∏ /cancel ‚Äî —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å.\n\n(–ö–æ–¥ –¥–µ–π—Å—Ç–≤—É–µ—Ç 2 –º–∏–Ω—É—Ç—ã.)",
        "uk": "‚ùóÔ∏è–í–∏–¥–∞–ª–∏—Ç–∏ –≤—Å—ñ —Ç–≤–æ—ó –∑–∞–ø–∏—Å–∏/—Ä–µ–ø–æ—Ä—Ç–∏/–Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è?\n\n–ù–∞–ø–∏—à–∏: <code>{phrase}</code>\n–ê–±–æ /cancel ‚Äî —â–æ–± —Å–∫–∞—Å—É–≤–∞—Ç–∏.\n\n(–ö–æ–¥ –¥—ñ—î 2 —Ö–≤–∏–ª–∏–Ω–∏.)",
        "en": "‚ùóÔ∏èDelete all your entries/reports/reminders?\n\nType: <code>{phrase}</code>\nOr /cancel to abort.\n\n(The code is valid for 2 minutes.)",
    },
    "canceled": {
        "ru": "–û—Ç–º–µ–Ω–∏–ª. –ù–∏—á–µ–≥–æ –Ω–µ —É–¥–∞–ª—è–ª.",
        "uk": "–°–∫–∞—Å—É–≤–∞–≤. –ù—ñ—á–æ–≥–æ –Ω–µ –≤–∏–¥–∞–ª—è–≤.",
        "en": "Canceled. Nothing was deleted.",
    },
    "need_start": {
        "ru": "–ù–∞–∂–º–∏ /start",
        "uk": "–ù–∞—Ç–∏—Å–Ω–∏ /start",
        "en": "Press /start",
    },
    "expired": {
        "ru": "‚è± –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞ –∏—Å—Ç—ë–∫. –í—ã–∑–æ–≤–∏ /erase —Å–Ω–æ–≤–∞.",
        "uk": "‚è± –¢–µ—Ä–º—ñ–Ω –¥—ñ—ó –∫–æ–¥—É –º–∏–Ω—É–≤. –í–∏–∫–ª–∏—á /erase —â–µ —Ä–∞–∑.",
        "en": "‚è± The code expired. Run /erase again.",
    },
    "wrong": {
        "ru": "–ù—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å —Ä–æ–≤–Ω–æ: <code>{phrase}</code> ‚Äî –∏–ª–∏ /cancel",
        "uk": "–ü–æ—Ç—Ä—ñ–±–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç–∏ —Ä—ñ–≤–Ω–æ: <code>{phrase}</code> ‚Äî –∞–±–æ /cancel",
        "en": "You must type exactly: <code>{phrase}</code> ‚Äî or /cancel",
    },
    "done": {
        "ru": "‚úÖ –ì–æ—Ç–æ–≤–æ. –í—Å–µ —Ç–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã.\n(–ê–∫–∫–∞—É–Ω—Ç –æ—Å—Ç–∞–≤–∏–ª, –º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º.)\n\n–£–¥–∞–ª–µ–Ω–æ: –∑–∞–º–µ—Ç–æ–∫ ‚Äî {j}, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π ‚Äî {r}, —Ä–µ–ø–æ—Ä—Ç–æ–≤ ‚Äî {b}.",
        "uk": "‚úÖ –ì–æ—Ç–æ–≤–æ. –£—Å—ñ —Ç–≤–æ—ó –¥–∞–Ω—ñ –≤–∏–¥–∞–ª–µ–Ω–æ.\n(–ê–∫–∞—É–Ω—Ç –ª–∏—à–∏–≤, –º–æ–∂–Ω–∞ –¥–∞–ª—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è –±–æ—Ç–æ–º.)\n\n–í–∏–¥–∞–ª–µ–Ω–æ: –Ω–æ—Ç–∞—Ç–æ–∫ ‚Äî {j}, –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å ‚Äî {r}, —Ä–µ–ø–æ—Ä—Ç—ñ–≤ ‚Äî {b}.",
        "en": "‚úÖ Done. All your data is deleted.\n(Account kept; you can continue using the bot.)\n\nDeleted: entries ‚Äî {j}, reminders ‚Äî {r}, reports ‚Äî {b}.",
    },
}


def _lang(m: Message, user: Optional[User]) -> str:
    return (getattr(user, "language", None) or getattr(getattr(m, "from_user", None), "language_code", None) or "ru").lower()


def _t(key: str, lang: str, **kwargs) -> str:
    tpl = _L10N[key].get(lang) or _L10N[key]["ru"]
    return tpl.format(**kwargs)


@router.message(Command("erase"))
async def erase_start(m: Message, state: FSMContext):
    # –ì–µ–Ω–µ—Ä–∏–º –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—É—é —Ñ—Ä–∞–∑—É –≤–∏–¥–∞ "DELETE ABC123"
    token = secrets.token_hex(3).upper()  # 6 —Å–∏–º–≤–æ–ª–æ–≤
    phrase = f"DELETE {token}"
    expires_at = datetime.now(timezone.utc) + timedelta(minutes=2)

    await state.set_state(EraseFSM.confirm)
    await state.update_data(phrase=phrase, expires_at=expires_at.isoformat())

    # –Ø–∑—ã–∫ –≤–æ–∑—å–º—ë–º –∏–∑ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–∑–∂–µ, —Ç—É—Ç –ø–æ–∫–∞ –±–µ–∑ session
    await m.answer(_t("prompt", _lang(m, None), phrase=phrase), parse_mode="HTML")


@router.message(Command("cancel"))
async def erase_cancel(m: Message, state: FSMContext):
    await state.clear()
    await m.answer(_t("canceled", _lang(m, None)))


@router.message(EraseFSM.confirm)
async def erase_do(m: Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    phrase = data.get("phrase")
    expires_at_s = data.get("expires_at")

    # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
    if not phrase or not expires_at_s:
        await state.clear()
        return await m.answer(_t("expired", _lang(m, None)))

    try:
        expires_at = datetime.fromisoformat(expires_at_s)
    except Exception:
        await state.clear()
        return await m.answer(_t("expired", _lang(m, None)))

    # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    lang = _lang(m, user)

    if not user:
        await state.clear()
        return await m.answer(_t(lang, "need_start"))

    text = (m.text or "").strip()
    if text.lower() == "/cancel":
        await state.clear()
        return await m.answer(_t(lang, "canceled"))

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞
    if datetime.now(timezone.utc) > expires_at:
        await state.clear()
        return await m.answer(_t(lang, "expired"))

    # –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
    if text != phrase:
        return await m.answer(_t("wrong", lang, phrase=phrase), parse_mode="HTML")

    # –ü–æ—Å—á–∏—Ç–∞–µ–º, —á—Ç–æ–±—ã –æ—Ç—á–∏—Ç–∞—Ç—å—Å—è
    j_cnt = await session.scalar(
        select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
    )
    r_cnt = await session.scalar(
        select(func.count()).select_from(Reminder).where(Reminder.user_id == user.id)
    )
    b_cnt = await session.scalar(
        select(func.count()).select_from(BugReport).where(BugReport.user_id == user.id)
    )

    # –£–¥–∞–ª—è–µ–º
    async with session.begin():
        await session.execute(
            delete(JournalEntry).where(JournalEntry.user_id == user.id).execution_options(synchronize_session=False)
        )
        await session.execute(
            delete(Reminder).where(Reminder.user_id == user.id).execution_options(synchronize_session=False)
        )
        await session.execute(
            delete(BugReport).where(BugReport.user_id == user.id).execution_options(synchronize_session=False)
        )

    await state.clear()
    await m.answer(_t("done", lang, j=j_cnt or 0, r=r_cnt or 0, b=b_cnt or 0))
==========================================================================================
# app/handlers/export.py
==========================================================================================
from __future__ import annotations

import io
import json
import gzip
from datetime import datetime, timezone
from typing import Optional

from aiogram import Router
from aiogram.filters import StateFilter, Command
from aiogram.types import Message, BufferedInputFile
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.config import settings
from app.models.user import User
from app.models.journal import JournalEntry
from app.models.reminder import Reminder
from app.models.bug_report import BugReport  # –í–ê–ñ–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º BugReport

router = Router()


# –ü—Ä–æ—Å—Ç–µ–Ω—å–∫–∞—è –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è 2 —Å–æ–æ–±—â–µ–Ω–∏–π
_L10N = {
    "export_disabled": {
        "ru": "–≠–∫—Å–ø–æ—Ä—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –≤—ã–∫–ª—é—á–µ–Ω.",
        "uk": "–ï–∫—Å–ø–æ—Ä—Ç —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–º–∫–Ω–µ–Ω–æ.",
        "en": "Export is temporarily disabled.",
    },
    "press_start": {
        "ru": "–ù–∞–∂–º–∏ /start",
        "uk": "–ù–∞—Ç–∏—Å–Ω–∏ /start",
        "en": "Press /start",
    },
}


def _t(key: str, lang: Optional[str]) -> str:
    lang = (lang or settings.default_locale or "ru").lower()
    return _L10N.get(key, {}).get(lang, _L10N[key]["ru"])


def _ser_dt(dt: Optional[datetime]) -> Optional[str]:
    """ISO8601 UTC, –±–µ–∑–æ–ø–∞—Å–Ω–æ –¥–ª—è naive/aware –¥–∞—Ç."""
    if not dt:
        return None
    if dt.tzinfo is None:
        return dt.replace(tzinfo=timezone.utc).isoformat().replace("+00:00", "Z")
    return dt.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")


@router.message(Command("export"))
async def export_data(m: Message, session: AsyncSession):
    # –ù–∞ –ø—Ä–æ–¥–µ –º–æ–∂–Ω–æ –≤—ã–∫–ª—é—á–∞—Ç—å —ç–∫—Å–ø–æ—Ä—Ç —Ñ–ª–∞–≥–æ–º
    if not settings.enable_exporter:
        # –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–∫–∞–∑–∞—Ç—å –Ω–∞ —è–∑—ã–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_lang = getattr(getattr(m, "from_user", None), "language_code", None)
        return await m.answer(_t("export_disabled", user_lang))

    # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    if not user:
        user_lang = getattr(getattr(m, "from_user", None), "language_code", None)
        return await m.answer(_t("press_start", user_lang))

    # –ó–∞–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    entries = (
        await session.execute(
            select(JournalEntry)
            .where(JournalEntry.user_id == user.id)
            .order_by(JournalEntry.id)
        )
    ).scalars().all()

    reminders = (
        await session.execute(
            select(Reminder).where(Reminder.user_id == user.id).order_by(Reminder.id)
        )
    ).scalars().all()

    reports = (
        await session.execute(
            select(BugReport).where(BugReport.user_id == user.id).order_by(BugReport.id)
        )
    ).scalars().all()

    payload = {
        "user": {
            "id": user.id,
            "tg_id": user.tg_id,
            "language": getattr(user, "language", None),
            "consent_accepted_at": _ser_dt(getattr(user, "consent_accepted_at", None)),
        },
        "journal": [
            {
                "id": e.id,
                "text": e.text,
                "created_at": _ser_dt(getattr(e, "created_at", None)),
            }
            for e in entries
        ],
        "reminders": [
            {
                "id": r.id,
                "text": r.text,
                "due_at": _ser_dt(getattr(r, "due_at", None)),
                "sent_at": _ser_dt(getattr(r, "sent_at", None)),
            }
            for r in reminders
        ],
        "reports": [
            {
                "id": r.id,
                "text": r.text,
                "created_at": _ser_dt(getattr(r, "created_at", None)),
            }
            for r in reports
        ],
        "meta": {
            "exported_at": _ser_dt(datetime.now(timezone.utc)),
            "counts": {
                "journal": len(entries),
                "reminders": len(reminders),
                "reports": len(reports),
            },
            "version": "1",
        },
    }

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    fname_base = f"diary_export_{user.tg_id}_{datetime.now(timezone.utc).strftime('%Y%m%dT%H%M%SZ')}"
    raw = json.dumps(payload, ensure_ascii=False, indent=2).encode("utf-8")

    # –¢–µ–ª–µ–≥—Ä–∞–º-–ª–∏–º–∏—Ç –¥–ª—è –±–æ—Ç–æ–≤ ~50 –ú–ë. –ü–æ–¥—Å—Ç—Ä–∞—Ö—É–µ–º—Å—è gzip‚Äô–æ–º, –µ—Å–ª–∏ > 8 –ú–ë.
    if len(raw) > 8 * 1024 * 1024:
        buf = io.BytesIO()
        with gzip.GzipFile(fileobj=buf, mode="wb") as gz:
            gz.write(raw)
        data = buf.getvalue()
        fname = f"{fname_base}.json.gz"
    else:
        data = raw
        fname = f"{fname_base}.json"

    await m.answer_document(BufferedInputFile(data, filename=fname))
==========================================================================================
# app/handlers/journal.py
==========================================================================================
# app/handlers/journal.py
from aiogram import Router, F
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from app.models.user import User
from app.models.journal import JournalEntry
try:
    from app.handlers.premium import maybe_grant_trial
except Exception:
    async def maybe_grant_trial(*a, **k):
        return False
from app.keyboards import get_main_kb

router = Router()

class JournalFSM(StatesGroup):
    waiting_text = State()

def _tr(lang: str | None, ru: str, uk: str, en: str) -> str:
    l = (lang or "ru").lower()
    if l == "uk":
        return uk
    if l == "en":
        return en
    return ru

@router.message(Command("journal"))
async def journal_prompt(m: Message, state: FSMContext, lang: str):
    # –í—Ö–æ–¥–∏–º –≤ —Ä–µ–∂–∏–º –ø—Ä–∏—ë–º–∞ –æ–¥–Ω–æ–π –∑–∞–ø–∏—Å–∏
    await state.set_state(JournalFSM.waiting_text)
    await m.answer(
        _tr(
            lang,
            "–ù–∞–ø–∏—à–∏ 2‚Äì3 –º—ã—Å–ª–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n\n/cancel ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å",
            "–ù–∞–ø–∏—à–∏ 2‚Äì3 –¥—É–º–∫–∏ –∑–∞ —Å—å–æ–≥–æ–¥–Ω—ñ –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.\n\n/cancel ‚Äî —Å–∫–∞—Å—É–≤–∞—Ç–∏",
            "Send 2‚Äì3 thoughts for today in one message.\n\n/cancel ‚Äî cancel",
        )
    )

@router.message(Command("cancel"))
async def journal_cancel(m: Message, state: FSMContext, lang: str):
    await state.clear()
    await m.answer(
        _tr(
            lang,
            "–û—Ç–º–µ–Ω–∏–ª. –ó–∞–ø–∏—Å—å –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.",
            "–°–∫–∞—Å—É–≤–∞–≤. –ó–∞–ø–∏—Å –Ω–µ –∑–±–µ—Ä–µ–∂–µ–Ω–æ.",
            "Cancelled. Entry not saved.",
        ),
        reply_markup=get_main_kb(lang),
    )

@router.message(JournalFSM.waiting_text, F.text)
async def journal_save(
    m: Message,
    state: FSMContext,
    session: AsyncSession,
    lang: str,
):
    # –Æ–∑–µ—Ä –∏ —Å–æ–≥–ª–∞—Å–∏–µ
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()

    if not user or not user.consent_accepted_at:
        await state.clear()
        return await m.answer(
            _tr(
                lang,
                "–ù—É–∂–Ω–æ –ø—Ä–∏–Ω—è—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É: –Ω–∞–∂–º–∏ üîí Privacy",
                "–ü–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫—É: –Ω–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
                "You need to accept the policy: tap üîí Privacy",
            ),
            reply_markup=get_main_kb(getattr(user, "locale", None) or lang if user else lang),
        )

    text = (m.text or "").strip()
    if len(text) < 3:
        # —Å–ª–∏—à–∫–æ–º –ø—É—Å—Ç–æ ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –∏ –ø—Ä–æ—Å–∏–º –¥–æ–ø–∏—Å–∞—Ç—å
        return await m.answer(
            _tr(
                lang,
                "–ö–æ—Ä–æ—Ç–∫–æ–≤–∞—Ç–æ. –î–æ–±–∞–≤—å –¥–µ—Ç–∞–ª–µ–π –∏ –æ—Ç–ø—Ä–∞–≤—å –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
                "–ó–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫–æ. –î–æ–¥–∞–π –¥–µ—Ç–∞–ª–µ–π —ñ –Ω–∞–¥—ñ—à–ª–∏ –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.",
                "Too short. Add a bit more detail and send again in one message.",
            )
        )

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–ø–∏—Å—å
    entry = JournalEntry(user_id=user.id, text=text)
    session.add(entry)
    await session.commit()

    # –ü—Ä–µ–º–∏—É–º-—Ç—Ä–∏–∞–ª (–º—è–≥–∫–æ, –±–µ–∑ –ø–∞–¥–µ–Ω–∏–π)
    try:
        await maybe_grant_trial(session, user, m.bot)
    except Exception:
        pass

    await state.clear()

    # –ü—Ä–æ—Å—Ç–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    total = (
        await session.execute(
            select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
        )
    ).scalar() or 0

    await m.answer(
        _tr(
            lang,
            f"–°–æ—Ö—Ä–∞–Ω–∏–ª. –ó–∞–ø–∏—Å–µ–π –≤—Å–µ–≥–æ: {total}.\n\n/stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, /remind ‚Äî —Å–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.",
            f"–ó–±–µ—Ä—ñ–≥. –ó–∞–ø–∏—Å—ñ–≤ –≤—Å—å–æ–≥–æ: {total}.\n\n/stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, /remind ‚Äî —Å—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è.",
            f"Saved. Total entries: {total}.\n\n/stats ‚Äî stats, /remind ‚Äî create a reminder.",
        ),
        reply_markup=get_main_kb(getattr(user, "locale", None) or lang),
    )

@router.message(Command("stats"))
async def journal_stats(m: Message, session: AsyncSession, lang: str):
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    if not user:
        return await m.answer(_tr(lang, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))

    total = (
        await session.execute(
            select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
        )
    ).scalar() or 0

    await m.answer(
        _tr(
            lang,
            f"–ó–∞–ø–∏—Å–µ–π –≤—Å–µ–≥–æ: {total}. –ü—Ä–æ–¥–æ–ª–∂–∞–π –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!",
            f"–ó–∞–ø–∏—Å—ñ–≤ –≤—Å—å–æ–≥–æ: {total}. –ü—Ä–æ–¥–æ–≤–∂—É–π —É —Ç–æ–º—É –∂ –¥—É—Å—ñ!",
            f"Total entries: {total}. Keep it up!",
        )
    )
==========================================================================================
# app/handlers/language.py
==========================================================================================
# app/handlers/language.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, text as sql_text

from app.models.user import User
from app.keyboards import get_main_kb, is_language_btn

router = Router()

ALIASES = {
    "ru": "ru", "rus": "ru", "—Ä—É": "ru", "—Ä—É—Å": "ru", "—Ä—É—Å—Å–∫–∏–π": "ru",
    "uk": "uk", "ua": "uk", "—É–∫": "uk", "—É–∫—Ä": "uk", "—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞": "uk", "—Ä–æ—Å—ñ–π—Å—å–∫–∞": "ru", "—É–∫—Ä–∞–∏–Ω—Å–∫–∏–π": "uk",
    "en": "en", "eng": "en", "–∞–Ω–≥–ª": "en", "–∞–Ω–≥–ª–∏–π—Å–∫–∏–π": "en", "–∞–Ω–≥–ª—ñ–π—Å—å–∫–∞": "en", "english": "en",
}

PROMPT = {
    "ru": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫: RU / UK / EN (–º–æ–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å: —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / english)",
    "uk": "–í–∏–±–µ—Ä–∏ –º–æ–≤—É: RU / UK / EN (–º–æ–∂–Ω–∞ –Ω–∞–ø–∏—Å–∞—Ç–∏: —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / —Ä—É—Å—Å–∫–∏–π / english)",
    "en": "Choose language: RU / UK / EN (you can type: english / —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞)",
}

def _safe_loc(user: User | None) -> str:
    loc = (getattr(user, "locale", None) or getattr(user, "lang", None) or "ru").lower()
    return "uk" if loc == "ua" else (loc if loc in {"ru","uk","en"} else "ru")

@router.message(F.text.func(is_language_btn) | F.text.regexp(r"(?i)^\s*(/language|language|—è–∑—ã–∫|–º–æ–≤–∞)\s*$"))
async def language_start(m: Message, session: AsyncSession):
    user = (await session.execute(select(User).where(User.tg_id == m.from_user.id))).scalar_one_or_none()
    loc = _safe_loc(user)
    await m.answer(PROMPT.get(loc, PROMPT["ru"]), reply_markup=None)

@router.message(F.text.func(lambda s: (s or "").strip().lower() in ALIASES))
async def language_set(m: Message, session: AsyncSession):
    code = ALIASES[(m.text or "").strip().lower()]

    # ORM-—Å—Ç–∏–ª—å: —Å–æ–∑–¥–∞—ë–º, –µ—Å–ª–∏ –Ω–µ—Ç, –∏–Ω–∞—á–µ –∞–ø–¥–µ–π—Ç–∏–º
    user = (await session.execute(select(User).where(User.tg_id == m.from_user.id))).scalar_one_or_none()
    if not user:
        user = User(tg_id=m.from_user.id, locale=code, lang=code)
        session.add(user)
    else:
        user.locale = code
        # –¥–µ—Ä–∂–∏–º lang –≤ —Å–∏–Ω–∫–µ ‚Äì –Ω–∞ –±—É–¥—É—â–µ–µ
        try:
            await session.execute(sql_text("UPDATE users SET lang=:lang WHERE tg_id=:tg"), {"lang": code, "tg": m.from_user.id})
        except Exception:
            user.lang = code

    await session.commit()
    msg = {"ru":"–ì–æ—Ç–æ–≤–æ. –Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª—ë–Ω.","uk":"–ì–æ—Ç–æ–≤–æ. –ú–æ–≤—É –æ–Ω–æ–≤–ª–µ–Ω–æ.","en":"Done. Language updated."}.get(code,"Done.")
    await m.answer(msg, reply_markup=get_main_kb(code))
==========================================================================================
# app/handlers/premium.py
==========================================================================================

# ====== –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é (–∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—â–µ–µ)
from __future__ import annotations
from app.filters.buttons import Btn

import os
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo

from aiogram import Router, F
from aiogram.filters import StateFilter, Command
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

from app.config import settings


# ====== i18n (fallback-safe) ======
try:
    from app.i18n import t as _i18n_t  # –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã –≤–∏–¥–∞ "[key]"
except Exception:
    _i18n_t = None

_DEF = {
    "premium_on": {
        "ru": "–ü—Ä–µ–º–∏—É–º —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω ‚úÖ",
        "uk": "–ü—Ä–µ–º—ñ—É–º —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π ‚úÖ",
        "en": "Premium is already active ‚úÖ",
    },
    "premium_on_till": {
        "ru": "–ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {dt} ({tz}) ‚úÖ",
        "uk": "–ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {dt} ({tz}) ‚úÖ",
        "en": "Premium is active until {dt} ({tz}) ‚úÖ",
    },
    "subscribe_offer": {
        "ru": "–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî –∏ –ø–æ–ª—É—á–∏ 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞ üéÅ",
        "uk": "–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –ü—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî —ñ –æ—Ç—Ä–∏–º–∞–π 24 –≥–æ–¥–∏–Ω–∏ –ø—Ä–µ–º—ñ—É–º—É üéÅ",
        "en": "Premium is off. Subscribe to our channel and get 24h of Premium üéÅ",
    },
    "sub_given": {
        "ru": "–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞ ‚úÖ",
        "uk": "–í—ñ—Ç–∞—é! –ü—ñ–¥–ø–∏—Å–∫—É –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ ‚Äî –ø—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ ‚úÖ",
        "en": "Congrats! Subscription confirmed ‚Äî Premium activated for 24 hours ‚úÖ",
    },
    "sub_not_found": {
        "ru": "–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫–∏. –ù–∞–∂–º–∏ ¬´–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è¬ª, –∑–∞—Ç–µ–º ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª.",
        "uk": "–ù–µ –±–∞—á—É –ø—ñ–¥–ø–∏—Å–∫–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è¬ª, –ø–æ—Ç—ñ–º ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª.",
        "en": "I can‚Äôt see your subscription. Tap ‚ÄúSubscribe‚Äù then ‚ÄúCheck‚Äù.",
    },
    "btn_pay":   {"ru": "–û–ø–ª–∞—Ç–∏—Ç—å", "uk": "–û–ø–ª–∞—Ç–∏—Ç–∏", "en": "Pay"},
    "btn_sub":   {"ru": "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", "uk": "–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è", "en": "Subscribe"},
    "btn_check": {"ru": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å", "uk": "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏", "en": "Check"},
}

def t(lang: str, key: str, **fmt) -> str:
    """–°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π i18n, –µ—Å–ª–∏ –æ–Ω –≤–µ—Ä–Ω—É–ª '[key]' ‚Äî –±–µ—Ä—ë–º –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å."""
    loc = (lang or "ru")[:2].lower()
    if loc == "ua":
        loc = "uk"

    if _i18n_t:
        try:
            s = _i18n_t(key, loc)  # –¥–æ–ø—É—Å–∫–∞–µ–º –ª—é–±–æ–π –ø–æ—Ä—è–¥–æ–∫ –≤ –∏—Ö —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
            if isinstance(s, str) and not s.startswith("["):
                return s.format(**fmt) if fmt else s
        except Exception:
            pass

    v = (_DEF.get(key) or {}).get(loc) or (_DEF.get(key) or {}).get("ru") or key
    return v.format(**fmt) if fmt else v

router = Router()

CHANNEL_USERNAME = (
    getattr(settings, "premium_channel", None)
    or os.getenv("PREMIUM_CHANNEL")
    or "@NoticesDiarY"
)
CHANNEL_URL = f"https://t.me/{CHANNEL_USERNAME.lstrip('@')}"

try:
    from app.lang import t  # type: ignore
except Exception:
    try:
        from app.i18n import t  # type: ignore
    except Exception:
        _DEF = {
            "premium_on": {
                "ru": "–ü—Ä–µ–º–∏—É–º —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω ‚úÖ",
                "uk": "–ü—Ä–µ–º—ñ—É–º —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π ‚úÖ",
                "en": "Premium is already active ‚úÖ",
            },
            "premium_on_till": {
                "ru": "–ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {dt} ({tz}) ‚úÖ",
                "uk": "–ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {dt} ({tz}) ‚úÖ",
                "en": "Premium is active until {dt} ({tz}) ‚úÖ",
            },
            "subscribe_offer": {
                "ru": "–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî –∏ –ø–æ–ª—É—á–∏ 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞ üéÅ",
                "uk": "–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –ü—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî —ñ –æ—Ç—Ä–∏–º–∞–π 24 –≥–æ–¥–∏–Ω–∏ –ø—Ä–µ–º—ñ—É–º—É üéÅ",
                "en": "Premium is off. Subscribe to our channel and get 24h of Premium üéÅ",
            },
            "sub_given": {
                "ru": "–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞ ‚úÖ",
                "uk": "–í—ñ—Ç–∞—é! –ü—ñ–¥–ø–∏—Å–∫—É –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ ‚Äî –ø—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ ‚úÖ",
                "en": "Congrats! Subscription confirmed ‚Äî Premium activated for 24 hours ‚úÖ",
            },
            "sub_not_found": {
                "ru": "–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫–∏. –ù–∞–∂–º–∏ ¬´–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è¬ª, –∑–∞—Ç–µ–º ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª.",
                "uk": "–ù–µ –±–∞—á—É –ø—ñ–¥–ø–∏—Å–∫–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è¬ª, –ø–æ—Ç—ñ–º ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª.",
                "en": "I can‚Äôt see your subscription. Tap ‚ÄúSubscribe‚Äù then ‚ÄúCheck‚Äù.",
            },
            "btn_pay":   {"ru": "–û–ø–ª–∞—Ç–∏—Ç—å", "uk": "–û–ø–ª–∞—Ç–∏—Ç–∏", "en": "Pay"},
            "btn_sub":   {"ru": "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", "uk": "–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è", "en": "Subscribe"},
            "btn_check": {"ru": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å", "uk": "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏", "en": "Check"},
        }
        def t(lang: str, key: str, **fmt) -> str:
            l = (lang or "ru")[:2].lower()
            v = _DEF.get(key, {})
            if isinstance(v, dict):
                txt = v.get(l) or v.get("ru") or key
                return txt.format(**fmt) if fmt else txt
            return str(v)

try:
    from app.keyboards import get_main_kb  # type: ignore
except Exception:
    def get_main_kb(lang: str):
        return None

_SUPPORTED = {"ru", "uk", "en"}

def _lang_of(u: dict | None, m: Message | CallbackQuery | None) -> str:
    if isinstance(u, dict) and (u.get("lang") or u.get("locale")):
        l = (u.get("lang") or u.get("locale") or "ru")[:2].lower()
    else:
        code = None
        if isinstance(m, Message):
            code = getattr(getattr(m, "from_user", None), "language_code", None)
        elif isinstance(m, CallbackQuery):
            code = getattr(getattr(m, "from_user", None), "language_code", None) or \
                   getattr(getattr(m.message, "from_user", None), "language_code", None)
        l = (code or getattr(settings, "default_locale", "ru"))[:2].lower()
    l = "uk" if l == "ua" else l
    return l if l in _SUPPORTED else "ru"

async def _ensure_user_columns(session: AsyncSession) -> None:
    # –¥–æ–±–∞–≤–∏–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∫–æ–ª–æ–Ω–∫–∏ —Ç–∏—Ö–æ
    for ddl in (
        "ALTER TABLE users ADD COLUMN locale TEXT",
        "ALTER TABLE users ADD COLUMN premium_until TIMESTAMP",
        "ALTER TABLE users ADD COLUMN is_premium INTEGER DEFAULT 0",
    ):
        try:
            await session.execute(sql_text(ddl))
        except Exception:
            pass
    try:
        await session.commit()
    except Exception:
        await session.rollback()

async def _fetch_user(session: AsyncSession, tg_id: int) -> dict:
    await _ensure_user_columns(session)
    row = (await session.execute(sql_text(
        "SELECT id, tg_id, locale, lang, is_premium, premium_until, tz FROM users WHERE tg_id=:tg"
    ), {"tg": tg_id})).first()

    if row:
        vals = tuple(row)
        if len(vals) == 7:
            id_, tg, locale, lang, is_premium, premium_until, tz = vals
        elif len(vals) == 6:
            # —Å—Ç–∞—Ä—ã–π SELECT: –±–µ–∑ locale
            id_, tg, lang, is_premium, premium_until, tz = vals
            locale = None
        else:
            # —Å–æ–≤—Å–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç ‚Äî –≤–µ—Ä–Ω—ë–º –¥–µ—Ñ–æ–ª—Ç—ã
            return {"id": None, "tg_id": tg_id, "lang": "ru", "locale": None,
                    "is_premium": False, "premium_until": None,
                    "tz": getattr(settings, "default_tz", "Europe/Kyiv")}
        lang = (lang or locale or "ru")
        l2 = (lang[:2].lower() if isinstance(lang, str) else "ru")
        l2 = "uk" if l2 == "ua" else (l2 if l2 in _SUPPORTED else "ru")
        return {
            "id": id_, "tg_id": tg, "lang": l2, "locale": (locale or l2),
            "is_premium": bool(is_premium),
            "premium_until": premium_until,
            "tz": tz or getattr(settings, "default_tz", "Europe/Kyiv"),
        }

    await session.execute(sql_text(
        "INSERT INTO users (tg_id, locale, lang, is_premium) VALUES (:tg, :loc, :lang, 0)"
    ), {"tg": tg_id, "loc": "ru", "lang": "ru"})
    await session.commit()
    return {"id": None, "tg_id": tg_id, "lang": "ru", "locale": "ru",
            "is_premium": False, "premium_until": None,
            "tz": getattr(settings, "default_tz", "Europe/Kyiv")}

def _to_dt_aware(val) -> datetime | None:
    if val is None:
        return None
    if isinstance(val, datetime):
        return val if val.tzinfo else val.replace(tzinfo=timezone.utc)
    try:
        dt = datetime.fromisoformat(str(val).replace("Z", "+00:00"))
        return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)
    except Exception:
        return None

def _is_active(u: dict) -> bool:
    if not u.get("is_premium"):
        return False
    until = _to_dt_aware(u.get("premium_until"))
    return True if until is None else (datetime.now(timezone.utc) < until)

def _fmt_local(dt_utc: datetime, tz_name: str) -> str:
    try:
        return dt_utc.astimezone(ZoneInfo(tz_name)).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return dt_utc.astimezone(ZoneInfo("Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")

def _pay_kb(lang: str, tg_id: int) -> InlineKeyboardMarkup:
    base = getattr(settings, "public_url", None) or os.environ.get("PUBLIC_URL", "").strip()
    if not base.startswith("https://"):
        base = "https://example.com"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t(lang, "btn_pay"), url=f"{base}/pay?tg_id={tg_id}")]
    ])

def _subscribe_kb(lang: str, tg_id: int) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t(lang, "btn_sub"),   url=CHANNEL_URL)],
        [InlineKeyboardButton(text=t(lang, "btn_check"), callback_data="premium:check")],
        [InlineKeyboardButton(text=t(lang, "btn_pay"),   url=(getattr(settings, "public_url", "") or "https://example.com") + f"/pay?tg_id={tg_id}")],
    ])

async def _grant_24h(session: AsyncSession, tg_id: int) -> None:
    await _ensure_user_columns(session)
    until = datetime.now(timezone.utc) + timedelta(days=1)
    await session.execute(sql_text(
        "UPDATE users SET is_premium=1, premium_until=:u WHERE tg_id=:tg"
    ), {"u": until, "tg": tg_id})
    await session.commit()

async def _user_is_channel_member(bot, user_id: int) -> bool:
    try:
        cm = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        status = getattr(cm, "status", None)
        status = getattr(status, "value", status)  # Enum -> str
        return str(status) in {"member", "administrator", "creator"}
    except Exception:
        return False

async def maybe_grant_trial(session: AsyncSession, tg_id: int) -> None:
    u = await _fetch_user(session, tg_id)
    if not _is_active(u):
        await _grant_24h(session, tg_id)

@router.message(StateFilter('*'), Command("premium"))
@router.message(F.text.lower().in_({"üíé premium","premium","–ø—Ä–µ–º–∏—É–º","üíé –ø—Ä–µ–º–∏—É–º","–ø—Ä–µ–º—ñ—É–º","üíé –ø—Ä–µ–º—ñ—É–º"}))
async def cmd_premium(m: Message, session: AsyncSession, lang: str | None = None):
    u = await _fetch_user(session, m.from_user.id)
    lang = (lang or _lang_of(u, m))

    if _is_active(u):
        until = _to_dt_aware(u.get("premium_until"))
        if until:
            dt_local = _fmt_local(until, u.get("tz") or "Europe/Kyiv")
            await m.answer(
                t(lang, "premium_on_till", dt=dt_local, tz=(u.get("tz") or "Europe/Kyiv")),
                reply_markup=get_main_kb(lang)
            )
            return
        await m.answer(t(lang, "premium_on"), reply_markup=get_main_kb(lang))
        return

    await m.answer(t(lang, "subscribe_offer"), reply_markup=_subscribe_kb(lang, m.from_user.id))

@router.callback_query(F.data == "premium:check")
async def premium_check(c: CallbackQuery, session: AsyncSession, lang: str | None = None):
    u = await _fetch_user(session, c.from_user.id)
    lang = (lang or _lang_of(u, c))

    try:
        is_member = await _user_is_channel_member(c.bot, c.from_user.id)
        await c.answer()
    except Exception:
        is_member = False
        await c.answer()

    if is_member:
        await _grant_24h(session, c.from_user.id)
        await c.message.answer(t(lang, "sub_given"), reply_markup=get_main_kb(lang))
    else:
        await c.message.answer(t(lang, "sub_not_found"), reply_markup=_subscribe_kb(lang, c.from_user.id))


# === PATCH: robust local t() for Premium ===
try:
    from app.i18n import t as _i18n_t
except Exception:
    _i18n_t = None

# –ª–æ–∫–∞–ª—å–Ω—ã–π fallback —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–µ–º–∏—É–º-–∫–ª—é—á–µ–π (–Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –ø–µ—Ä–µ–≤–æ–¥—ã –Ω–µ –ø–æ–¥—Ö–≤–∞—Ç—è—Ç—Å—è)
_DEF_PREMIUM = {
    "premium_on": {
        "ru": "–ü—Ä–µ–º–∏—É–º —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω ‚úÖ",
        "uk": "–ü—Ä–µ–º—ñ—É–º —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π ‚úÖ",
        "en": "Premium is already active ‚úÖ",
    },
    "premium_on_till": {
        "ru": "–ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {dt} ({tz}) ‚úÖ",
        "uk": "–ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {dt} ({tz}) ‚úÖ",
        "en": "Premium is active until {dt} ({tz}) ‚úÖ",
    },
    "subscribe_offer": {
        "ru": "–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî –∏ –ø–æ–ª—É—á–∏ 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞ üéÅ",
        "uk": "–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –ü—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî —ñ –æ—Ç—Ä–∏–º–∞–π 24 –≥–æ–¥–∏–Ω–∏ –ø—Ä–µ–º—ñ—É–º—É üéÅ",
        "en": "Premium is off. Subscribe to our channel and get 24h of Premium üéÅ",
    },
    "sub_given": {
        "ru": "–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞ ‚úÖ",
        "uk": "–í—ñ—Ç–∞—é! –ü—ñ–¥–ø–∏—Å–∫—É –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ ‚Äî –ø—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ ‚úÖ",
        "en": "Congrats! Subscription confirmed ‚Äî Premium activated for 24 hours ‚úÖ",
    },
    "sub_not_found": {
        "ru": "–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫–∏. –ù–∞–∂–º–∏ ¬´–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è¬ª, –∑–∞—Ç–µ–º ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª.",
        "uk": "–ù–µ –±–∞—á—É –ø—ñ–¥–ø–∏—Å–∫–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è¬ª, –ø–æ—Ç—ñ–º ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª.",
        "en": "I can‚Äôt see your subscription. Tap ‚ÄúSubscribe‚Äù then ‚ÄúCheck‚Äù.",
    },
    "btn_pay":   {"ru": "–û–ø–ª–∞—Ç–∏—Ç—å",    "uk": "–û–ø–ª–∞—Ç–∏—Ç–∏",    "en": "Pay"},
    "btn_sub":   {"ru": "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", "uk": "–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è", "en": "Subscribe"},
    "btn_check": {"ru": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å",   "uk": "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏",  "en": "Check"},
}

def _prem_t(lang: str, key: str, **fmt) -> str:
    loc = (lang or "ru")[:2].lower()
    if loc == "ua": loc = "uk"

    # 1) –ø—Ä–æ–±—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–µ i18n.t —Å—Ç—Ä–æ–≥–æ –∫–∞–∫ t(key, lang)
    if _i18n_t:
        try:
            s = _i18n_t(key, loc, **fmt)
            if isinstance(s, str) and not s.startswith("["):
                return s
        except Exception:
            pass

    # 2) –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –ø—Ä–µ–º–∏—É–º–∞
    v = (_DEF_PREMIUM.get(key) or {}).get(loc) or (_DEF_PREMIUM.get(key) or {}).get("ru") or f"[{key}]"
    try:
        return v.format(**fmt)
    except Exception:
        return v

# –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∞–µ–º name, —á—Ç–æ–±—ã –≤–µ—Å—å —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –Ω–∞—à t()
t = _prem_t
# === /PATCH ===


# --- button aliases (idempotent) ---
try:
    router.message.register(premium, StateFilter('*'), Btn('btn_premium'))   # type: ignore
    router.message.register(premium, StateFilter('*'), Btn('menu_premium')) # type: ignore
except Exception:
    pass
==========================================================================================
# app/handlers/premium_reset.py
==========================================================================================
from __future__ import annotations

import os, re
from typing import Optional
from aiogram import Router, F
from aiogram.filters import StateFilter, Command
from aiogram.types import Message, CallbackQuery
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

from app.keyboards import get_main_kb
from app.config import settings

router = Router()

def _admin_ids():
    # settings.admin_ids –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–ø–∏—Å–∫–æ–º/—Å—Ç—Ä–æ–∫–æ–π; —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è ADMINS="id1,id2"
    val = getattr(settings, "admin_ids", None)
    if isinstance(val, (list, tuple, set)):
        ids = {int(x) for x in val if str(x).isdigit()}
    elif isinstance(val, str):
        ids = {int(x) for x in re.findall(r"\d+", val)}
    else:
        ids = set()
    env = os.getenv("ADMINS", "")
    ids |= {int(x) for x in re.findall(r"\d+", env)}
    return ids

async def _reset_premium(session: AsyncSession, tg_id: int) -> int:
    q = sql_text("UPDATE users SET is_premium=0, premium_until=NULL WHERE tg_id=:tg")
    res = await session.execute(q, {"tg": tg_id})
    await session.commit()
    return res.rowcount or 0

def _loc(lang: Optional[str]) -> str:
    l = (lang or getattr(settings, "default_locale", "ru"))[:2].lower()
    return "uk" if l == "ua" else (l if l in {"ru","uk","en"} else "ru")

_MSG = {
    "ru": {
        "done_self": "–ì–æ—Ç–æ–≤–æ ‚úÖ –ü—Ä–µ–º–∏—É–º –¥–ª—è —Ç–≤–æ–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ —Å–±—Ä–æ—à–µ–Ω.",
        "done_other": "–ì–æ—Ç–æ–≤–æ ‚úÖ –ü—Ä–µ–º–∏—É–º —Å–±—Ä–æ—à–µ–Ω –¥–ª—è tg_id={tg}.",
        "no_change": "–ù–µ—á–µ–≥–æ —Å–±—Ä–∞—Å—ã–≤–∞—Ç—å ‚Äî –ø—Ä–µ–º–∏—É–º —É–∂–µ –≤—ã–∫–ª—é—á–µ–Ω.",
        "forbidden": "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —Å–±—Ä–æ—Å–∞ —É –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
        "usage": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n/premium_reset ‚Äî —Å–±—Ä–æ—Å–∏—Ç—å —É —Å–µ–±—è\n/premium_reset 123456789 ‚Äî (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω) —Å–±—Ä–æ—Å–∏—Ç—å —É tg_id",
    },
    "uk": {
        "done_self": "–ì–æ—Ç–æ–≤–æ ‚úÖ –ü—Ä–µ–º—ñ—É–º –¥–ª—è —Ç–≤–æ–≥–æ –∞–∫–∞—É–Ω—Ç–∞ —Å–∫–∏–Ω—É—Ç–æ.",
        "done_other": "–ì–æ—Ç–æ–≤–æ ‚úÖ –ü—Ä–µ–º—ñ—É–º —Å–∫–∏–Ω—É—Ç–æ –¥–ª—è tg_id={tg}.",
        "no_change": "–ù—ñ—á–æ–≥–æ —Å–∫–∏–¥–∞—Ç–∏ ‚Äî –ø—Ä–µ–º—ñ—É–º –≤–∂–µ –≤–∏–º–∫–Ω–µ–Ω–æ.",
        "forbidden": "–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø—Ä–∞–≤ –¥–ª—è —Å–∫–∏–¥–∞–Ω–Ω—è –≤ —ñ–Ω—à–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞.",
        "usage": "–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:\n/premium_reset ‚Äî —Å–∫–∏–Ω—É—Ç–∏ —É —Å–µ–±–µ\n/premium_reset 123456789 ‚Äî (–ª–∏—à–µ –∞–¥–º—ñ–Ω) —Å–∫–∏–Ω—É—Ç–∏ —É tg_id",
    },
    "en": {
        "done_self": "Done ‚úÖ Premium for your account has been reset.",
        "done_other": "Done ‚úÖ Premium has been reset for tg_id={tg}.",
        "no_change": "Nothing to reset ‚Äî premium is already off.",
        "forbidden": "Not allowed to reset for another user.",
        "usage": "Usage:\n/premium_reset ‚Äî reset for yourself\n/premium_reset 123456789 ‚Äî (admin only) reset for tg_id",
    },
}

@router.message(Command("premium_reset"))
async def premium_reset(m: Message, session: AsyncSession, lang: Optional[str] = None):
    loc = _loc(lang)
    admins = _admin_ids()
    args = (m.text or "").split()[1:]

    target_tg = m.from_user.id
    if args:
        # –∞–¥–º–∏–Ω –º–æ–∂–µ—Ç –ø–µ—Ä–µ–¥–∞—Ç—å —á—É–∂–æ–π tg_id
        m_id = re.search(r"\d{5,}", " ".join(args))
        if m_id:
            if m.from_user.id not in admins:
                await m.answer(_MSG[loc]["forbidden"])
                return
            target_tg = int(m_id.group(0))

    changed = await _reset_premium(session, target_tg)
    if changed:
        if target_tg == m.from_user.id:
            await m.answer(_MSG[loc]["done_self"], reply_markup=get_main_kb(loc))
        else:
            await m.answer(_MSG[loc]["done_other"].format(tg=target_tg), reply_markup=get_main_kb(loc))
    else:
        await m.answer(_MSG[loc]["no_change"], reply_markup=get_main_kb(loc))

# –ù–∞ –±—É–¥—É—â–µ–µ: –µ—Å–ª–∏ –¥–æ–±–∞–≤–∏—à—å –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É "premium:reset", —ç—Ç–æ—Ç —Ö–µ–Ω–¥–ª–µ—Ä —Ç–æ–∂–µ –æ—Ç—Ä–∞–±–æ—Ç–∞–µ—Ç
@router.callback_query(F.data == "premium:reset")
async def premium_reset_cb(c: CallbackQuery, session: AsyncSession, lang: Optional[str] = None):
    loc = _loc(lang)
    await c.answer()
    changed = await _reset_premium(session, c.from_user.id)
    await c.message.answer(
        _MSG[loc]["done_self"] if changed else _MSG[loc]["no_change"],
        reply_markup=get_main_kb(loc),
    )

==========================================================================================
# app/handlers/privacy.py
==========================================================================================
# app/handlers/privacy.py
from __future__ import annotations

import logging
from aiogram import Router, F
from aiogram.filters import StateFilter, Command
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

from app.keyboards import get_main_kb, is_privacy_btn

router = Router()
log = logging.getLogger(__name__)

# ---- i18n (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ñ–æ–ª–±—ç–∫) ----
POLICY_TXT = {
    "ru": (
        "–≠—Ç–æ –∂—É—Ä–Ω–∞–ª-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, –Ω–µ —Ç–µ—Ä–∞–ø–∏—è –∏ –Ω–µ –º–µ–¥—É—Å–ª—É–≥–∞.\n"
        "–ù–∞–∂–∏–º–∞—è *Agree*, –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ –∏ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ –ü–æ–ª–∏—Ç–∏–∫—É.\n"
        "–ö–æ–º–∞–Ω–¥—ã: /journal ‚Äî –∑–∞–ø–∏—Å—å, /remind ‚Äî –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ, /stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞.\n\n"
        "–û—Ç–≤–µ—Ç: *Agree* / *Disagree*"
    ),
    "uk": (
        "–¶–µ —â–æ–¥–µ–Ω–Ω–∏–∫-–∞—Å–∏—Å—Ç–µ–Ω—Ç, –Ω–µ —Ç–µ—Ä–∞–ø—ñ—è —ñ –Ω–µ –º–µ–¥–∏—á–Ω–∞ –ø–æ—Å–ª—É–≥–∞.\n"
        "–ù–∞—Ç–∏—Å–∫–∞—é—á–∏ *Agree*, –≤–∏ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂—É—î—Ç–µ —Ä–æ–∑—É–º—ñ–Ω–Ω—è —ñ –ø—Ä–∏–π–º–∞—î—Ç–µ –ü–æ–ª—ñ—Ç–∏–∫—É.\n"
        "–ö–æ–º–∞–Ω–¥–∏: /journal ‚Äî –∑–∞–ø–∏—Å, /remind ‚Äî –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è, /stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞.\n\n"
        "–í—ñ–¥–ø–æ–≤—ñ–¥—å: *Agree* / *Disagree*"
    ),
    "en": (
        "This is a journal assistant, not therapy or a medical service.\n"
        "By pressing *Agree* you confirm understanding and accept the Policy.\n"
        "Commands: /journal ‚Äî entry, /remind ‚Äî reminder, /stats ‚Äî stats.\n\n"
        "Reply: *Agree* / *Disagree*"
    ),
}
OK_TXT = {"ru": "–°–ø–∞—Å–∏–±–æ! –ü–æ–ª–∏—Ç–∏–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞ ‚úÖ", "uk": "–î—è–∫—É—é! –ü–æ–ª—ñ—Ç–∏–∫–∞ –ø—Ä–∏–π–Ω—è—Ç–∞ ‚úÖ", "en": "Thanks! Policy accepted ‚úÖ"}
NO_TXT = {"ru": "–ü—Ä–∏–Ω—è—Ç–∏–µ –ø–æ–ª–∏—Ç–∏–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.", "uk": "–ü—Ä–∏–π–Ω—è—Ç—Ç—è –ø–æ–ª—ñ—Ç–∏–∫–∏ —Å–∫–∞—Å–æ–≤–∞–Ω–æ.", "en": "Policy not accepted."}

SUPPORTED = {"ru", "uk", "en"}

def _norm_lang(code: str | None) -> str:
    l = (code or "ru")[:2].lower()
    return "uk" if l == "ua" else (l if l in SUPPORTED else "ru")

async def _ensure_cols(session: AsyncSession) -> None:
    # –º—è–≥–∫–∏–µ ALTER'—ã
    try:
        await session.execute(sql_text("ALTER TABLE users ADD COLUMN policy_accepted INTEGER DEFAULT 0"))
    except Exception:
        pass
    try:
        await session.commit()
    except Exception:
        await session.rollback()

async def _fetch_user_lang(session: AsyncSession, tg_id: int) -> str:
    await _ensure_cols(session)
    row = (await session.execute(sql_text("SELECT lang FROM users WHERE tg_id=:tg"), {"tg": tg_id})).first()
    if row and row[0]:
        return _norm_lang(row[0])
    # –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—â—ë –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞–¥–∏–º
    await session.execute(sql_text("INSERT OR IGNORE INTO users(tg_id, lang) VALUES (:tg, :lang)"),
                          {"tg": tg_id, "lang": "ru"})
    await session.commit()
    return "ru"

def _policy_kb() -> InlineKeyboardMarkup:
    # –∫–Ω–æ–ø–∫–∏ –Ω–∞–º–µ—Ä–µ–Ω–Ω–æ –Ω–∞ –∞–Ω–≥–ª. –∫–∞–∫ –≤ —Ç–≤–æ–∏—Ö —Å–∫—Ä–∏–Ω–∞—Ö
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Agree", callback_data="privacy:agree"),
         InlineKeyboardButton(text="Disagree", callback_data="privacy:disagree")]
    ])

# ---- handlers ----

@router.message(Command("privacy"))
@router.message(F.text.func(is_privacy_btn))
async def privacy_show(m: Message, session: AsyncSession):
    lang = await _fetch_user_lang(session, m.from_user.id)
    await m.answer(POLICY_TXT.get(lang, POLICY_TXT["ru"]), reply_markup=_policy_kb(), parse_mode="Markdown")

@router.callback_query(F.data == "privacy:agree")
async def privacy_agree(c: CallbackQuery, session: AsyncSession):
    await _ensure_cols(session)
    try:
        await session.execute(sql_text("UPDATE users SET policy_accepted=1 WHERE tg_id=:tg"),
                              {"tg": c.from_user.id})
        await session.commit()
    except Exception:
        log.exception("policy_accepted update failed")
    lang = await _fetch_user_lang(session, c.from_user.id)
    await c.message.answer(OK_TXT.get(lang, OK_TXT["ru"]), reply_markup=get_main_kb(lang))
    with contextlib.suppress(Exception):
        await c.answer()

@router.callback_query(F.data == "privacy:disagree")
async def privacy_disagree(c: CallbackQuery, session: AsyncSession):
    await _ensure_cols(session)
    try:
        await session.execute(sql_text("UPDATE users SET policy_accepted=0 WHERE tg_id=:tg"),
                              {"tg": c.from_user.id})
        await session.commit()
    except Exception:
        log.exception("policy_accepted reset failed")
    lang = await _fetch_user_lang(session, c.from_user.id)
    await c.message.answer(NO_TXT.get(lang, NO_TXT["en"]), reply_markup=get_main_kb(lang))
    with contextlib.suppress(Exception):
        await c.answer()

# –ª–æ–∫–∞–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç –¥–ª—è contextlib (—á—Ç–æ–±—ã –Ω–µ —Ç—è–Ω—É—Ç—å –µ–≥–æ –Ω–∞–≤–µ—Ä—Ö, –µ—Å–ª–∏ –Ω–µ –Ω—É–∂–µ–Ω)
import contextlib  # noqa: E402
==========================================================================================
# app/handlers/reminders.py
==========================================================================================
# app/handlers/remind.py
from __future__ import annotations

from datetime import datetime, timezone
from zoneinfo import ZoneInfo

from aiogram import Router, F
from aiogram.filters import StateFilter, Command
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, and_

from app.models.user import User
from app.models.reminder import Reminder
from app.services.nlp import parse_any
from app.services.reminders import (
    compute_next_run,
    to_local,
    to_utc,
    now_utc as now_utc_fn,  # –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ–º –∏–º–µ–Ω–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
)
from app.handlers.premium import maybe_grant_trial

router = Router()

SUPPORTED = {"ru", "uk", "en"}


def _tr(lang: str | None, ru: str, uk: str, en: str) -> str:
    l = (lang or "ru").lower()[:2]
    if l == "uk":
        return uk
    if l == "en":
        return en
    return ru


async def _get_lang(session: AsyncSession, m: Message, fallback: str | None = None) -> str:
    """–ë–µ—Ä—ë–º —è–∑—ã–∫ –∏–∑ –ë–î (users.lang) -> –∏–∑ Telegram -> fallback -> ru."""
    tg = getattr(getattr(m, "from_user", None), "id", None)
    code = getattr(getattr(m, "from_user", None), "language_code", None)
    db_lang = None
    if tg:
        try:
            res = await session.execute(select(User.lang).where(User.tg_id == tg))
            db_lang = res.scalar_one_or_none()
        except Exception:
            db_lang = None
    l = (db_lang or code or fallback or "ru")[:2].lower()
    return l if l in SUPPORTED else "ru"


def _fmt_local(dt_utc: datetime, tz_name: str) -> str:
    return to_local(dt_utc, tz_name).strftime("%Y-%m-%d %H:%M")


# ----- HELP -----
@router.message(Command("remind"))
async def remind_help(m: Message, session: AsyncSession, lang: str | None = None):
    l = lang or await _get_lang(session, m)
    await m.answer(
        _tr(
            l,
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "‚Ä¢ ¬´–Ω–∞–ø–æ–º–Ω–∏ –≤–æ–¥—É –≤ 12:00¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–ø–æ–º–Ω–∏ –ø–æ–∑–≤–æ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç –ø–æ –±—É–¥–Ω—è–º –≤ 10:00¬ª\n"
            "‚Ä¢ ¬´–≤—ã–∫–ª—é—á–∏ –≤—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è¬ª / ¬´–≤–∫–ª—é—á–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤–æ–¥–∞¬ª",
            "–ü—Ä–∏–∫–ª–∞–¥–∏:\n"
            "‚Ä¢ ¬´–Ω–∞–≥–∞–¥–∞–π –≤–æ–¥—É –æ 12:00¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–≥–∞–¥–∞–π –ø–æ–¥–∑–≤–æ–Ω–∏—Ç–∏ —á–µ—Ä–µ–∑ 15 —Ö–≤–∏–ª–∏–Ω¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–≥–∞–¥–∞–π –∑–≤—ñ—Ç –ø–æ –±—É–¥–Ω—è—Ö –æ 10:00¬ª\n"
            "‚Ä¢ ¬´–≤–∏–º–∫–Ω–∏ –≤—Å—ñ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è¬ª / ¬´—É–≤—ñ–º–∫–Ω–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –≤–æ–¥–∞¬ª",
            "Examples:\n"
            "‚Ä¢ ‚Äúremind water at 12:00‚Äù\n"
            "‚Ä¢ ‚Äúremind to call in 15 minutes‚Äù\n"
            "‚Ä¢ ‚Äúremind report weekdays at 10:00‚Äù\n"
            "‚Ä¢ ‚Äúdisable all reminders‚Äù / ‚Äúenable reminders water‚Äù",
        ),
        parse_mode=None,
    )


# ----- TRIGGERS -----
_TRIGGER_WORDS: tuple[str, ...] = (
    "–Ω–∞–ø–æ–º–Ω–∏",
    "–Ω–∞–≥–∞–¥–∞–π",
    "remind",
    "–≤–∫–ª—é—á–∏",
    "–≤–∫–ª",
    "—É–≤—ñ–º–∫–Ω–∏",
    "enable",
    "on",
    "–≤—ã–∫–ª—é—á–∏",
    "–≤—ã–∫–ª",
    "–≤—ñ–¥–∫–ª—é—á–∏",
    "–≤–∏–º–∫–Ω–∏",
    "disable",
    "off",
)


def _has_trigger(s: str | None) -> bool:
    return bool(s) and any(w in s.lower() for w in _TRIGGER_WORDS)


@router.message(F.text.func(_has_trigger))
async def remind_parse(m: Message, session: AsyncSession, lang: str | None = None):
    # 1) –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å + —Å–æ–≥–ª–∞—Å–∏–µ
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()

    l = lang or await _get_lang(session, m)

    if not user or not user.consent_accepted_at:
        return await m.answer(
            _tr(
                l,
                "–ù—É–∂–Ω–æ –ø—Ä–∏–Ω—è—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É: –Ω–∞–∂–º–∏ üîí Privacy",
                "–ü–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫—É: –Ω–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
                "You need to accept the policy: tap üîí Privacy",
            ),
            parse_mode=None,
        )

    tz_name = user.tz or "Europe/Kyiv"
    now_utc = now_utc_fn()  # UTC –º–æ–º–µ–Ω—Ç
    now_local = now_utc.astimezone(ZoneInfo(tz_name))  # –ª–æ–∫–∞–ª—å–Ω—ã–π ¬´—Å–µ–π—á–∞—Å¬ª –¥–ª—è –ø–∞—Ä—Å–µ—Ä–∞

    # 2) –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥: create / enable / disable
    parsed = parse_any(m.text, user_tz=tz_name, now=now_local)
    if not parsed:
        return await m.answer(
            _tr(
                l,
                "–ù–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –ù–∞–ø–∏—à–∏: ¬´–Ω–∞–ø–æ–º–Ω–∏ <—á—Ç–æ> –≤/—á–µ—Ä–µ–∑ <–∫–æ–≥–¥–∞>¬ª –∏–ª–∏ ¬´–≤–∫–ª—é—á–∏/–≤—ã–∫–ª—é—á–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è [–ø—Ä–æ <—á—Ç–æ>]¬ª.",
                "–ù–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤ –∫–æ–º–∞–Ω–¥—É. –ù–∞–ø–∏—à–∏: ¬´–Ω–∞–≥–∞–¥–∞–π <—â–æ> –æ/—á–µ—Ä–µ–∑ <–∫–æ–ª–∏>¬ª –∞–±–æ ¬´—É–≤—ñ–º–∫–Ω–∏/–≤–∏–º–∫–Ω–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è [–ø—Ä–æ <—â–æ>]¬ª.",
                "Didn't understand. Use ‚Äúremind <what> at/in <when>‚Äù or ‚Äúenable/disable reminders [about <what>]‚Äù.",
            ),
            parse_mode=None,
        )

    # === ENABLE / DISABLE ===
    if parsed.intent in ("enable", "disable"):
        action_enable = parsed.intent == "enable"
        q = (parsed.toggle.query or "").strip() if getattr(parsed, "toggle", None) else ""
        is_all = bool(getattr(parsed, "toggle", None) and parsed.toggle.all)

        filters = [Reminder.user_id == user.id]
        if not is_all and q:
            cond = getattr(Reminder.title, "ilike", None)
            filters.append(cond(f"%{q}%") if cond else Reminder.title.like(f"%{q}%"))

        to_update = (
            await session.execute(select(Reminder).where(and_(*filters)))
        ).scalars().all()

        if not to_update:
            return await m.answer(
                _tr(l, "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à—ë–ª –ø–æ –∑–∞–ø—Ä–æ—Å—É.", "–ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π—à–æ–≤ –∑–∞ –∑–∞–ø–∏—Ç–æ–º.", "Found nothing to update."),
                parse_mode=None,
            )

        await session.execute(update(Reminder).where(and_(*filters)).values(is_active=action_enable))

        if action_enable:
            changed = 0
            for r in to_update:
                if r.cron and (r.next_run is None or r.next_run <= now_utc):
                    nxt = compute_next_run(r.cron, now_utc, tz_name)
                    if nxt:
                        r.next_run = nxt
                        session.add(r)
                        changed += 1
            await session.commit()
        else:
            await session.commit()

        cnt = len(to_update)
        return await m.answer(
            _tr(
                l,
                f"{'–í–∫–ª—é—á–∏–ª' if action_enable else '–í—ã–∫–ª—é—á–∏–ª'} {cnt} –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.",
                f"{'–£–≤—ñ–º–∫–Ω—É–≤' if action_enable else '–í–∏–º–∫–Ω—É–≤'} {cnt} –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å.",
                f"{'Enabled' if action_enable else 'Disabled'} {cnt} reminder(s).",
            )
        )

    # === CREATE ===
    pr = parsed.reminder
    if not pr:
        return await m.answer(
            _tr(l, "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.", "–ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑—ñ–±—Ä–∞—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è.", "Couldn't parse the reminder."),
            parse_mode=None,
        )

    next_run_utc: datetime | None = None
    cron: str | None = None

    if pr.cron:
        cron = pr.cron
        next_run_utc = compute_next_run(cron, now_utc, tz_name)
        if not next_run_utc:
            return await m.answer(
                _tr(
                    l,
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã—á–∏—Å–ª–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ü—Ä–∏–º–µ—Ä: ¬´–∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 09:00¬ª, ¬´–ø–æ –±—É–¥–Ω—è–º –≤ 10:00¬ª.",
                    "–ù–µ –≤–¥–∞–ª–æ—Å—è –æ–±—á–∏—Å–ª–∏—Ç–∏ —Ä–æ–∑–∫–ª–∞–¥. –ü—Ä–∏–∫–ª–∞–¥: ¬´—â–æ–¥–Ω—è –æ 09:00¬ª, ¬´–ø–æ –±—É–¥–Ω—è—Ö –æ 10:00¬ª.",
                    "Couldn't compute schedule. E.g., ‚Äúdaily at 09:00‚Äù, ‚Äúweekdays at 10:00‚Äù.",
                ),
                parse_mode=None,
            )
    else:
        dt = getattr(pr, "next_run_utc", None)
        if not isinstance(dt, datetime):
            return await m.answer(
                _tr(
                    l,
                    "–ù–µ –ø–æ–Ω—è–ª –≤—Ä–µ–º—è. –ü—Ä–∏–º–µ—Ä—ã: ¬´–≤ 12:30¬ª, ¬´–∑–∞–≤—Ç—Ä–∞ –≤ 9¬ª, ¬´—á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç¬ª.",
                    "–ù–µ –∑—Ä–æ–∑—É–º—ñ–≤ —á–∞—Å. –ü—Ä–∏–∫–ª–∞–¥–∏: ¬´–æ 12:30¬ª, ¬´–∑–∞–≤—Ç—Ä–∞ –æ 9¬ª, ¬´—á–µ—Ä–µ–∑ 15 —Ö–≤–∏–ª–∏–Ω¬ª.",
                    "Couldn't recognise time. Examples: ‚Äúat 12:30‚Äù, ‚Äútomorrow 9‚Äù, ‚Äúin 15 minutes‚Äù.",
                ),
                parse_mode=None,
            )
        next_run_utc = to_utc(dt, tz_name)

    # –î–µ–¥—É–ø: –∞–∫—Ç–∏–≤–Ω–æ–µ —Å —Ç–µ–º –∂–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º –∏ —Ç–∞–∫–∏–º –∂–µ —Ç–∏–ø–æ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
    dup = (
        await session.execute(
            select(Reminder).where(
                and_(
                    Reminder.user_id == user.id,
                    Reminder.is_active.is_(True),
                    Reminder.title == pr.what,
                    (Reminder.cron == cron) if cron else (Reminder.cron.is_(None)),
                )
            )
        )
    ).scalar_one_or_none()

    if dup:
        dup.next_run = next_run_utc
        session.add(dup)
        await session.commit()
        local_str = _fmt_local(next_run_utc, tz_name)
        return await m.answer(
            _tr(
                l,
                f"–û–±–Ω–æ–≤–∏–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: ¬´{pr.what}¬ª. –ë–ª–∏–∂–∞–π—à–µ–µ: {local_str} ({tz_name}).",
                f"–û–Ω–æ–≤–∏–≤ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è: ¬´{pr.what}¬ª. –ù–∞–π–±–ª–∏–∂—á–µ: {local_str} ({tz_name}).",
                f"Updated reminder: ‚Äú{pr.what}‚Äù. Next: {local_str} ({tz_name}).",
            )
        )

    r = Reminder(user_id=user.id, title=pr.what, cron=cron, next_run=next_run_utc, is_active=True)
    session.add(r)
    await session.commit()

    # –¢—Ä–∏–∞–ª –∑–∞ –ª—é–±–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ –∏–Ω–∞—á–µ ‚Äî –ø–æ–º–µ–Ω—è–µ–º –ø—Ä–∞–≤–∏–ª–æ)
    try:
        await maybe_grant_trial(session, user.tg_id)
    except Exception:
        pass

    local_str = _fmt_local(next_run_utc, tz_name)
    if cron:
        return await m.answer(
            _tr(
                l,
                f"–ì–æ—Ç–æ–≤–æ! –ë—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å: ¬´{pr.what}¬ª. –ü–µ—Ä–≤—ã–π —Ä–∞–∑: {local_str} ({tz_name}).",
                f"–ì–æ—Ç–æ–≤–æ! –ù–∞–≥–∞–¥—É–≤–∞—Ç–∏–º—É: ¬´{pr.what}¬ª. –ü–µ—Ä—à–∏–π —Ä–∞–∑: {local_str} ({tz_name}).",
                f"Done! I‚Äôll remind: ‚Äú{pr.what}‚Äù. First run: {local_str} ({tz_name}).",
            )
        )
    else:
        return await m.answer(
            _tr(
                l,
                f"–ì–æ—Ç–æ–≤–æ! –ù–∞–ø–æ–º–Ω—é: {pr.what} –≤ {local_str} ({tz_name}).",
                f"–ì–æ—Ç–æ–≤–æ! –ù–∞–≥–∞–¥–∞—é: {pr.what} –æ {local_str} ({tz_name}).",
                f"Done! I‚Äôll remind: {pr.what} at {local_str} ({tz_name}).",
            )
        )


# ----- LIST -----
@router.message(Command("reminders"))
async def reminders_list(m: Message, session: AsyncSession, lang: str | None = None):
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    l = lang or await _get_lang(session, m)
    if not user:
        return await m.answer(_tr(l, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"), parse_mode=None)

    tz_name = user.tz or "Europe/Kyiv"
    now_utc = now_utc_fn()

    rows = (await session.execute(select(Reminder).where(Reminder.user_id == user.id))).scalars().all()
    if not rows:
        return await m.answer(
            _tr(
                l,
                "–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π. –ü—Ä–∏–º–µ—Ä: ¬´–Ω–∞–ø–æ–º–Ω–∏ –≤–æ–¥—É –≤ 12:00¬ª.",
                "–ü–æ–∫–∏ –Ω–µ–º–∞—î –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å. –ü—Ä–∏–∫–ª–∞–¥: ¬´–Ω–∞–≥–∞–¥–∞–π –≤–æ–¥—É –æ 12:00¬ª.",
                "No reminders yet. Example: ‚Äúremind water at 12:00‚Äù.",
            ),
            parse_mode=None,
        )

    # –ê–∫—Ç–∏–≤–Ω—ã–µ –≤–≤–µ—Ä—Ö, –∑–∞—Ç–µ–º –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è; None –≤ –∫–æ–Ω–µ—Ü
    rows.sort(key=lambda r: (0 if r.is_active else 1, r.next_run.timestamp() if r.next_run else float("inf")))

    lines: list[str] = []
    for r in rows[:10]:
        status = "‚úÖ" if r.is_active else "‚è∏Ô∏è"
        when = "-"
        if r.next_run:
            when = _fmt_local(r.next_run, tz_name)
            if r.next_run <= now_utc:
                when += " ‚ö†Ô∏è"
        elif r.cron and r.is_active:
            nxt = compute_next_run(r.cron, now_utc, tz_name)
            when = _fmt_local(nxt, tz_name) if nxt else "-"
        lines.append(f"{status} {r.title} ‚Äî {when}")

    await m.answer("\n".join(lines), parse_mode=None)
==========================================================================================
# app/handlers/report.py
==========================================================================================
# app/handlers/report.py
from aiogram import Router, F
from aiogram.filters import StateFilter, Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, ForceReply
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.bug_report import BugReport
from app.models.user import User
from app.keyboards import get_main_kb
from app.config import settings

router = Router()

class ReportFSM(StatesGroup):
    waiting_text = State()

TEXTS = {
    "ru": {
        "ask": (
            "–û–ø–∏—à–∏, —á—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç/—á—Ç–æ —É–ª—É—á—à–∏—Ç—å. –ú–æ–∂–Ω–æ –ø—Ä–∏–ª–æ–∂–∏—Ç—å —Å–∫—Ä–∏–Ω/—Ñ–∞–π–ª.\n"
            "–û—Ç–ø—Ä–∞–≤—å —Å–æ–æ–±—â–µ–Ω–∏–µ–º –Ω–∏–∂–µ üëá"
        ),
        "saved": "–°–ø–∞—Å–∏–±–æ! –†–µ–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –ú—ã –ø–æ—Å–º–æ—Ç—Ä–∏–º –∏ –æ—Ç–≤–µ—Ç–∏–º.",
        "start_first": "–ù–∞–∂–º–∏ /start ‚Äî –∏ –ø–æ–≤—Ç–æ—Ä–∏ —Ä–µ–ø–æ—Ä—Ç.",
        "empty": "–ù—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å –ø–∞—Ä—É —Å–ª–æ–≤ –∫ —Ä–µ–ø–æ—Ä—Ç—É. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ üëá",
    },
    "uk": {
        "ask": (
            "–û–ø–∏—à—ñ—Ç—å, —â–æ –Ω–µ –ø—Ä–∞—Ü—é—î/—â–æ –ø–æ–∫—Ä–∞—â–∏—Ç–∏. –ú–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ —Å–∫—Ä—ñ–Ω/—Ñ–∞–π–ª.\n"
            "–ù–∞–¥—ñ—à–ª—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–∏–∂—á–µ üëá"
        ),
        "saved": "–î—è–∫—É—î–º–æ! –†–µ–ø–æ—Ä—Ç –∑–±–µ—Ä–µ–∂–µ–Ω–æ. –ü–µ—Ä–µ–≥–ª—è–Ω–µ–º–æ —ñ –≤—ñ–¥–ø–æ–≤—ñ–º–æ.",
        "start_first": "–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å /start ‚Äî —ñ –ø–æ–≤—Ç–æ—Ä—ñ—Ç—å —Ä–µ–ø–æ—Ä—Ç.",
        "empty": "–ü–æ—Ç—Ä—ñ–±–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç–∏ –∫—ñ–ª—å–∫–∞ —Å–ª—ñ–≤ –¥–æ —Ä–µ–ø–æ—Ä—Ç—É. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ üëá",
    },
    "en": {
        "ask": (
            "Describe what‚Äôs broken / what to improve. You may attach a screenshot/file.\n"
            "Send your message below üëá"
        ),
        "saved": "Thanks! Bug report saved. We‚Äôll review and reply.",
        "start_first": "Please press /start and send the report again.",
        "empty": "Please add a few words to the report. Try again üëá",
    },
}

def _t(lang: str, key: str) -> str:
    return TEXTS.get(lang, TEXTS["ru"]).get(key, key)

# ---- –¢—Ä–∏–≥–≥–µ—Ä—ã –æ—Ç–∫—Ä—ã—Ç–∏—è —Ñ–æ—Ä–º—ã —Ä–µ–ø–æ—Ä—Ç–∞ ----
# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º: /report, /bug, –∏ —Ç–µ–∫—Å—Ç—ã –∫–Ω–æ–ø–æ–∫ RU/UK/EN —Å/–±–µ–∑ –≤–∞—Ä–∏–∞—Ü–∏–∏ —ç–º–æ–¥–∑–∏ (FE0F)
report_triggers = (
    F.text.regexp(r"(?i)^\s*/(report|bug)\s*$")
    | F.text.regexp(r"(?i)^\s*üõ†\ufe0f?\s*report\s*bug\s*$")
    | F.text.regexp(r"(?i)^\s*üõ†\ufe0f?\s*–ø–æ–≤—ñ–¥–æ–º–∏—Ç–∏\s*–ø—Ä–æ\s*–±–∞–≥\s*$")
    | F.text.regexp(r"^\s*üõ†\ufe0f?\s*Report bug\s*$")
    | F.text.regexp(r"^\s*üõ†\ufe0f?\s*–ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥\s*$")
)

@router.message(Command("report"))
@router.message(Command("bug"))
@router.message(report_triggers)
async def ask_report(m: Message, state: FSMContext, lang: str):
    await state.set_state(ReportFSM.waiting_text)
    await m.answer(_t(lang, "ask"), reply_markup=ForceReply(selective=True))

# ---- –ü—Ä–∏—ë–º —Ä–µ–ø–æ—Ä—Ç–∞: —Ç–µ–∫—Å—Ç –ò–õ–ò –≤–ª–æ–∂–µ–Ω–∏–µ (photo/document/video) ----
content_any = (F.text | F.caption | F.photo | F.document | F.video | F.animation | F.voice | F.audio)

@router.message(ReportFSM.waiting_text, content_any)
async def save_report(m: Message, state: FSMContext, session: AsyncSession, lang: str):
    # –ù–∞–π—Ç–∏ user.id –ø–æ tg_id ‚Äî FK –≤ BugReport
    res = await session.execute(select(User.id).where(User.tg_id == m.from_user.id))
    user_id = res.scalar_one_or_none()
    if not user_id:
        await state.clear()
        return await m.answer(_t(lang, "start_first"), reply_markup=get_main_kb(lang))

    # –¢–µ–∫—Å—Ç –±–µ—Ä—ë–º –∏–∑ text –∏–ª–∏ caption
    text = (m.text or m.caption or "").strip()
    if not text:
        # –µ—Å–ª–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ —á–∏—Å—Ç–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ –±–µ–∑ –ø–æ–¥–ø–∏—Å–∏ ‚Äî –º—è–≥–∫–æ –ø–æ–ø—Ä–æ—Å–∏–º –¥–æ–±–∞–≤–∏—Ç—å –ø–∞—Ä—É —Å–ª–æ–≤
        return await m.answer(_t(lang, "empty"), reply_markup=ForceReply(selective=True))

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î (—Ö—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—É—é —á–∞—Å—Ç—å)
    br = BugReport(user_id=user_id, text=text)
    session.add(br)
    await session.commit()

    # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ ‚Äî —É–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–∞ –∏ –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª —Å –≤–ª–æ–∂–µ–Ω–∏—è–º–∏
    admin_id = None
    try:
        admin_id = int(settings.bot_admin_tg_id) if settings.bot_admin_tg_id else None
    except Exception:
        admin_id = None

    if admin_id:
        uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else str(m.from_user.id)
        preview = (text[:800] + "‚Ä¶") if len(text) > 800 else text

        # 1) –ö–æ—Ä–æ—Ç–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        try:
            await m.bot.send_message(
                admin_id,
                f"üêû Bug report from {uname}\n\n{preview}"
            )
        except Exception:
            pass

        # 2) –ö–æ–ø–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ –≤—Å–µ–º–∏ –≤–ª–æ–∂–µ–Ω–∏—è–º–∏ (–µ—Å–ª–∏ –±—ã–ª–∏)
        try:
            await m.bot.copy_message(
                chat_id=admin_id,
                from_chat_id=m.chat.id,
                message_id=m.message_id
            )
        except Exception:
            # –æ–∫, –±–µ–∑ –ø–∞–Ω–∏–∫–∏ ‚Äî –∏–Ω–æ–≥–¥–∞ –Ω–µ–ª—å–∑—è —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å (–∫–∞–Ω–∞–ª—ã/–ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏)
            pass

    await state.clear()
    await m.answer(_t(lang, "saved"), reply_markup=get_main_kb(lang))

# –ù–µ–±–æ–ª—å—à–æ–π UX: –µ—Å–ª–∏ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ ¬´/cancel¬ª
@router.message(ReportFSM.waiting_text, Command("cancel"))
async def cancel_report(m: Message, state: FSMContext, lang: str):
    await state.clear()
    await m.answer(get_main_kb(lang).input_field_placeholder or "–û–∫, –æ—Ç–º–µ–Ω–∏–ª.", reply_markup=get_main_kb(lang))
==========================================================================================
# app/handlers/start.py
==========================================================================================
# app/handlers/start.py
from __future__ import annotations

import re
from zoneinfo import ZoneInfo

from aiogram import Router
from aiogram.filters import StateFilter, CommandStart
from aiogram.types import Message
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.keyboards import get_main_kb
from app.config import settings

router = Router()

_TEXTS = {
    "ru": {
        "hello_need_privacy": (
            "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –¥–Ω–µ–≤–Ω–∏–∫-–ø–æ–º–æ—â–Ω–∏–∫.\n"
            "–ù–∞–∂–º–∏ <b>üîí –ü–æ–ª–∏—Ç–∏–∫–∞</b>, —á—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å —É—Å–ª–æ–≤–∏—è –∏ –Ω–∞—á–∞—Ç—å.\n"
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
        "hello_ready": (
            "–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å –∑–∞–ø–∏—Å—å –∫–æ–º–∞–Ω–¥–æ–π /journal.\n"
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
    },
    "uk": {
        "hello_need_privacy": (
            "–ü—Ä–∏–≤—ñ—Ç! –¶–µ —â–æ–¥–µ–Ω–Ω–∏–∫-–ø–æ–º—ñ—á–Ω–∏–∫.\n"
            "–ù–∞—Ç–∏—Å–Ω–∏ <b>üîí –ü–æ–ª—ñ—Ç–∏–∫–∞</b>, —â–æ–± –ø—Ä–∏–π–Ω—è—Ç–∏ —É–º–æ–≤–∏ —ñ –ø–æ—á–∞—Ç–∏.\n"
            "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
        "hello_ready": (
            "–ó –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è–º! –ú–æ–∂–µ—à –ø–∏—Å–∞—Ç–∏ –∑–∞–ø–∏—Å –∫–æ–º–∞–Ω–¥–æ—é /journal.\n"
            "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
    },
    "en": {
        "hello_need_privacy": (
            "Hi! This is a journal assistant.\n"
            "Press <b>üîí Privacy</b> to accept the policy and start.\n"
            "Main menu is below."
        ),
        "hello_ready": (
            "Welcome back! You can write an entry with /journal.\n"
            "Main menu is below."
        ),
    },
}

_SUPPORTED = {"ru", "uk", "en"}

def _norm_locale(x: str | None) -> str:
    s = (x or "").split("-")[0].lower()
    if s == "ua":
        s = "uk"
    return s if s in _SUPPORTED else "ru"

def _is_valid_tz(tz: str | None) -> bool:
    if not tz:
        return False
    try:
        ZoneInfo(tz)
        return True
    except Exception:
        return False

def _parse_start_payload(text: str | None) -> tuple[str | None, str | None]:
    """Deep-link: /start lang=uk tz=Europe/Kyiv -> (lang, tz)"""
    if not text:
        return None, None
    parts = text.split(maxsplit=1)
    payload = parts[1] if len(parts) > 1 else ""
    if not payload:
        return None, None
    m_lang = re.search(r"(?:^|\s)lang=(ru|uk|en|ua)\b", payload, re.I)
    m_tz   = re.search(r"(?:^|\s)tz=([\w/\-+]+)", payload, re.I)
    lang = _norm_locale(m_lang.group(1)) if m_lang else None
    tz   = m_tz.group(1) if m_tz else None
    return lang, tz

def _pick_locale(user: User | None) -> str:
    return _norm_locale((getattr(user, "locale", None)) or settings.default_locale or "ru")

@router.message(CommandStart())
async def cmd_start(m: Message, session: AsyncSession):
    # upsert –ø–æ tg_id
    user = (await session.execute(
        select(User).where(User.tg_id == m.from_user.id)
    )).scalar_one_or_none()

    # –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é/deeplink
    lang_dl, tz_dl = _parse_start_payload(m.text or "")
    lang_tele = _norm_locale(getattr(m.from_user, "language_code", None))
    lang_default = _norm_locale(settings.default_locale or "ru")
    tz_default = settings.default_tz or "Europe/Kyiv"

    if not user:
        loc = lang_dl or lang_tele or lang_default
        tz  = tz_dl if _is_valid_tz(tz_dl) else tz_default
        user = User(tg_id=m.from_user.id, locale=loc, lang=loc, tz=tz)
        session.add(user)
        await session.flush()
    else:
        changed = False
        if lang_dl and user.locale != lang_dl:
            user.locale = lang_dl
            user.lang = lang_dl  # –¥–µ—Ä–∂–∏–º –≤ —Å–∏–Ω–∫–µ
            changed = True
        if tz_dl and _is_valid_tz(tz_dl) and user.tz != tz_dl:
            user.tz = tz_dl
            changed = True
        if changed:
            session.add(user)

    # —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ë–î –¥–æ –æ—Ç–≤–µ—Ç–∞
    await session.commit()

    loc = _pick_locale(user)
    kb = get_main_kb(loc) or None
    txt_key = "hello_ready" if getattr(user, "consent_accepted_at", None) else "hello_need_privacy"
    txts = _TEXTS.get(loc) or _TEXTS["ru"]
    await m.answer(txts.get(txt_key, _TEXTS["ru"]["hello_need_privacy"]), reply_markup=kb)
==========================================================================================
# app/hooks.py
==========================================================================================

import os, pkgutil, importlib, inspect
try:
    from fastapi import FastAPI, APIRouter
    from fastapi.responses import HTMLResponse, PlainTextResponse
    from starlette.applications import Starlette
except Exception:
    FastAPI = object
    Starlette = object

def _register(app):
    try:
        r = APIRouter()
        @r.get("/pay", response_class=HTMLResponse)
        async def pay(tg_id: str | None = None):
            p = os.path.join(os.path.dirname(__file__), "templates", "pay.html")
            return HTMLResponse(open(p, "r", encoding="utf-8").read())
        @r.get("/pay-mono")
        async def pay_mono(tg_id: str | None = None):
            return PlainTextResponse("MonoPay stub OK", status_code=200)
        @r.get("/pay-crypto")
        async def pay_crypto(tg_id: str | None = None):
            return PlainTextResponse("Crypto stub OK", status_code=200)
        existing = {getattr(rt, "path", "") for rt in getattr(app, "routes", []) or getattr(app.router, "routes", [])}
        need = {"/pay","/pay-mono","/pay-crypto"}
        if not need.issubset(existing):
            app.include_router(r)
    except Exception:
        pass

def _scan_and_patch():
    try:
        import app as _app_pkg
    except Exception:
        return
    for m in pkgutil.walk_packages(_app_pkg.__path__, "app."):
        try:
            mod = importlib.import_module(m.name)
        except Exception:
            continue
        for _, obj in inspect.getmembers(mod):
            if isinstance(obj, (FastAPI, Starlette)):
                _register(obj)

_scan_and_patch()

==========================================================================================
# app/http.py
==========================================================================================

from fastapi import FastAPI, Query, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse, PlainTextResponse
from pathlib import Path
import os, httpx

app = FastAPI(title="Diary HTTP")

def _load_env_chain():
    candidates = [
        "scripts/dev.env", "dev.env", ".env", ".env.local",
        "config/dev.env", "config/.env", "env", "local.env"
    ]
    for rel in candidates:
        p = Path(rel)
        if not p.exists():
            continue
        for line in p.read_text(encoding="utf-8").splitlines():
            s = line.strip()
            if not s or s.startswith("#") or "=" not in s:
                continue
            k, v = s.split("=", 1)
            k, v = k.strip(), v.strip().strip('"').strip("'")
            if k and k not in os.environ:
                os.environ[k] = v

_load_env_chain()

def _base():
    return os.getenv("PUBLIC_URL") or os.getenv("PUBLIC_BASE_URL") or ""

@app.get("/env-check")
async def env_check():
    keys = ["PUBLIC_URL","PUBLIC_BASE_URL","SUB_PRICE_UAH","SUB_PRICE_USD","NOWP_API_KEY","MONO_TOKEN"]
    return {k: bool(os.getenv(k)) for k in keys}

@app.get("/health")
async def health():
    return {"ok": True}

@app.get("/pay", response_class=HTMLResponse)
async def pay(tg_id: str = Query(...)):
    html = f"""<!doctype html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>–û–ø–ª–∞—Ç–∞</title>
<style>
body{{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;margin:0}}
.wrap{{max-width:740px;margin:32px auto;padding:0 16px}}
h1{{font-size:28px;margin:0 0 24px}}
a.btn{{display:block;width:100%;padding:18px 20px;border:0;border-radius:16px;font-size:20px;color:#fff;text-decoration:none;text-align:center;margin:14px 0}}
a.card{{background:#5b39f0}} a.crypto{{background:#14a37f}}
</style>
<div class="wrap">
  <h1>–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã</h1>
  <a class="btn card"   href="/pay-mono?tg_id={tg_id}">–ö–∞—Ä—Ç–æ–π (MonoPay, Apple/Google Pay)</a>
  <a class="btn crypto" href="/pay-crypto?tg_id={tg_id}">–ö—Ä–∏–ø—Ç–æ–π (USDT TRC20)</a>
</div>"""
    return HTMLResponse(html)

@app.get("/pay-crypto")
async def pay_crypto(tg_id: str = Query(...)):
    api_key = os.getenv("NOWP_API_KEY","")
    amount_usd = float(os.getenv("SUB_PRICE_USD", os.getenv("SUB_PRICE_USDT","10")))
    success = _base()+"/payments/success"
    cancel  = _base()+"/payments/cancel"
    if not api_key:
        return PlainTextResponse("NOWPayments API key missing", status_code=501)
    payload = {
        "price_amount": round(amount_usd, 2),
        "price_currency": "usd",
        "pay_currency": "usdttrc20",
        "order_id": f"tg_{tg_id}",
        "success_url": success,
        "cancel_url": cancel
    }
    async with httpx.AsyncClient(timeout=20) as cli:
        r = await cli.post("https://api.nowpayments.io/v1/invoice",
                           json=payload, headers={"x-api-key": api_key})
    data = r.json()
    if r.status_code != 200 or "invoice_url" not in data:
        raise HTTPException(502, detail=data)
    return RedirectResponse(data["invoice_url"], status_code=303)

@app.get("/pay-mono")
async def pay_mono(tg_id: str = Query(...)):
    token = os.getenv("MONO_TOKEN","")
    amount_uah = float(os.getenv("SUB_PRICE_UAH","99"))
    amount = int(round(amount_uah*100))
    success = _base()+"/payments/success"
    webhook = _base()+"/payments/mono-callback"
    if not token:
        return PlainTextResponse("Monobank merchant token missing", status_code=501)
    payload = {
        "amount": amount,
        "ccy": 980,
        "merchantPaymInfo": {"reference": f"tg_{tg_id}", "destination": "Diary Assistant Premium"},
        "redirectUrl": success,
        "webHookUrl": webhook
    }
    async with httpx.AsyncClient(timeout=20) as cli:
        r = await cli.post("https://api.monobank.ua/api/merchant/invoice/create",
                           headers={"X-Token": token, "Content-Type":"application/json"},
                           json=payload)
    data = r.json()
    if r.status_code != 200 or "pageUrl" not in data:
        raise HTTPException(502, detail=data)
    return RedirectResponse(data["pageUrl"], status_code=303)

@app.post("/payments/mono-callback")
async def mono_cb(body: dict):
    return {"ok": True}

@app.get("/payments/success", response_class=HTMLResponse)
async def ok():
    return "<h1>–û–ø–ª–∞—á–µ–Ω–æ ‚úÖ</h1>"

@app.get("/payments/cancel", response_class=HTMLResponse)
async def cancel():
    return "<h1>–ü–ª–∞—Ç—ë–∂ –æ—Ç–º–µ–Ω—ë–Ω</h1>"

==========================================================================================
# app/i18n.py
==========================================================================================
from __future__ import annotations
from typing import Any, Mapping

# —Å—Ç–∞—Ä—ã–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ –∏–∑ texts.py (–µ—Å–ª–∏ –µ—Å—Ç—å)
try:
    from app.texts import t as _txt_t      # type: ignore
except Exception:
    _txt_t = None

# –æ–≤–µ—Ä–ª–µ–π-—Å–ª–æ–≤–∞—Ä—å (–º–æ–∂–µ—Ç –∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å)
try:
    from app.texts import TRANSLATIONS as _TX  # type: ignore
except Exception:
    _TX = {}

SUPPORTED = {"ru","uk","en"}

def _norm(a: Any, b: Any|None):
    if b is None:
        x = str(a or "").strip().lower()
        if x in SUPPORTED:
            return x, x
        return str(a), "ru"
    a1, b1 = str(a or ""), str(b or "")
    a_loc = a1[:2].lower() in SUPPORTED
    b_loc = b1[:2].lower() in SUPPORTED
    if a_loc and not b_loc:
        return b1, a1[:2].lower()
    if b_loc and not a_loc:
        return a1, b1[:2].lower()
    return a1, (b1[:2].lower() if b1 else "ru")

def t(a: Any, b: Any|None=None, **kw) -> str:
    key, lang = _norm(a,b)
    if lang == "ua":
        lang = "uk"

    # 1) –ø—Ä–æ–±—É–µ–º –°–¢–ê–†–´–ô texts.t (–µ—Å–ª–∏ –µ—Å—Ç—å)
    if _txt_t:
        try:
            s = _txt_t(key, lang, **kw)  # —É –Ω–∏—Ö –ø–æ—Ä—è–¥–æ–∫: t(key, lang)
            if isinstance(s, str) and not (s.startswith('[') and s.endswith(']')) and s != key:
                return s
        except Exception:
            pass

    # 2) –ø—Ä–æ–±—É–µ–º –æ–≤–µ—Ä–ª–µ–π-—Å–ª–æ–≤–∞—Ä—å (premium –∏ –ø—Ä.)
    loc: Mapping[str,str] | None = _TX.get(key) if isinstance(_TX, dict) else None
    if isinstance(loc, Mapping):
        val = loc.get(lang) or loc.get("en") or loc.get("ru")
        if isinstance(val, str):
            try:
                return val.format(**kw) if kw else val
            except Exception:
                return val

    # 3) –Ω–∞–∑–≤–∞–Ω–∏—è —è–∑—ã–∫–æ–≤ –ø–æ –∫–ª—é—á–∞–º 'ru'/'uk'/'en'
    if key in SUPPORTED and key == lang:
        return {"ru":"–†—É—Å—Å–∫–∏–π","uk":"–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞","en":"English"}[lang]

    # 4) –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–ª–±—ç–∫
    return f"[{key}]"

==========================================================================================
# app/i18n/en.json
==========================================================================================
{
  "hello": "Hi!",
  "journal_prompt": "How are you? Jot 2‚Äì3 thoughts for today.",
  "privacy": "This is an assistant, not therapy. By accepting you acknowledge the policy."
}
==========================================================================================
# app/i18n/ru.json
==========================================================================================
{
  "hello": "–ü—Ä–∏–≤–µ—Ç!",
  "journal_prompt": "–ö–∞–∫ —Ç—ã? –ù–∞–ø–∏—à–∏ 2‚Äì3 –º—ã—Å–ª–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è.",
  "privacy": "–≠—Ç–æ –ø–æ–º–æ—â–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø–∏—è. –ü—Ä–∏–Ω–∏–º–∞—è —É—Å–ª–æ–≤–∏—è, –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ."
}
==========================================================================================
# app/i18n/uk.json
==========================================================================================
{
  "hello": "–ü—Ä–∏–≤—ñ—Ç!",
  "journal_prompt": "–Ø–∫ —Ç–∏? –ù–∞–ø–∏—à–∏ 2‚Äì3 –¥—É–º–∫–∏ –∑–∞ —Å—å–æ–≥–æ–¥–Ω—ñ.",
  "privacy": "–¶–µ –ø–æ–º—ñ—á–Ω–∏–∫, –∞ –Ω–µ —Ç–µ—Ä–∞–ø—ñ—è. –ü—Ä–∏–π–º–∞—é—á–∏ —É–º–æ–≤–∏, –≤–∏ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂—É—î—Ç–µ —Ä–æ–∑—É–º—ñ–Ω–Ω—è."
}
==========================================================================================
# app/keyboards.py
==========================================================================================
from __future__ import annotations
import re
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

_BAD_I18N = re.compile(r"^\[[a-z]{2}\]$")

def _t(lang: str, key: str, fallback: dict) -> str:
    try:
        from app.i18n import t as _real
        v = _real(lang, key)
        if isinstance(v, str) and v.strip() and not _BAD_I18N.match(v.strip().lower()):
            return v
    except Exception:
        pass
    lang = (lang or "ru")[:2].lower()
    if lang == "ua":
        lang = "uk"
    return fallback.get(lang, fallback.get("ru", key))

def get_main_kb(lang: str, is_premium: bool = False) -> ReplyKeyboardMarkup:
    rows = [
        [KeyboardButton(text=_t(lang,'menu_meditation', {'ru':'üßò –ú–µ–¥–∏—Ç–∞—Ü–∏—è','uk':'üßò –ú–µ–¥–∏—Ç–∞—Ü—ñ—è','en':'üßò Meditation'})),
         KeyboardButton(text=_t(lang,'menu_music',      {'ru':'üéµ –ú—É–∑—ã–∫–∞','uk':'üéµ –ú—É–∑–∏–∫–∞','en':'üéµ Music'}))],
        [KeyboardButton(text=_t(lang,'btn_premium',     {'ru':'üíé –ü—Ä–µ–º–∏—É–º','uk':'üíé –ü—Ä–µ–º—ñ—É–º','en':'üíé Premium'}))],
        [KeyboardButton(text=_t(lang,'btn_language',    {'ru':'üåê –Ø–∑—ã–∫','uk':'üåê –ú–æ–≤–∞','en':'üåê Language'}))],
        [KeyboardButton(text=_t(lang,'btn_privacy',     {'ru':'üîí –ü–æ–ª–∏—Ç–∏–∫–∞','uk':'üîí –ü–æ–ª—ñ—Ç–∏–∫–∞','en':'üîí Privacy'}))],
        [KeyboardButton(text=_t(lang,'btn_report_bug',  {'ru':'üõ† –°–æ–æ–±—â–∏—Ç—å –æ –±–∞–≥–µ','uk':'üõ† –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥','en':'üõ† Report a bug'}))],
    ]
    return ReplyKeyboardMarkup(resize_keyboard=True, keyboard=rows)

main_menu_kb = get_main_kb  # –∞–ª–∏–∞—Å –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –∏–º–ø–æ—Ä—Ç–æ–≤

def _norm(s: str) -> str:
    return " ".join((s or "").strip().lower().replace("—ë","–µ").split())

MEDITATION_TXT = {_norm(x) for x in {
    "üßò –º–µ–¥–∏—Ç–∞—Ü–∏—è","–º–µ–¥–∏—Ç–∞—Ü–∏—è","üßò –º–µ–¥–∏—Ç–∞—Ü—ñ—è","–º–µ–¥–∏—Ç–∞—Ü—ñ—è","üßò meditation","meditation"
}}
MUSIC_TXT = {_norm(x) for x in {
    "üéµ –º—É–∑—ã–∫–∞","–º—É–∑—ã–∫–∞","üéµ –º—É–∑–∏–∫–∞","–º—É–∑–∏–∫–∞","üéµ music","music"
}}
PREMIUM_TXT = {_norm(x) for x in {
    "üíé –ø—Ä–µ–º–∏—É–º","–ø—Ä–µ–º–∏—É–º","üíé –ø—Ä–µ–º—ñ—É–º","–ø—Ä–µ–º—ñ—É–º","üíé premium","premium"
}}
LANGUAGE_TXT = {_norm(x) for x in {
    "üåê —è–∑—ã–∫","—è–∑—ã–∫","üåê –º–æ–≤–∞","–º–æ–≤–∞","üåê language","language",
    "ru","uk","en","—Ä—É—Å—Å–∫–∏–π","—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞","english"
}}
PRIVACY_TXT = {_norm(x) for x in {
    "üîí –ø–æ–ª–∏—Ç–∏–∫–∞","–ø–æ–ª–∏—Ç–∏–∫–∞","üîí –ø–æ–ª—ñ—Ç–∏–∫–∞","–ø–æ–ª—ñ—Ç–∏–∫–∞","üîí privacy","privacy"
}}
REPORT_TXT = {_norm(x) for x in {
    "üõ† —Å–æ–æ–±—â–∏—Ç—å –æ –±–∞–≥–µ","—Å–æ–æ–±—â–∏—Ç—å –æ –±–∞–≥–µ","üõ† –ø–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥","–ø–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
    "üõ† report a bug","report a bug","report bug"
}}

def is_meditation_btn(text: str) -> bool: return _norm(text) in MEDITATION_TXT
def is_music_btn(text: str) -> bool:     return _norm(text) in MUSIC_TXT
def is_premium_btn(text: str) -> bool:   return _norm(text) in PREMIUM_TXT
def is_language_btn(text: str) -> bool:  return _norm(text) in LANGUAGE_TXT
def is_privacy_btn(text: str) -> bool:   return _norm(text) in PRIVACY_TXT
def is_report_bug_btn(text: str) -> bool:return _norm(text) in REPORT_TXT

PRIVACY_LABELS = {
    "ru": "üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
    "uk": "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
    "en": "üîí Privacy",
}

__all__ = [
    "get_main_kb", "main_menu_kb",
    "is_meditation_btn","is_music_btn","is_premium_btn",
    "is_language_btn","is_privacy_btn","is_report_bug_btn",
    "PRIVACY_LABELS",
]

==========================================================================================
# app/main.py
==========================================================================================
# app/main.py
from __future__ import annotations
import asyncio, logging, os, importlib, pkgutil, contextlib
from typing import Any, Dict, Awaitable, Callable

from aiogram import Dispatcher, BaseMiddleware
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import BotCommand

from app.bot import bot
from app.db import async_session as SessionLocal, engine, Base
from app.config import settings
import app.models as _models_pkg
import app.hooks  # noqa: F401  # –ø–æ–¥—Ö–≤–∞—Ç–∏—Ç—å –ª—é–±—ã–µ side-effects

# --- —Å–µ—Ä–≤–∏—Å—ã ---
try:
    from app.services.reminders import tick_reminders
except Exception:
    async def tick_reminders(*_a, **_kw): return None

try:
    from app.scheduler import ensure_started  # –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å
except Exception:
    ensure_started = None  # type: ignore

# --- —Ä–æ—É—Ç–µ—Ä—ã ---
from app.handlers import start, language, privacy, journal, reminders, report, premium, premium_reset
from app.features import router as features_router

# --- –∫–æ–º–∞–Ω–¥—ã ---
RU_COMMANDS = [
    BotCommand(command="start",   description="–ù–∞—á–∞—Ç—å"),
    BotCommand(command="journal", description="–°–¥–µ–ª–∞—Ç—å –∑–∞–ø–∏—Å—å"),
    BotCommand(command="stats",   description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",  description="–°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"),
    BotCommand(command="premium", description="–ü—Ä–µ–º–∏—É–º-—Å—Ç–∞—Ç—É—Å"),
]
UK_COMMANDS = [
    BotCommand(command="start",   description="–ü–æ—á–∞—Ç–∏"),
    BotCommand(command="journal", description="–ó—Ä–æ–±–∏—Ç–∏ –∑–∞–ø–∏—Å"),
    BotCommand(command="stats",   description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",  description="–°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è"),
    BotCommand(command="premium", description="–ü—Ä–µ–º—ñ—É–º-—Å—Ç–∞—Ç—É—Å"),
]
EN_COMMANDS = [
    BotCommand(command="start",   description="Start"),
    BotCommand(command="journal", description="New journal entry"),
    BotCommand(command="stats",   description="Stats"),
    BotCommand(command="remind",  description="Create reminder"),
    BotCommand(command="premium", description="Premium"),
]

# --- –º–∏–¥–¥–ª–≤–∞—Ä–∏ ---
try:
    from app.middlewares.lang import LangMiddleware
except Exception:
    class LangMiddleware(BaseMiddleware):
        async def __call__(self, handler, event, data):
            data.setdefault("lang", "ru")
            return await handler(event, data)

class DBSessionMiddleware(BaseMiddleware):
    async def __call__(self, handler: Callable[[Any, Dict[str, Any]], Awaitable[Any]], event, data: Dict[str, Any]) -> Any:
        async with SessionLocal() as session:
            data["session"] = session
            return await handler(event, data)

# --- —É—Ç–∏–ª–∏—Ç—ã ---
async def _ensure_db() -> None:
    # –ø—Ä–æ–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª–∏ –∏ —Å–æ–∑–¥–∞—ë–º —Ç–∞–±–ª–∏—Ü—ã
    for _, name, _ in pkgutil.iter_modules(_models_pkg.__path__, _models_pkg.__name__ + "."):
        importlib.import_module(name)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def _set_commands() -> None:
    await bot.set_my_commands(RU_COMMANDS, language_code="ru")
    await bot.set_my_commands(UK_COMMANDS, language_code="uk")
    await bot.set_my_commands(EN_COMMANDS, language_code="en")

async def _reminders_loop() -> None:
    tick = max(1, int(os.getenv("REMINDER_TICK_SEC", str(getattr(settings, "reminder_tick_sec", 5)))))
    while True:
        try:
            async with SessionLocal() as session:
                await tick_reminders(session, bot)
        except Exception:
            logging.exception("reminders_loop error")
        await asyncio.sleep(tick)

def build_dispatcher() -> Dispatcher:
    dp = Dispatcher(storage=MemoryStorage())
    dp.update.outer_middleware(DBSessionMiddleware())
    dp.update.outer_middleware(LangMiddleware())

    # –ø–æ—Ä—è–¥–æ–∫ –∫—Ä–∏—Ç–∏—á–µ–Ω: premium —Ä–∞–Ω—å—à–µ, language —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ–¥–Ω–∏–º

    dp.include_router(premium_reset.router)
    dp.include_router(privacy.router)
    dp.include_router(start.router)
    dp.include_router(journal.router)
    dp.include_router(report.router)
    dp.include_router(features_router)
    dp.include_router(reminders.router)
    dp.include_router(language.router)
    return dp

async def main() -> None:
    level = getattr(logging, os.getenv("LOG_LEVEL", "INFO").upper(), logging.INFO)
    logging.basicConfig(level=level)
    # –ø—Ä–∏–≥–ª—É—à–∏—Ç—å –±–æ–ª—Ç–æ–≤–Ω—é –±–∏–±–ª–∏–æ—Ç–µ–∫
    for name in ("aiosqlite", "apscheduler", "sqlalchemy.engine.Engine"):
        with contextlib.suppress(Exception):
            logging.getLogger(name).setLevel(logging.WARNING)

    # –ë–î –∏ —Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã
    await _ensure_db()
    with contextlib.suppress(Exception):
        if ensure_started:
            ensure_started()

    dp = build_dispatcher()
    await _set_commands()

    # —Å—Ç–∞—Ä—Ç—É–µ–º –≤ —Ä–µ–∂–∏–º–µ polling
    with contextlib.suppress(Exception):
        await bot.delete_webhook(drop_pending_updates=True)

    # –∫—Ç–æ –º—ã —Ç–∞–∫–∏–µ
    with contextlib.suppress(Exception):
        me = await bot.get_me()
        logging.info("Connected as @%s id: %s", me.username, me.id)

    reminders_task = asyncio.create_task(_reminders_loop(), name="reminders_loop")
    logging.info("‚úÖ Bot is up. Starting polling‚Ä¶")
    try:
        await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())
    finally:
        reminders_task.cancel()
        with contextlib.suppress(Exception):
            await reminders_task
        with contextlib.suppress(Exception):
            await bot.session.close()

if __name__ == "__main__":
    asyncio.run(main())
==========================================================================================
# app/middlewares/lang.py
==========================================================================================
# app/middlewares/lang.py
from __future__ import annotations
from typing import Any, Dict, Awaitable, Callable, Optional, Tuple

from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery
from sqlalchemy import select

from app.models.user import User
from app.db import async_session

SUPPORTED_LOCALES = {"ru","uk","en"}

def _extract_from_event(event: Any) -> Tuple[Optional[int], str]:
    tg_id: Optional[int] = None
    lc: str = ""
    if isinstance(event, Message) and event.from_user:
        tg_id = event.from_user.id
        lc = (event.from_user.language_code or "")[:2].lower()
    elif isinstance(event, CallbackQuery) and event.from_user:
        tg_id = event.from_user.id
        lc = (event.from_user.language_code or "")[:2].lower()
    else:
        fu = getattr(event, "event_from_user", None)
        if fu:
            tg_id = getattr(fu, "id", None)
            lc = (getattr(fu, "language_code", "") or "")[:2].lower()
    if lc == "ua": lc = "uk"
    return tg_id, lc

class LangMiddleware(BaseMiddleware):
    def __init__(self, default_locale: str = "ru") -> None:
        super().__init__()
        self.default_locale = default_locale if default_locale in SUPPORTED_LOCALES else "ru"

    async def __call__(
        self,
        handler: Callable[[Any, Dict[str, Any]], Awaitable[Any]],
        event: Any,
        data: Dict[str, Any],
    ) -> Any:
        tg_id, tele_lc = _extract_from_event(event)

        user: Optional[User] = data.get("user")
        if not user and tg_id:
            session = data.get("session")
            if session:
                user = (await session.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()
            else:
                async with async_session() as s:
                    user = (await s.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()
            if user:
                data["user"] = user

        loc = ""
        if user:
            loc = (getattr(user, "locale", None) or getattr(user, "lang", None) or "").lower()
        loc = loc[:2]
        locale = (
            loc if loc in SUPPORTED_LOCALES else
            (tele_lc if tele_lc in SUPPORTED_LOCALES else self.default_locale)
        )

        data["lang"] = locale
        if user and getattr(user, "tz", None):
            data.setdefault("tz", user.tz)

        i18n_ctx = data.get("i18n")
        if i18n_ctx:
            try:
                await i18n_ctx.set_locale(locale)
            except Exception:
                pass

        return await handler(event, data)
==========================================================================================
# app/models.py
==========================================================================================
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import Integer, String, ForeignKey, Index
class Base(DeclarativeBase):
    pass
class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    tg_id: Mapped[int] = mapped_column(Integer, unique=True)
    tz: Mapped[str] = mapped_column(String, default="Europe/Kyiv")
    reminders: Mapped[list["Reminder"]] = relationship(back_populates="user", cascade="all, delete-orphan")
class Reminder(Base):
    __tablename__ = "reminder"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    title: Mapped[str | None] = mapped_column(String)
    cron: Mapped[str | None] = mapped_column(String)
    next_run: Mapped[str | None] = mapped_column(String)
    is_active: Mapped[int] = mapped_column(Integer, default=1)
    user: Mapped["User"] = relationship(back_populates="reminders")
Index("ix_reminder_user_next", Reminder.user_id, Reminder.next_run)

==========================================================================================
# app/models/__init__.py
==========================================================================================
from .user import User
from .payment import Payment
__all__=["User","Payment"]

==========================================================================================
# app/models/bug_report.py
==========================================================================================
# app/models/bug_report.py
from __future__ import annotations

from typing import Optional
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import ForeignKey, Text, String, TIMESTAMP, func, Index, text as sa_text
from app.db import Base

class BugReport(Base):
    __tablename__ = "bug_reports"

    id: Mapped[int] = mapped_column(primary_key=True)

    user_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    # —Ç–µ–∫—Å—Ç –æ—Ç—á—ë—Ç–∞ ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π
    text: Mapped[str] = mapped_column(Text, nullable=False)

    # —Å—Ç–∞—Ç—É—Å: python-side default + server-side default (–≤–∞–∂–Ω–æ: sa_text, —á—Ç–æ–±—ã –Ω–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞—Ç—å —Å –ø–æ–ª–µ–º text)
    status: Mapped[str] = mapped_column(
        String(32),
        default="new",
        server_default=sa_text("'new'"),
        nullable=False,
    )

    created_at = mapped_column(
        TIMESTAMP(timezone=True),
        server_default=func.now(),   # –∫—Ä–æ—Å—Å-–°–£–ë–î –Ω–æ—Ä–º–∞–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
        nullable=False,
    )

    __table_args__ = (
        Index("ix_bug_reports_status", "status"),
    )

    def __repr__(self) -> str:
        return f"<BugReport id={self.id} user_id={self.user_id} status={self.status}>"
==========================================================================================
# app/models/journal.py
==========================================================================================
from __future__ import annotations

from typing import Optional
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import ForeignKey, Text, Integer

from app.db import Base
from app.models.mixins import TimestampMixin


class JournalEntry(TimestampMixin, Base):
    __tablename__ = "journal_entries"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"),
        index=True,
        nullable=False,
    )
    text: Mapped[str] = mapped_column(Text, nullable=False)
    # 1..5 ‚Äî –≤–∞–ª–∏–¥–∏—Ä—É–π –≤ –∫–æ–¥–µ/—Å—Ö–µ–º–µ, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    mood: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
==========================================================================================
# app/models/mixins.py
==========================================================================================
from __future__ import annotations

from datetime import datetime
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import DateTime
from sqlalchemy.sql import func


class TimestampMixin:
    """Timezone-aware created_at / updated_at mixin."""
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    updated_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=True,
    )
==========================================================================================
# app/models/payment.py
==========================================================================================
from __future__ import annotations

from typing import Optional
from datetime import datetime

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import (
    ForeignKey,
    String,
    Integer,
    Text,
    TIMESTAMP,
    func,
    CheckConstraint,
    Index,
)

from app.db import Base
from app.models.mixins import TimestampMixin


class Payment(TimestampMixin, Base):
    __tablename__ = "payments"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    provider: Mapped[str] = mapped_column(String(32))
    plan: Mapped[str] = mapped_column(String(64))

    amount_cents: Mapped[int] = mapped_column(Integer)
    currency: Mapped[str] = mapped_column(String(8), default="USD")

    status: Mapped[str] = mapped_column(String(16))
    external_id: Mapped[Optional[str]] = mapped_column(String(128), nullable=True, index=True)

    # –•—Ä–∞–Ω–∏–º —Å—ã—Ä–æ–µ —Ç–µ–ª–æ –≤–µ–±—Ö—É–∫–∞ –∫–∞–∫ —Ç–µ–∫—Å—Ç (–±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π 256 —Å–∏–º–≤–æ–ª–æ–≤)
    payload: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –µ—Å–ª–∏ –≥–¥–µ-—Ç–æ —á–∏—Ç–∞—é—Ç —ç—Ç–æ –ø–æ–ª–µ –Ω–∞–ø—Ä—è–º—É—é
    created_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        server_default=func.now(),
    )
    paid_at: Mapped[Optional[datetime]] = mapped_column(TIMESTAMP(timezone=True), nullable=True)

    __table_args__ = (
        CheckConstraint("amount_cents >= 0", name="ck_payments_amount_nonneg"),
        Index("ix_payments_provider_status", "provider", "status"),
        # –ß–∞—Å—Ç–∏—á–Ω–æ-—É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –ø–æ external_id (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ NULL)
        # –∏–º—è —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ç–µ–º, —á—Ç–æ —Ç—ã —É–∂–µ —Å–æ–∑–¥–∞–ª —á–µ—Ä–µ–∑ SQL
        Index(
            "uq_payments_external_id",
            "external_id",
            unique=True,
            postgresql_where=(external_id.is_not(None)),  # –∏–≥–Ω–æ—Ä–∏–º NULL
        ),
    )

    def __repr__(self) -> str:
        return f"<Payment id={self.id} user_id={self.user_id} {self.provider} {self.status}>"
==========================================================================================
# app/models/reminder.py
==========================================================================================
from __future__ import annotations

import logging
from typing import Optional
from datetime import datetime

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import ForeignKey, Text, Boolean, DateTime, Index

from app.db import Base
from app.models.mixins import TimestampMixin

log = logging.getLogger("reminders")


class Reminder(TimestampMixin, Base):
    __tablename__ = "reminder"  # –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ –µ–¥. —á–∏—Å–ª–µ, –∫–∞–∫ –≤ –ë–î

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"),
        index=True,
        nullable=False,
    )

    # –ö–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç/–Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
    title: Mapped[str] = mapped_column(Text, nullable=False)

    # –õ–∏–±–æ cron, –ª–∏–±–æ –æ–¥–∏–Ω–æ—á–Ω—ã–π next_run
    cron: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    next_run: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )

    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)

    __table_args__ = (
        Index("ix_reminder_due", "is_active", "next_run"),
    )
==========================================================================================
# app/models/user.py
==========================================================================================
# app/models/user.py
from __future__ import annotations

from datetime import time, datetime
from typing import Optional

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import BigInteger, Boolean, String, Time, DateTime

from app.db import Base
from app.models.mixins import TimestampMixin


class User(TimestampMixin, Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    tg_id: Mapped[int] = mapped_column(BigInteger, unique=True, index=True, nullable=False)

    # –∏–º–µ–Ω–Ω–æ locale —Ö—Ä–∞–Ω–∏–º –≤ –ë–î
    locale: Mapped[str] = mapped_column(String(8), default="ru", nullable=False)
    tz: Mapped[str] = mapped_column(String(64), default="Europe/Kyiv", nullable=False)

    consent_accepted_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    premium_until: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    premium_trial_granted: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

    morning_auto: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    morning_time: Mapped[time] = mapped_column(Time(timezone=False), default=time(9, 30), nullable=False)

    # –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
    @property
    def language(self) -> str:
        return self.locale

    @language.setter
    def language(self, v: str) -> None:
        self.locale = (v or "ru")
==========================================================================================
# app/payments/__init__.py
==========================================================================================

==========================================================================================
# app/payments/coinbase_webhook.py
==========================================================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
import os, hmac, hashlib, json, logging
from datetime import datetime, timezone, timedelta
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

router = APIRouter()
log = logging.getLogger("payments.webhook")
WEBHOOK_SECRET = os.getenv("COINBASE_COMMERCE_WEBHOOK_SECRET","")
DATABASE_URL = os.getenv("DATABASE_URL","")
engine = create_async_engine(DATABASE_URL, pool_pre_ping=True) if DATABASE_URL else None

async def grant_premium_days(tg_id: int, days: int = 31) -> bool:
    if not engine:
        return False
    async with engine.begin() as conn:
        res = await conn.execute(
            text(
                "UPDATE users "
                "SET premium_until = (CASE "
                "WHEN premium_until IS NOT NULL AND premium_until > (NOW() AT TIME ZONE 'utc') "
                "THEN premium_until ELSE (NOW() AT TIME ZONE 'utc') END) "
                " + (:days || ' days')::interval "
                "WHERE tg_id = :tg_id"
            ),
            {"tg_id": int(tg_id), "days": str(days)},
        )
        if res.rowcount == 0:
            try:
                await conn.execute(
                    text(
                        "INSERT INTO users (tg_id, premium_until) "
                        "VALUES (:tg_id, (NOW() AT TIME ZONE 'utc') + (:days || ' days')::interval)"
                    ),
                    {"tg_id": int(tg_id), "days": str(days)},
                )
            except Exception:
                pass
    return True

def _verify(sig_hdr: str, raw: bytes) -> bool:
    if not WEBHOOK_SECRET:
        return True
    digest = hmac.new(WEBHOOK_SECRET.encode(), raw, hashlib.sha256).hexdigest()
    return hmac.compare_digest(digest, sig_hdr or "")

@router.post("/payments/coinbase/webhook")
async def coinbase_webhook(request: Request):
    raw = await request.body()
    sig = request.headers.get("X-CC-Webhook-Signature","")
    if not _verify(sig, raw):
        return JSONResponse({"ok": False}, status_code=400)
    try:
        data = await request.json()
    except Exception:
        try:
            data = json.loads(raw.decode("utf-8","ignore"))
        except Exception:
            data = {}
    event = data.get("event") or {}
    etype = event.get("type")
    charge = event.get("data") or {}
    meta = charge.get("metadata") or {}
    tg_id = meta.get("tg_id")
    code = charge.get("code")
    log.info("coinbase_event type=%s code=%s tg_id=%s", etype, code, tg_id)
    ok_types = {"charge:confirmed","charge:resolved"}
    if etype in ok_types and tg_id:
        try:
            await grant_premium_days(int(tg_id), 31)
            log.info("premium_granted tg_id=%s", tg_id)
        except Exception as e:
            log.exception("premium_grant_failed tg_id=%s err=%s", tg_id, e)
            return JSONResponse({"ok": False}, status_code=500)
    return JSONResponse({"ok": True})

==========================================================================================
# app/payments/now.py
==========================================================================================

from fastapi import APIRouter, Request, Header, HTTPException
from fastapi.responses import RedirectResponse
import os, hmac, hashlib, json, requests

router = APIRouter()

def _base():
    return os.getenv("NOWP_BASE","https://api.nowpayments.io/v1").rstrip("/")

def _pub():
    return os.getenv("PUBLIC_BASE_URL","").rstrip("/")

def _price():
    return os.getenv("NOWP_PRICE_USD","1.00")

@router.get("/payments/now/create")
def now_create_invoice(tg_id: str):
    api_key = os.getenv("NOWP_API_KEY","").strip()
    if not api_key:
        raise HTTPException(status_code=500, detail="NOWP_API_KEY missing")
    payload = {
        "price_amount": _price(),
        "price_currency": "USD",
        "order_id": str(tg_id),
        "ipn_callback_url": f"{_pub()}/payments/now/webhook",
        "success_url": f"{_pub()}/payments/now/thanks",
        "cancel_url": f"{_pub()}/payments/now/cancel"
    }
    r = requests.post(f"{_base()}/invoice",
                      headers={"x-api-key": api_key, "Content-Type":"application/json"},
                      json=payload, timeout=20)
    try:
        r.raise_for_status()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"NOWP create failed: {e}")
    data = r.json()
    url = data.get("invoice_url")
    if not url:
        raise HTTPException(status_code=500, detail="invoice_url not found")
    return RedirectResponse(url, status_code=303)

@router.get("/payments/now/thanks")
def now_thanks():
    return {"ok": True, "status":"thanks"}

@router.get("/payments/now/cancel")
def now_cancel():
    return {"ok": True, "status":"cancel"}

@router.post("/payments/now/webhook")
async def now_webhook(request: Request, x_nowpayments_sig: str = Header(None)):
    raw = await request.body()
    secret = os.getenv("NOWP_IPN_SECRET","")
    expect = hmac.new(secret.encode(), raw, hashlib.sha512).hexdigest()
    if not x_nowpayments_sig or x_nowpayments_sig.lower() != expect.lower():
        raise HTTPException(status_code=400, detail="bad signature")

    body = await request.json()
    status = (body.get("payment_status") or "").lower()
    tg_id = str(body.get("order_id") or "").strip()
    invoice_id = str(body.get("invoice_id") or body.get("payment_id") or "")

    # TODO: integrate DB idempotency by invoice_id

    if status in {"finished","confirmed"} and tg_id.isdigit():
        try:
            # TODO: set_premium_until(int(tg_id), datetime.utcnow() + timedelta(days=30))
            pass
        except Exception as e:
            print("premium grant failed:", e)

    return {"ok": True}

==========================================================================================
# app/payments/nowp.py
==========================================================================================

from fastapi import APIRouter, Request
from fastapi.responses import RedirectResponse, JSONResponse
import os, hmac, hashlib, json, requests

router = APIRouter()

def _base():
    return os.getenv("NOWP_BASE", "https://api.nowpayments.io/v1")

def _verify_sig(secret: str, body: bytes, sig: str) -> bool:
    try:
        obj = json.loads(body.decode("utf-8"))
    except Exception:
        return False
    data = json.dumps(obj, separators=(',',':'), sort_keys=True)
    mac = hmac.new(secret.encode(), data.encode(), hashlib.sha512).hexdigest()
    return hmac.compare_digest(mac, (sig or '').lower())

@router.get("/payments/now/create")
def now_create(tg_id: str):
    key = os.getenv("NOWP_API_KEY")
    price = os.getenv("NOWP_PRICE_USD", "5.00")
    public = os.getenv("PUBLIC_BASE_URL", "https://ilda-comelier-pliantly.ngrok-free.dev")
    payload = {
        "price_amount": str(price),
        "price_currency": "USD",
        "order_id": str(tg_id),
        "ipn_callback_url": f"{public}/payments/now/webhook",
        "success_url": f"{public}/payments/now/thanks",
        "cancel_url": f"{public}/payments/now/cancel"
    }
    try:
        r = requests.post(f"{_base()}/invoice",
                          headers={"x-api-key": key, "Content-Type": "application/json"},
                          json=payload, timeout=20)
        r.raise_for_status()
        inv = r.json()
        url = inv.get("invoice_url") or inv.get("data",{}).get("invoice_url")
        if not url:
            return JSONResponse({"ok": False, "error": "no invoice_url", "resp": inv}, status_code=502)
        return RedirectResponse(url, status_code=303)
    except Exception as e:
        body = getattr(getattr(e, "response", None), "text", None)
        return JSONResponse({"ok": False, "error": str(e), "resp": body}, status_code=502)

@router.post("/payments/now/webhook")
async def now_webhook(request: Request):
    secret = os.getenv("NOWP_IPN_SECRET","")
    sig = request.headers.get("x-nowpayments-sig","")
    body = await request.body()
    if not _verify_sig(secret, body, sig):
        return JSONResponse({"ok": False, "reason": "bad_signature"}, status_code=401)
    data = json.loads(body.decode("utf-8"))
    status = (data.get("payment_status") or "").lower()
    order_id = str(data.get("order_id") or "")
    if status in ("finished","confirmed"):
        pass
    return JSONResponse({"ok": True})

@router.get("/payments/now/thanks")
def now_thanks():
    return {"ok": True, "status": "thanks"}

@router.get("/payments/now/cancel")
def now_cancel():
    return {"ok": False, "status": "cancel"}

==========================================================================================
# app/payments/nowpayments.py
==========================================================================================
import os, hmac, hashlib, requests
from fastapi import APIRouter, Query, Request
from fastapi.responses import RedirectResponse

router = APIRouter()

@router.get("/create")
def create_invoice(tg_id: str = Query(...)):
    api = os.getenv("NOWP_API_KEY")
    public = os.getenv("PUBLIC_BASE_URL")
    price = float(os.getenv("NOWP_PRICE_USD","5.00"))
    payload = {
        "price_amount": price,
        "price_currency": "USD",
        "order_id": f"tg_{tg_id}",
        "success_url": f"{public}/payments/success",
        "cancel_url":  f"{public}/payments/cancel",
        "ipn_callback_url": f"{public}/payments/now/webhook"
    }
    r = requests.post(
        "https://api.nowpayments.io/v1/invoice",
        headers={"x-api-key": api, "Content-Type":"application/json"},
        json=payload, timeout=20
    )
    r.raise_for_status()
    return RedirectResponse(r.json()["invoice_url"], status_code=303)

@router.post("/webhook")
async def webhook(request: Request):
    body = await request.body()
    sign = request.headers.get("x-nowpayments-sig","")
    check = hmac.new(os.getenv("NOWP_IPN_SECRET","").encode(), body, hashlib.sha512).hexdigest()
    if not hmac.compare_digest(check, sign):
        return {"ok": False}
    data = await request.json()
    status = data.get("payment_status") or data.get("invoice_status")
    order_id = data.get("order_id","")
    tg_id = order_id.replace("tg_","")
    print("NOWP EVENT:", status, tg_id)
    if status in ("finished","confirmed","paid","partially_paid"):
        # TODO: –≤—ã–¥–∞—Ç—å –ø—Ä–µ–º–∏—É–º tg_id –Ω–∞ 30 –¥–Ω–µ–π
        pass
    return {"ok": True}

==========================================================================================
# app/scheduler.py
==========================================================================================
from __future__ import annotations
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from pytz import utc
import asyncio

scheduler = AsyncIOScheduler(timezone=utc)

def ensure_started():
    # –ï—Å–ª–∏ –ª—É–ø –µ—â—ë –Ω–µ –∑–∞–ø—É—â–µ–Ω (–∏–º–ø–æ—Ä—Ç –≤—Ä–µ–º–µ–Ω–∏) ‚Äî –≤—ã—Ö–æ–¥–∏–º –º–æ–ª—á–∞.
    try:
        asyncio.get_running_loop()
    except RuntimeError:
        return
    if not scheduler.running:
        scheduler.start()

==========================================================================================
# app/services/__init__.py
==========================================================================================

==========================================================================================
# app/services/exporter.py
==========================================================================================
# exporter.py
import re
from typing import Optional, Tuple

# –ì–ª–∞–≥–æ–ª-—Ç—Ä–∏–≥–≥–µ—Ä (RU/UK/EN) + –º—è–≥–∫–∏–µ ¬´–ø–æ–∂–∞–ª—É–π—Å—Ç–∞/–±—É–¥—å –ª–∞—Å–∫–∞¬ª
VERB = (
    r"(?:–ø–æ–∂–∞–ª—É–π—Å—Ç–∞\s+)?(?:–±—É–¥—å\s+–ª–∞—Å–∫–∞\s+)?"
    r"(?:"
    r"–Ω–∞–ø–æ–º–Ω–∏(?:—Ç—å)?|–ø–æ—Å—Ç–∞–≤—å\s+–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ|"
    r"–Ω–∞–≥–∞–¥–∞–π|–Ω–∞–≥–∞–¥–∞—Ç–∏|"
    r"remind(?:\s+me)?(?:\s+to)?"
    r")"
)

# –õ—é–±—ã–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏
QUOTE_CHARS = "\"'‚Äú‚Äù¬´¬ª"
Q = r"[\"'‚Äú‚Äù¬´¬ª]"

def _strip_quotes_punct(s: str) -> str:
    s = s.strip()
    if len(s) >= 2 and s[0] in QUOTE_CHARS and s[-1] in QUOTE_CHARS:
        s = s[1:-1].strip()
    return s.rstrip(".!?,; ").lstrip()

# –ü–∞—Ç—Ç–µ—Ä–Ω—ã: –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –≥—Ä—É–ø–ø—ã what/when
_RAW_PATTERNS = [
    # 1) RU/UK/EN: ¬´–Ω–∞–ø–æ–º–Ω–∏ WHAT –≤|–æ|—á–µ—Ä–µ–∑|at|on|in WHEN¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+(?:–≤|–æ|—á–µ—Ä–µ–∑|at|on|in)\s+(?P<when>.+)",

    # 2) RU/EN: ¬´–Ω–∞–ø–æ–º–Ω–∏ —á–µ—Ä–µ–∑ WHEN WHAT¬ª
    rf"{VERB}\s+(?:—á–µ—Ä–µ–∑|in)\s+(?P<when>[^\"'‚Äú‚Äù¬´¬ª]+?)\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+{Q}?)",

    # 3) RU/UK: ¬´–Ω–∞–ø–æ–º–Ω–∏ WHAT (—Å–µ–≥–æ–¥–Ω—è|–∑–∞–≤—Ç—Ä–∞|–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞|—Å—å–æ–≥–æ–¥–Ω—ñ) [–≤ ‚Ä¶]¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+"
    rf"(?P<when>(?:—Å–µ–≥–æ–¥–Ω—è|–∑–∞–≤—Ç—Ä–∞|–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞|—Å—å–æ–≥–æ–¥–Ω—ñ)(?:\s+(?:–≤|–æ)\s+.+)?)",

    # 4) EN: ¬´remind (today|tomorrow|next Monday|on Monday [at ‚Ä¶]|weekdays|daily) WHAT¬ª
    rf"{VERB}\s+(?P<when>(?:today|tomorrow|next\s+\w+|on\s+\w+(?:day)?|weekdays|daily)(?:\s+at\s+.+)?)\s+"
    rf"(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+{Q}?)",

    # 5) Every/–∫–∞–∂–¥—ã–π/—â–æ–¥–Ω—è + –≤—Ä–µ–º—è (–ª—é–±—ã–µ —è–∑—ã–∫–∏): ¬´–Ω–∞–ø–æ–º–Ω–∏ WHAT –∫–∞–∂–¥—ã–π ‚Ä¶ –≤ 9:00¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+"
    rf"(?P<when>(?:–∫–∞–∂–¥\w+|—â–æ–¥–Ω—è|—â–æ—Ç–∏–∂–Ω—è|—â–æ—Å\w+|every|weekdays|daily)(?:\s+(?:–≤|–æ|at)\s+.+)?)",

    # 6) –ë—É–¥–Ω–∏–π/–¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏ + –≤—Ä–µ–º—è: ¬´–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç —Å—Ä–µ–¥—É –≤ 18:30¬ª / ¬´‚Ä¶ –ø–æ –±—É–¥–Ω—è–º –≤ 10¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+"
    rf"(?P<when>(?:–ø–æ\s+–±—É–¥–Ω—è–º|–±—É–¥–Ω—è–º|weekdays|"
    rf"(?:–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫|–≤—Ç–æ—Ä–Ω–∏–∫|—Å—Ä–µ–¥–∞|—Å—Ä–µ–¥—É|—á–µ—Ç–≤–µ—Ä–≥|–ø—è—Ç–Ω–∏—Ü–∞|—Å—É–±–±–æ—Ç–∞|–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ)|"
    rf"(?:–ø–æ–Ω–µ–¥—ñ–ª–æ–∫|–≤—ñ–≤—Ç–æ—Ä–æ–∫|—Å–µ—Ä–µ–¥–∞|—á–µ—Ç–≤–µ—Ä|–ø º—è—Ç–Ω–∏—Ü—è|–ø'—è—Ç–Ω–∏—Ü—è|—Å—É–±–æ—Ç–∞|–Ω–µ–¥—ñ–ª—è)|"
    rf"(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday))"
    rf"(?:\s+(?:–≤|–æ|at)\s+.+)?)",
]

PATTERNS = [re.compile(p, re.I | re.U) for p in _RAW_PATTERNS]

def parse_remind(text: str) -> Optional[Tuple[str, str]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (what, when) –∏–ª–∏ None.
    –ü—Ä–∏–º–µ—Ä—ã —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è:
      - ¬´–Ω–∞–ø–æ–º–Ω–∏ –ø–æ–∑–≤–æ–Ω–∏—Ç—å –º–∞–º–µ –∑–∞–≤—Ç—Ä–∞ –≤ 9¬ª
      - ¬´–Ω–∞–ø–æ–º–Ω–∏ —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞ "–ø—Ä–∏–Ω—è—Ç—å —Ç–∞–±–ª–µ—Ç–∫–∏"¬ª
      - ¬´remind me to drink water weekdays at 10¬ª
      - ¬´–Ω–∞–≥–∞–¥–∞–π "–∑–≤—ñ—Ç" —â–æ—Å–µ—Ä–µ–¥–∏ –æ 18:30¬ª
      - ¬´–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç –ø–æ –±—É–¥–Ω—è–º –≤ 10¬ª
      - ¬´remind tomorrow at 7 "call John"¬ª
    """
    s = (text or "").strip()
    if not s:
        return None
    for rx in PATTERNS:
        m = rx.search(s)
        if not m:
            continue
        what = _strip_quotes_punct(m.group("what"))
        when = _strip_quotes_punct(m.group("when"))
        if what and when:
            return what, when
    return None
==========================================================================================
# app/services/i18n.py
==========================================================================================
# app/i18n.py
from __future__ import annotations
import json
import re
from pathlib import Path
from typing import Dict, Any, Iterable
from functools import lru_cache
from app.config import settings

_BASE = Path(__file__).resolve().parent.parent / "i18n"

# –µ—Å–ª–∏ –≤ .env DEFAULT_LOCALE=ru/uk/en ‚Äî –ø–æ–¥—Ç—è–Ω–µ–º
_DEFAULT = (settings.default_locale or "ru").split("-")[0].lower()

# –ø—Ä–æ—Å—Ç–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤—Ö–æ–¥—è—â–∏—Ö –∫–æ–¥–æ–≤ —è–∑—ã–∫–∞
_NORMALIZE = {
    "ua": "uk",
    "ru-ru": "ru",
    "uk-ua": "uk",
    "en-us": "en",
    "en-gb": "en",
}

class _SafeDict(dict):
    def __missing__(self, key):
        # –Ω–µ –ø–∞–¥–∞–µ–º –Ω–∞ {missing_key}, –∞ –≤—ã–≤–æ–¥–∏–º –∫–∞–∫ –µ—Å—Ç—å
        return "{" + key + "}"

def _norm_locale(locale: str | None) -> str:
    if not locale:
        return _DEFAULT
    l = locale.lower()
    return _NORMALIZE.get(l, l.split("-")[0])

def _dig(d: Dict[str, Any], path: Iterable[str]) -> Any:
    cur: Any = d
    for p in path:
        if not isinstance(cur, dict) or p not in cur:
            return None
        cur = cur[p]
    return cur

@lru_cache(maxsize=16)
def _load(locale: str) -> dict:
    p = _BASE / f"{locale}.json"
    if not p.exists():
        return {}
    return json.loads(p.read_text("utf-8"))

def available_locales() -> set[str]:
    return {f.stem for f in _BASE.glob("*.json")}

def t(key: str, locale: str | None = None, **kwargs) -> str:
    """
    t("menu.start", locale="uk", name="–í–∞–ª–µ–Ω—Ç–∏–Ω")
    ‚Ä¢ dot-keys –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: section.sub.key
    ‚Ä¢ –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ format: –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã –Ω–µ —Ä–æ–Ω—è—é—Ç –∫–æ–¥
    ‚Ä¢ —Ñ–æ–ª–±—ç–∫: locale -> DEFAULT_LOCALE -> 'en' -> –∫–ª—é—á
    """
    loc = _norm_locale(locale)
    fallbacks = [loc, _DEFAULT, "en"]
    path = key.split(".")

    text: str | None = None
    for lc in fallbacks:
        data = _load(lc)
        val = _dig(data, path)
        if isinstance(val, str):
            text = val
            break

    if text is None:
        # –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∞–º –∫–ª—é—á (—É–¥–æ–±–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
        text = key

    return text.format_map(_SafeDict(**kwargs))

def reload_locales() -> None:
    """–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ DEV –ø–æ—Å–ª–µ –ø—Ä–∞–≤–∫–∏ i18n/*.json)."""
    _load.cache_clear()
==========================================================================================
# app/services/nlp.py
==========================================================================================
from __future__ import annotations

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, time
from typing import Optional, Literal
from zoneinfo import ZoneInfo

@dataclass
class ParsedReminder:
    what: str
    raw_when: str
    next_run_utc: Optional[datetime] = None
    cron: Optional[str] = None

@dataclass
class ToggleRequest:
    action: Literal["enable", "disable"]
    query: Optional[str] = None
    all: bool = False

@dataclass
class ParseResult:
    intent: Literal["create", "enable", "disable"]
    reminder: Optional[ParsedReminder] = None
    toggle: Optional[ToggleRequest] = None

def parse_any(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParseResult]:
    tgl = parse_toggle(text)
    if tgl:
        return ParseResult(intent=tgl.action, toggle=tgl)
    rem = parse_remind(text, user_tz=user_tz, now=now)
    if rem:
        return ParseResult(intent="create", reminder=rem)
    return None

def parse_remind(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParsedReminder]:
    tz = ZoneInfo(user_tz)
    now = now or datetime.now(tz)
    text_norm = _normalize(text)

    cron = _parse_recurring_cron(text_norm)
    if cron:
        what = _extract_what(text_norm, recurring=True)
        if not what:
            return None
        return ParsedReminder(what=what, raw_when=text.strip(), cron=cron)

    dt = _parse_once_datetime(text_norm, now, tz)
    if dt:
        what = _extract_what(text_norm, recurring=False)
        if not what:
            return None
        return ParsedReminder(what=what, raw_when=text.strip(), next_run_utc=dt.astimezone(ZoneInfo("UTC")))
    return None

_TOGGLE_ON_WORDS  = r"(?:–≤–∫–ª—é—á–∏|–≤–∫–ª|—É–≤—ñ–º–∫–Ω–∏|—É–≤—ñ–º–∫|on|enable)"
_TOGGLE_OFF_WORDS = r"(?:–≤—ã–∫–ª—é—á–∏|–≤—ã–∫–ª|–≤—ñ–¥–∫–ª—é—á–∏|–≤–∏–º–∫–Ω–∏|–≤–∏–º–∫|off|disable)"
_REMINDER_WORDS = r"(?:–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏(?:–µ|—è)|–Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è|reminder(?:s)?)"
_ALL_WORDS = r"(?:–≤—Å–µ|—É—Å—ñ|–≤—Å—ñ|all)"

_RE_TOGGLE = re.compile(
    rf"(?i)\b(?P<act>{_TOGGLE_ON_WORDS}|{_TOGGLE_OFF_WORDS})\b"
    rf"(?:\s+{_REMINDER_WORDS})?"
    rf"(?:\s+(?:–ø—Ä–æ|–Ω–∞|–ø–æ|about|for))?"
    rf"(?:\s+(?P<all>{_ALL_WORDS}))?"
    rf"(?:\s*(?P<query>.+))?$"
)

def parse_toggle(text: str) -> Optional[ToggleRequest]:
    s = _normalize(text)
    m = _RE_TOGGLE.match(s)
    if not m:
        return None
    act = m.group("act")
    action: Literal["enable", "disable"] = "enable" if re.search(rf"^{_TOGGLE_ON_WORDS}$", act, flags=re.I) else "disable"
    is_all = bool(m.group("all") and m.group("all").strip())
    query = (m.group("query") or "").strip()
    if is_all:
        return ToggleRequest(action=action, query=None, all=True)
    if not query:
        return ToggleRequest(action=action, query=None, all=True)
    return ToggleRequest(action=action, query=query, all=False)

_TRIGGERS = r"(?:–Ω–∞–ø–æ–º–Ω–∏|–Ω–∞–≥–∞–¥–∞–π|remind(?:\s+me\s+to)?)"
_RE_IN = r"(?:—á–µ—Ä–µ–∑|–∑–∞|in)"
_RE_AT = r"(?:–≤|–æ|at)"
_RE_TODAY = r"(?:—Å–µ–≥–æ–¥–Ω—è|—Å—å–æ–≥–æ–¥–Ω—ñ|today)"
_RE_TOMORROW = r"(?:–∑–∞–≤—Ç—Ä–∞|tomorrow)"
_RE_EVERY = r"(?:–∫–∞–∂–¥—ã–π|–∫–∞–∂–¥—É—é|–∫–∞–∂–¥–æ–µ|—â–æ–¥–Ω—è|—â–æ—Ç–∏–∂–Ω—è|—â–æ—Å–µ—Ä–µ–¥–∏|—â–æ–ø–æ–Ω–µ–¥—ñ–ª–∫–∞|every|weekdays|daily)"

_DOW_MAP = {
    "–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫": 1, "–≤—Ç–æ—Ä–Ω–∏–∫": 2, "—Å—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä–≥": 4, "–ø—è—Ç–Ω–∏—Ü–∞": 5, "—Å—É–±–±–æ—Ç–∞": 6, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ": 0, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω–∏–µ": 0,
    "–ø–æ–Ω–µ–¥—ñ–ª–æ–∫": 1, "–≤—ñ–≤—Ç–æ—Ä–æ–∫": 2, "—Å–µ—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä": 4, "–ø º—è—Ç–Ω–∏—Ü—è": 5, "–ø'—è—Ç–Ω–∏—Ü—è": 5, "—Å—É–±–æ—Ç–∞": 6, "–Ω–µ–¥—ñ–ª—è": 0,
    "monday": 1, "tuesday": 2, "wednesday": 3, "thursday": 4, "friday": 5, "saturday": 6, "sunday": 0,
}
_WEEKDAY_SET = set(_DOW_MAP.keys())

_RE_TIME = re.compile(r"\b(?P<h>\d{1,2})(?::(?P<m>\d{2}))?\s*(?P<ampm>am|pm)?\b", re.I)
_RE_DATE_DOT = re.compile(r"\b(?P<d>\d{1,2})\.(?P<m>\d{1,2})(?:\.(?P<y>\d{4}))?\b")
_RE_DATE_ISO = re.compile(r"\b(?P<y>\d{4})-(?P<m>\d{1,2})-(?P<d>\d{1,2})\b")

_RE_REL = re.compile(
    rf"\b{_RE_IN}\s+"
    r"(?:(?P<hours>\d+)\s*(?:—á–∞—Å(?:–∞|–æ–≤)?|–≥–æ–¥(?:–∏–Ω–∏)?|h|hours?)\s*)?"
    r"(?:(?P<minutes>\d+)\s*(?:–º–∏–Ω—É—Ç(?:—ã)?|—Ö–≤(?:–∏–ª–∏–Ω)?|m|mins?|minutes?)\s*)?"
    r"(?:(?P<days>\d+)\s*(?:–¥–Ω(?:—è|–µ–π|—ñ–≤)?|days?)\s*)?"
    r"(?:(?P<weeks>\d+)\s*(?:–Ω–µ–¥–µ–ª(?:—è|–∏|—å)|—Ç–∏–∂–Ω(?:—ñ|—ñ–≤)|weeks?)\s*)?"
    r"\b",
    re.I,
)

def _normalize(text: str) -> str:
    t = text.strip().lower().replace("‚Äô", "'")
    t = re.sub(r"\s+", " ", t)
    return t

def _extract_what(text_norm: str, recurring: bool, allow_without_trigger: bool = True) -> Optional[str]:
    markers = [
        r"\b" + _RE_IN + r"\b",
        r"\b" + _RE_AT + r"\b",
        r"\b" + _RE_TODAY + r"\b",
        r"\b" + _RE_TOMORROW + r"\b",
        r"\b" + _RE_EVERY + r"\b",
        r"\b" + "|".join(map(re.escape, _WEEKDAY_SET)) + r"\b",
        r"\b–ø–æ –±—É–¥–Ω—è–º\b",
        r"\bweekdays\b",
        r"\bdaily\b",
        r"\b—â–æ–¥–Ω—è\b",
    ]
    m = re.search(rf"{_TRIGGERS}\s+(?:me\s+to\s+)?", text_norm)
    if m:
        start = m.end()
    elif allow_without_trigger:
        start = 0
    else:
        return None

    end = len(text_norm)
    for mk in markers:
        mm = re.search(mk, text_norm[start:])
        if mm:
            end = min(end, start + mm.start())

    what = text_norm[start:end].strip(" ,.;:‚Äî-")
    return what or None

def _parse_time_fragment(s: str) -> Optional[time]:
    m = _RE_TIME.search(s)
    if not m:
        return None
    h = int(m.group("h"))
    mnt = int(m.group("m") or 0)
    ampm = (m.group("ampm") or "").lower()
    if ampm == "pm" and 1 <= h <= 11:
        h += 12
    if ampm == "am" and h == 12:
        h = 0
    if not (0 <= h <= 23 and 0 <= mnt <= 59):
        return None
    return time(hour=h, minute=mnt)

def _apply_time(base: datetime, t: time) -> datetime:
    return base.replace(hour=t.hour, minute=t.minute, second=0, microsecond=0)

def _parse_once_datetime(text_norm: str, now: datetime, tz: ZoneInfo) -> Optional[datetime]:
    m = _RE_REL.search(text_norm)
    if m and any(m.group(g) for g in ("minutes", "hours", "days", "weeks")):
        dt = now
        if m.group("minutes"): dt += timedelta(minutes=int(m.group("minutes")))
        if m.group("hours"):   dt += timedelta(hours=int(m.group("hours")))
        if m.group("days"):    dt += timedelta(days=int(m.group("days")))
        if m.group("weeks"):   dt += timedelta(weeks=int(m.group("weeks")))
        return dt

    date_dt = None
    mi = _RE_DATE_ISO.search(text_norm)
    md = _RE_DATE_DOT.search(text_norm)
    if mi:
        y, mo, d = int(mi.group("y")), int(mi.group("m")), int(mi.group("d"))
        date_dt = datetime(y, mo, d, tzinfo=tz)
    elif md:
        d, mo = int(md.group("d")), int(md.group("m"))
        y = int(md.group("y")) if md.group("y") else now.year
        date_dt = datetime(y, mo, d, tzinfo=tz)

    tm = _parse_time_fragment(text_norm)
    if date_dt:
        dt = _apply_time(date_dt, tm or time(9, 0))
        return dt

    if re.search(rf"\b{_RE_TODAY}\b", text_norm):
        dt = _apply_time(now, tm or time(9, 0))
        if tm is None and dt < now:
            dt = dt + timedelta(hours=1)
        return dt

    if re.search(rf"\b{_RE_TOMORROW}\b", text_norm):
        base = (now + timedelta(days=1)).replace(hour=9, minute=0, second=0, microsecond=0)
        if tm:
            base = _apply_time(base, tm)
        return base

    if tm:
        dt = _apply_time(now, tm)
        if dt <= now:
            dt += timedelta(days=1)
        return dt
    return None

def _parse_recurring_cron(text_norm: str) -> Optional[str]:
    tm = _parse_time_fragment(text_norm)
    if not tm:
        return None
    minute = tm.minute
    hour = tm.hour

    if re.search(r"\b(daily|—â–æ–¥–Ω—è|–∫–∞–∂–¥—ã–π –¥–µ–Ω—å)\b", text_norm):
        return f"{minute} {hour} * * *"

    if re.search(r"\b(weekdays|–ø–æ –±—É–¥–Ω—è–º)\b", text_norm):
        return f"{minute} {hour} * * 1-5"

    if re.search(r"\b(–∫–∞–∂–¥\w+|—â–æ—Å\w+|every)\b", text_norm):
        wd = _find_weekday(text_norm)
        if wd is not None:
            return f"{minute} {hour} * * {wd}"

    wd = _find_weekday(text_norm)
    if wd is not None and re.search(rf"\b{_RE_AT}\b", text_norm):
        return f"{minute} {hour} * * {wd}"
    return None

def _find_weekday(text_norm: str) -> Optional[int]:
    pos = -1
    val = None
    for name, dow in _DOW_MAP.items():
        m = re.search(rf"\b{name}\b", text_norm)
        if m and m.start() > pos:
            pos = m.start()
            val = dow
    return val

__all__ = [
    "ParsedReminder",
    "ToggleRequest",
    "ParseResult",
    "parse_any",
    "parse_remind",
    "parse_toggle",
]

==========================================================================================
# app/services/payments.py
==========================================================================================

==========================================================================================
# app/services/payments/__init__.py
==========================================================================================
from .coinbase import create_coinbase_charge, build_pay_kb
__all__=["create_coinbase_charge","build_pay_kb"]

==========================================================================================
# app/services/payments/coinbase.py
==========================================================================================
# app/services/payments/coinbase.py
from __future__ import annotations

import aiohttp, json, uuid
from typing import Optional, Tuple
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from app.config import settings
from app.models.user import User
from app.models.payment import Payment

API_BASE = getattr(settings, "coinbase_api_base", "https://api.commerce.coinbase.com")
COINBASE_CHARGES = "/charges"

def _headers(idempotency_key: str | None = None) -> dict:
    h = {
        "X-CC-Api-Key": settings.coinbase_api_key,
        "X-CC-Version": "2018-03-22",
        "Content-Type": "application/json",
    }
    if idempotency_key:
        h["Idempotency-Key"] = idempotency_key
    return h

async def create_coinbase_charge(
    session: AsyncSession,
    user: User,
    *,
    plan: str = "monthly",
    amount_usd: Optional[float] = None,
    description: Optional[str] = None,
) -> Tuple[Payment, str]:
    amount_usd = float(amount_usd if amount_usd is not None else settings.premium_price_usd)
    amount_cents = int(round(amount_usd * 100))

    pay = Payment(
        user_id=user.id,
        provider="coinbase",
        plan=plan,
        amount_cents=amount_cents,
        currency="USD",
        status="pending",
        payload=f"user:{user.id};plan:{plan}",
    )
    session.add(pay)
    await session.commit()
    await session.refresh(pay)

    body = {
        "name": "Premium 1 month",
        "description": description or "Diary Assistant Premium ‚Äî 1 month access",
        "pricing_type": "fixed_price",
        "local_price": {"amount": f"{amount_usd:.2f}", "currency": "USD"},
        "metadata": {"payment_id": str(pay.id), "user_id": str(user.id), "plan": plan},
    }

    timeout = aiohttp.ClientTimeout(total=25)
    idem = str(uuid.uuid4())

    async with aiohttp.ClientSession(timeout=timeout) as http:
        async with http.post(f"{API_BASE}{COINBASE_CHARGES}", headers=_headers(idem), data=json.dumps(body)) as resp:
            data = await resp.json()
            if resp.status >= 300:
                # –æ—Ç–º–µ—Ç–∏–º –æ—à–∏–±–∫—É –≤ –ø–ª–∞—Ç–µ–∂–µ –∏ –ø—Ä–æ–±—Ä–æ—Å–∏–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
                pay.status = "error"
                pay.payload = (pay.payload or "") + f";err:{resp.status}"
                await session.commit()
                raise RuntimeError(f"Coinbase create charge error {resp.status}: {data}")

    charge = data.get("data") or {}
    hosted_url = charge.get("hosted_url")
    pay.external_id = charge.get("id")
    await session.commit()
    return pay, hosted_url

def build_pay_kb(url: str, lang: str = "ru") -> InlineKeyboardMarkup:
    text = {
        "ru": "üíé –û–ø–ª–∞—Ç–∏—Ç—å Premium (Crypto)",
        "uk": "üíé –û–ø–ª–∞—Ç–∏—Ç–∏ Premium (Crypto)",
        "en": "üíé Pay Premium (Crypto)",
    }.get((lang or "ru")[:2], "üíé Pay Premium (Crypto)")
    return InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=text, url=url)]])
==========================================================================================
# app/services/reminders.py
==========================================================================================
# app/services/reminders.py
from __future__ import annotations

from datetime import datetime, timezone, timedelta
from zoneinfo import ZoneInfo

from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

try:
    from croniter import croniter  # pip install croniter
except Exception:  # fallback-—Å—Ç–∞–±, —á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞—Ç—å
    croniter = None  # type: ignore

# –ú–æ–¥–µ–ª–∏
from app.models.user import User
from app.models.reminder import Reminder


# ---------- i18n –º–∏–Ω–∏-–Ω–∞–±–æ—Ä ----------
_TEXT = {
    "ding": {
        "ru": "‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {title}",
        "uk": "‚è∞ –ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è: {title}",
        "en": "‚è∞ Reminder: {title}",
    }
}

def _pick_lang(u: User | None) -> str:
    cand = (getattr(u, "locale", None) or getattr(u, "lang", None) or "ru").lower()
    cand = cand.split("-")[0]
    return cand if cand in {"ru", "uk", "en"} else "ru"

def _fmt_local(dt_utc: datetime, tz_name: str | None) -> str:
    try:
        return dt_utc.astimezone(ZoneInfo(tz_name or "Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return dt_utc.astimezone(ZoneInfo("Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")


# ---------- cron ‚Üí next UTC ----------
async def compute_next_run(cron: str, now_utc: datetime, tz_name: str) -> datetime | None:
    """
    cron: —Å—Ç—Ä–æ–∫–∞ crontab, –Ω–∞–ø—Ä. "0 9 * * 1-5"
    now_utc: —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç (UTC, aware)
    tz_name: –∏–º—è TZ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (Europe/Kyiv –∏ —Ç.–ø.)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π –∑–∞–ø—É—Å–∫ –≤ UTC (aware) –ª–∏–±–æ None.
    """
    if croniter is None:
        return None
    try:
        base_local = now_utc.astimezone(ZoneInfo(tz_name or "UTC"))
        it = croniter(cron, base_local)
        nxt_local = it.get_next(datetime)  # aware –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π TZ
        return nxt_local.astimezone(timezone.utc)
    except Exception:
        return None


# ---------- —è–¥—Ä–æ —Ç–∏–∫–∞ ----------
async def _tick_with_session(session: AsyncSession, bot) -> None:
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ/–¥–æ–ª–∂–Ω—ã–µ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.
    - –ë–µ—Ä—ë–º due –≤ UTC
    - –®–ª—ë–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    - –ï—Å–ª–∏ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ ‚Äî —Å—á–∏—Ç–∞–µ–º next_run; –µ—Å–ª–∏ –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ ‚Äî –≤—ã–∫–ª—é—á–∞–µ–º
    """
    now_utc = datetime.now(timezone.utc)

    # –ü–æ–¥—Ç—è–≥–∏–≤–∞–µ–º –≤–º–µ—Å—Ç–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (–¥–ª—è tz/locale/tg_id)
    q = (
        select(Reminder, User)
        .join(User, Reminder.user_id == User.id)
        .where(
            and_(
                Reminder.is_active.is_(True),
                Reminder.next_run.is_not(None),
                Reminder.next_run <= now_utc,
            )
        )
        .order_by(Reminder.next_run.asc())
        .limit(100)
    )
    rows = (await session.execute(q)).all()

    for r, u in rows:
        # –ë–µ–∑ tg_id —Å–º—ã—Å–ª–∞ —Å–ª–∞—Ç—å –Ω–µ—Ç ‚Äî –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º
        if not getattr(u, "tg_id", None):
            r.is_active = False
            session.add(r)
            continue

        lang = _pick_lang(u)
        txt = _TEXT["ding"][lang].format(title=r.title or "reminder")
        try:
            await bot.send_message(u.tg_id, txt)
        except Exception:
            # –ù–∞–ø—Ä–∏–º–µ—Ä, 403 (bot was blocked). –ß—Ç–æ–±—ã –Ω–µ –∑–∞–±–∏–≤–∞—Ç—å –æ—á–µ—Ä–µ–¥—å ‚Äî –≥–ª—É—à–∏–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.
            r.is_active = False
            session.add(r)
            continue

        # –ü–µ—Ä–µ—Å—Ç–∞–≤–ª—è–µ–º next_run
        if r.cron:
            nxt = await compute_next_run(r.cron, now_utc + timedelta(seconds=1), u.tz or "Europe/Kyiv")
            if nxt:
                r.next_run = nxt
            else:
                r.is_active = False  # –Ω–µ —Å–º–æ–≥–ª–∏ –ø–æ—Å—á–∏—Ç–∞—Ç—å ‚Äî –≤—ã–∫–ª—é—á–∏–º
        else:
            # –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ
            r.is_active = False
            r.next_run = None

        session.add(r)

    if rows:
        await session.commit()


# ---------- –≤–Ω–µ—à–Ω–∏–π API —Å –≥–∏–±–∫–æ–π —Å–∏–≥–Ω–∞—Ç—É—Ä–æ–π ----------
async def tick_reminders(*args):
    """
    –ì–∏–±–∫–∏–π –∞–¥–∞–ø—Ç–µ—Ä, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å main.py.
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º:
      - await tick_reminders(session, bot)
      - await tick_reminders(bot, async_sessionmaker)
      - await tick_reminders(async_sessionmaker, bot)
    """
    if len(args) != 2:
        raise TypeError("tick_reminders expects 2 args: (session, bot) OR (bot, sessionmaker)")

    a, b = args[0], args[1]

    # –í–∞—Ä–∏–∞–Ω—Ç 1: –Ω–∞–º –¥–∞–ª–∏ (session, bot)
    if hasattr(a, "execute") and hasattr(b, "send_message"):
        session, bot = a, b
        return await _tick_with_session(session, bot)

    # –í–∞—Ä–∏–∞–Ω—Ç 2/3: –Ω–∞–º –¥–∞–ª–∏ –±–æ—Ç –∏ —Ñ–∞–±—Ä–∏–∫—É —Å–µ—Å—Å–∏–π (–∏–ª–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç)
    if hasattr(a, "send_message") and callable(b):
        bot, sessionmaker = a, b
    elif hasattr(b, "send_message") and callable(a):
        bot, sessionmaker = b, a
    else:
        raise TypeError("tick_reminders: unable to detect (session vs bot vs sessionmaker)")

    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é –∏–∑ —Ñ–∞–±—Ä–∏–∫–∏
    session = await sessionmaker() if "await" in getattr(sessionmaker, "__code__", type("", (), {})()).co_names else sessionmaker()
    async with session as s:
        return await _tick_with_session(s, bot)

def now_utc() -> datetime:
    return datetime.now(timezone.utc)

def to_utc(dt: datetime, tz_name: str | None) -> datetime:
    """–õ–æ–∫–∞–ª—å–Ω–æ–µ -> UTC (aware). –ï—Å–ª–∏ dt naive ‚Äî —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –æ–Ω –≤ tz_name."""
    try:
        tz = ZoneInfo(tz_name or "UTC")
    except Exception:
        tz = ZoneInfo("UTC")
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=tz)
    else:
        dt = dt.astimezone(tz)
    return dt.astimezone(timezone.utc)

def to_local(dt_utc: datetime, tz_name: str | None) -> datetime:
    """UTC -> –ª–æ–∫–∞–ª—å–Ω–æ–µ (aware)."""
    if dt_utc.tzinfo is None:
        dt_utc = dt_utc.replace(tzinfo=timezone.utc)
    try:
        tz = ZoneInfo(tz_name or "Europe/Kyiv")
    except Exception:
        tz = ZoneInfo("Europe/Kyiv")
    return dt_utc.astimezone(tz)
==========================================================================================
# app/texts.py
==========================================================================================

from typing import Dict

DEFAULT_LOCALE = "ru"
SUPPORTED_LOCALES = {"ru", "uk", "en"}

TEXTS: Dict[str, Dict[str, str]] = {
    "ru": {
        # common
        "welcome": "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –¥–Ω–µ–≤–Ω–∏–∫-–ø–æ–º–æ—â–Ω–∏–∫. –ù–∞–∂–º–∏ üîí –ü–æ–ª–∏—Ç–∏–∫–∞, —á—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å —É—Å–ª–æ–≤–∏—è –∏ –Ω–∞—á–∞—Ç—å.",
        "privacy": "–≠—Ç–æ –ø–æ–º–æ—â–Ω–∏–∫-–¥–Ω–µ–≤–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø–∏—è –∏ –Ω–µ –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∞—è —É—Å–ª—É–≥–∞.",
        "privacy_answer": "–û—Ç–≤–µ—Ç: –°–æ–≥–ª–∞—Å–µ–Ω / –ù–µ —Å–æ–≥–ª–∞—Å–µ–Ω",
        "privacy_thanks": "–°–ø–∞—Å–∏–±–æ! –ú–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å. –ù–∞–ø–∏—à–∏ –ø–µ—Ä–≤—É—é –∑–∞–ø–∏—Å—å: /journal",
        "privacy_declined": "–û–∫. –Ø –Ω–µ –±—É–¥—É —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –∑–∞–ø–∏—Å–∏, –ø–æ–∫–∞ –≤—ã –Ω–µ —Å–æ–≥–ª–∞—Å–Ω—ã.",
        "choose_lang": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫: RU / UK / EN (–º–æ–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å: —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / –∞–Ω–≥–ª–∏–π—Å–∫–∏–π)",
        "lang_updated": "–ì–æ—Ç–æ–≤–æ. –Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª—ë–Ω.",
        "press_start": "–ù–∞–∂–º–∏ /start",
        "main_hint": "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É.",

        # menu/buttons
        "menu_meditation": "üßò –ú–µ–¥–∏—Ç–∞—Ü–∏—è",
        "menu_music": "üéµ –ú—É–∑—ã–∫–∞",
        "btn_language": "üåê –Ø–∑—ã–∫",
        "btn_privacy":  "üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
        "btn_report":   "üõ† –°–æ–æ–±—â–∏—Ç—å –ø—Ä–æ –±–∞–≥",
        "btn_premium":  "üíé –ü—Ä–µ–º–∏—É–º",

        # features
        "meditations_intro": "üßò –ü–æ–¥–±–æ—Ä–∫–∞ –∫–æ—Ä–æ—Ç–∫–∏—Ö –º–µ–¥–∏—Ç–∞—Ü–∏–π –∏ –¥—ã—Ö–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–∞–∫—Ç–∏–∫.",
        "music_intro": "üéµ –ú—É–∑—ã–∫–∞ –¥–ª—è —Ñ–æ–∫—É—Å–∞, —Å–Ω–∞ –∏ —Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–∏—è.",
        "med_choose": "–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü–∏–∏:",
        "music_choose": "–í—ã–±–µ—Ä–∏ –ø–ª–µ–π–ª–∏—Å—Ç:",
    },
    "uk": {
        "welcome": "–ü—Ä–∏–≤—ñ—Ç! –¶–µ —â–æ–¥–µ–Ω–Ω–∏–∫-–ø–æ–º—ñ—á–Ω–∏–∫. –ù–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞, —â–æ–± –ø—Ä–∏–π–Ω—è—Ç–∏ —É–º–æ–≤–∏ —ñ –ø–æ—á–∞—Ç–∏.",
        "privacy": "–¶–µ –ø–æ–º—ñ—á–Ω–∏–∫-—â–æ–¥–µ–Ω–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø—ñ—è —ñ –Ω–µ –º–µ–¥–∏—á–Ω–∞ –ø–æ—Å–ª—É–≥–∞.",
        "privacy_answer": "–í—ñ–¥–ø–æ–≤—ñ–¥—å: –ó–≥–æ–¥–µ–Ω / –ù–µ –∑–≥–æ–¥–µ–Ω",
        "privacy_thanks": "–î—è–∫—É—é! –ü–æ—á–∏–Ω–∞—î–º–æ. –ù–∞–ø–∏—à–∏ –ø–µ—Ä—à–∏–π –∑–∞–ø–∏—Å: /journal",
        "privacy_declined": "–û–∫. –Ø –Ω–µ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏–º—É –∑–∞–ø–∏—Å–∏, –ø–æ–∫–∏ –≤–∏ –Ω–µ –∑–≥–æ–¥–Ω—ñ.",
        "choose_lang": "–û–±–µ—Ä–∏ –º–æ–≤—É: RU / UK / EN (–º–æ–∂–Ω–∞ –Ω–∞–ø–∏—Å–∞—Ç–∏: —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / —Ä—É—Å—Å–∫–∏–π / english)",
        "lang_updated": "–ì–æ—Ç–æ–≤–æ. –ú–æ–≤—É –æ–Ω–æ–≤–ª–µ–Ω–æ.",
        "press_start": "–ù–∞—Ç–∏—Å–Ω–∏ /start",
        "main_hint": "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É.",

        "menu_meditation": "üßò –ú–µ–¥–∏—Ç–∞—Ü—ñ—è",
        "menu_music": "üéµ –ú—É–∑–∏–∫–∞",
        "btn_language": "üåê –ú–æ–≤–∞",
        "btn_privacy":  "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
        "btn_report":   "üõ† –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
        "btn_premium":  "üíé –ü—Ä–µ–º—ñ—É–º",

        "meditations_intro": "üßò –î–æ–±—ñ—Ä–∫–∞ –∫–æ—Ä–æ—Ç–∫–∏—Ö –º–µ–¥–∏—Ç–∞—Ü—ñ–π —Ç–∞ –¥–∏—Ö–∞–ª—å–Ω–∏—Ö –ø—Ä–∞–∫—Ç–∏–∫.",
        "music_intro": "üéµ –ú—É–∑–∏–∫–∞ –¥–ª—è —Ñ–æ–∫—É—Å—É, —Å–Ω—É —Ç–∞ —Ä–æ–∑—Å–ª–∞–±–ª–µ–Ω–Ω—è.",
        "med_choose": "–û–±–µ—Ä—ñ—Ç—å —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü—ñ—ó:",
        "music_choose": "–í–∏–±–µ—Ä—ñ—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç:",
    },
    "en": {
        "welcome": "Hi! This is a diary assistant. Tap üîí Privacy to accept the policy and start.",
        "privacy": "This is a journal assistant, not therapy or a medical service.",
        "privacy_answer": "Reply: Agree / Disagree",
        "privacy_thanks": "Thanks! You can start. Send your first entry: /journal",
        "privacy_declined": "Okay. I won‚Äôt save entries until you agree.",
        "choose_lang": "Choose language: RU / UK / EN (you can also type: —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / english)",
        "lang_updated": "Done. Language updated.",
        "press_start": "Press /start",
        "main_hint": "Main menu is below.",

        "menu_meditation": "üßò Meditation",
        "menu_music": "üéµ Music",
        "btn_language": "üåê Language",
        "btn_privacy":  "üîí Privacy",
        "btn_report":   "üõ† Report a bug",
        "btn_premium":  "üíé Premium",

        "meditations_intro": "üßò Short meditations and breathing exercises.",
        "music_intro": "üéµ Music for focus, sleep and relaxation.",
        "med_choose": "Choose a meditation mode:",
        "music_choose": "Choose a playlist:",
    },
}

def _normalize_lang(lang: str | None) -> str:
    if not lang:
        return DEFAULT_LOCALE
    lang = lang.lower()[:2]
    return lang if lang in SUPPORTED_LOCALES else DEFAULT_LOCALE

def t(key: str, lang: str | None = None, **kwargs) -> str:
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ —Å —Ñ–æ–ª–±—ç–∫–∞–º–∏ –∏ .format(**kwargs).
    –ü–æ—Ä—è–¥–æ–∫ —Ñ–æ–ª–±—ç–∫–æ–≤: lang -> DEFAULT_LOCALE -> 'en' -> key
    """
    loc = _normalize_lang(lang)
    s = TEXTS.get(loc, {}).get(key)
    if s is None:
        s = TEXTS.get(DEFAULT_LOCALE, {}).get(key)
    if s is None:
        s = TEXTS.get("en", {}).get(key)
    if s is None:
        s = key
    try:
        return s.format(**kwargs)
    except Exception:
        return s


# --- Premium translations (added) ---
try:
    TRANSLATIONS
except NameError:
    TRANSLATIONS = {}

TRANSLATIONS.update({
    "premium_on": {
        "ru": "–ü—Ä–µ–º–∏—É–º —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω ‚úÖ",
        "uk": "–ü—Ä–µ–º—ñ—É–º —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π ‚úÖ",
        "en": "Premium is already active ‚úÖ",
    },
    "premium_on_till": {
        "ru": "–ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {dt} ({tz}) ‚úÖ",
        "uk": "–ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {dt} ({tz}) ‚úÖ",
        "en": "Premium is active until {dt} ({tz}) ‚úÖ",
    },
    "subscribe_offer": {
        "ru": "–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî –∏ –ø–æ–ª—É—á–∏ 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞ üéÅ",
        "uk": "–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –ü—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî —ñ –æ—Ç—Ä–∏–º–∞–π 24 –≥–æ–¥–∏–Ω–∏ –ø—Ä–µ–º—ñ—É–º—É üéÅ",
        "en": "Premium is off. Subscribe to our channel and get 24h of Premium üéÅ",
    },
    "sub_given": {
        "ru": "–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞ ‚úÖ",
        "uk": "–í—ñ—Ç–∞—é! –ü—ñ–¥–ø–∏—Å–∫—É –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ ‚Äî –ø—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ ‚úÖ",
        "en": "Congrats! Subscription confirmed ‚Äî Premium activated for 24 hours ‚úÖ",
    },
    "sub_not_found": {
        "ru": "–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫–∏. –ù–∞–∂–º–∏ ¬´–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è¬ª, –∑–∞—Ç–µ–º ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª.",
        "uk": "–ù–µ –±–∞—á—É –ø—ñ–¥–ø–∏—Å–∫–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è¬ª, –ø–æ—Ç—ñ–º ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª.",
        "en": "I can‚Äôt see your subscription. Tap ‚ÄúSubscribe‚Äù then ‚ÄúCheck‚Äù.",
    },
    "btn_pay":   {"ru": "–û–ø–ª–∞—Ç–∏—Ç—å",     "uk": "–û–ø–ª–∞—Ç–∏—Ç–∏",     "en": "Pay"},
    "btn_sub":   {"ru": "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è",  "uk": "–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è",  "en": "Subscribe"},
    "btn_check": {"ru": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å",    "uk": "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏",   "en": "Check"},
})


# === bug-report texts ===
TRANSLATIONS.update({
    "btn_report_bug": {
        "ru": "üß© –ë–∞–≥-—Ä–µ–ø–æ—Ä—Ç",
        "uk": "üß© –ë–∞–≥-—Ä–µ–ø–æ—Ä—Ç",
        "en": "üß© Report a bug",
    },
    "bug_report_start": {
        "ru": "–û–ø–∏—à–∏ –ø—Ä–æ–±–ª–µ–º—É –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º –∏ –ø—Ä–∏–ª–æ–∂–∏ —Å–∫—Ä–∏–Ω/–≤–∏–¥–µ–æ. –ò–ª–∏ –ø—Ä–∏—à–ª–∏ /cancel.",
        "uk": "–û–ø–∏—à–∏ –ø—Ä–æ–±–ª–µ–º—É –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º —ñ –¥–æ–¥–∞–π —Å–∫—Ä—ñ–Ω/–≤—ñ–¥–µ–æ. –ê–±–æ –Ω–∞–¥—ñ—à–ª–∏ /cancel.",
        "en": "Describe the issue in one message and attach a screenshot/video. Or send /cancel.",
    },
    "bug_report_cancel": {
        "ru": "–û–∫–µ–π, –æ—Ç–º–µ–Ω–∏–ª. –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é.",
        "uk": "–ì–∞—Ä–∞–∑–¥, —Å–∫–∞—Å—É–≤–∞–≤. –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ—Å—å –¥–æ –º–µ–Ω—é.",
        "en": "Okay, cancelled. Back to menu.",
    },
    "bug_report_thanks": {
        "ru": "–°–ø–∞—Å–∏–±–æ! –û—Ç—á—ë—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω ‚úÖ",
        "uk": "–î—è–∫—É—î–º–æ! –ó–≤—ñ—Ç –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ ‚úÖ",
        "en": "Thanks! Report sent ‚úÖ",
    },
})

==========================================================================================
# app/urls.py
==========================================================================================
from .config import PUBLIC_URL
def pay_url(tg_id: int) -> str:
    return f"{PUBLIC_URL.rstrip('/')}/pay?tg_id={tg_id}"

==========================================================================================
# app/web.py
==========================================================================================
from fastapi import FastAPI

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–π —Å–≤–æ–π —Ä–æ—É—Ç–µ—Ä —Å Coinbase –≤–µ–±—Ö—É–∫–∞–º–∏.
# –§–∞–π–ª —Ç—ã –∫–∏–¥–∞–ª –∫–∞–∫ –º–æ–¥—É–ª—å —Å APIRouter ‚Äî —Å—á–∏—Ç–∞—é, —á—Ç–æ –æ–Ω –ª–µ–∂–∏—Ç –≤ app/api/coinbase.py
# –ï—Å–ª–∏ —É —Ç–µ–±—è –¥—Ä—É–≥–æ–µ –∏–º—è/–ø—É—Ç—å ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ–ø—Ä–∞–≤—å –∏–º–ø–æ—Ä—Ç –Ω–∏–∂–µ.
from app.api.coinbase import router as coinbase_router

app = FastAPI(title="DiaryBot API", version="1.0")
app.include_router(coinbase_router)

@app.get("/healthz")
def healthz():
    return {"ok": True}

==========================================================================================
# app/webhooks/__init__.py
==========================================================================================

==========================================================================================
# app/webhooks/coinbase.py
==========================================================================================
# app/api/coinbase.py
from __future__ import annotations

import hmac, hashlib, json
from datetime import datetime, timezone, timedelta

from fastapi import APIRouter, Request, HTTPException
from starlette.responses import RedirectResponse
from sqlalchemy import select

from app.config import settings
from app.db import async_session
from app.models.payment import Payment
from app.models.user import User
from app.services.payments.coinbase import create_coinbase_charge

router = APIRouter(prefix="/payments/coinbase", tags=["payments"])

def _verify_signature(raw: bytes, sig: str | None) -> None:
    secret = (settings.coinbase_webhook_secret or "").encode()
    if not secret:
        raise HTTPException(500, "webhook secret is not set")
    calc = hmac.new(secret, raw, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(calc, (sig or "")):
        raise HTTPException(400, "bad signature")

@router.post("/webhook")
async def coinbase_webhook(request: Request):
    raw = await request.body()
    _verify_signature(raw, request.headers.get("X-CC-Webhook-Signature"))

    try:
        payload = json.loads(raw.decode("utf-8"))
    except Exception:
        raise HTTPException(400, "bad json")

    evt = (payload.get("event") or {})
    etype = evt.get("type")
    data = (evt.get("data") or {})
    meta = (data.get("metadata") or {})
    ext_id = data.get("id")

    local_pricing = ((data.get("pricing") or {}).get("local") or {})
    local_amount = local_pricing.get("amount")
    local_currency = local_pricing.get("currency")

    async with async_session() as s:
        # 1) –∏—â–µ–º –ø–ª–∞—Ç—ë–∂ –ø–æ external_id (–∏/–∏–ª–∏ –ø–æ metadata.payment_id –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤)
        pay = (await s.execute(select(Payment).where(Payment.external_id == ext_id))).scalar_one_or_none()
        if not pay and meta.get("payment_id"):
            pay = (await s.execute(select(Payment).where(Payment.id == int(meta["payment_id"])))).scalar_one_or_none()

        if not pay:
            # –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —á–∞—Ä–¥–∂ ‚Äî —Ç–∏—Ö–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º (–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å)
            return {"ok": True}

        # 2) —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω? —Ç–æ–∂–µ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ –≤—ã—Ö–æ–¥–∏–º
        if pay.status == "succeeded":
            return {"ok": True}

        # 3) –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏ –ø—Ä–æ–¥–ª–µ–≤–∞–µ–º –ø—Ä–µ–º–∏—É–º
        if etype == "charge:confirmed":
            pay.status = "succeeded"
            pay.paid_at = datetime.now(timezone.utc)
            if local_amount and local_currency:
                try:
                    pay.amount_cents = int(round(float(local_amount) * 100))
                    pay.currency = local_currency
                except Exception:
                    pass

            # –ø—Ä–æ–¥–ª–∏—Ç—å –ø—Ä–µ–º–∏—É–º –≤–ª–∞–¥–µ–ª—å—Ü—É
            user = (await s.execute(select(User).where(User.id == pay.user_id))).scalar_one_or_none()
            if user:
                now = datetime.now(timezone.utc)
                base = user.premium_until if user.premium_until and user.premium_until > now else now
                user.premium_until = base + timedelta(days=30)
                s.add(user)

        elif etype in {"charge:failed", "charge:delayed", "charge:expired", "charge:unresolved"}:
            pay.status = "failed"

        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é ¬´–∫–≤–∏—Ç–∞–Ω—Ü–∏—é¬ª —Å–æ–±—ã—Ç–∏—è (–ø–æ–ª–Ω—ã–π JSON –≤ String(256) –Ω–µ –≤–ª–µ–∑–µ—Ç)
        pay.payload = json.dumps({"etype": etype, "ext_id": ext_id}, ensure_ascii=False)[:250]
        s.add(pay)
        await s.commit()

    return {"ok": True}

@router.get("/buy")
async def coinbase_buy(user_id: int | None = None, tg_id: int | None = None):
    if not user_id and not tg_id:
        raise HTTPException(400, "user_id or tg_id required")

    async with async_session() as s:
        if user_id:
            user = (await s.execute(select(User).where(User.id == user_id))).scalar_one_or_none()
        else:
            user = (await s.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()
        if not user:
            raise HTTPException(404, "user not found")

        pay, hosted = await create_coinbase_charge(
            session=s,
            user=user,
            plan="monthly",
            amount_usd=settings.premium_price_usd,
            description="Diary Assistant Premium ‚Äî 1 month",
        )

    return RedirectResponse(hosted, status_code=302)
==========================================================================================
# backups_1764378738/main.py
==========================================================================================
# app/main.py
from __future__ import annotations
import asyncio, logging, os, importlib, pkgutil, contextlib
from typing import Any, Dict, Awaitable, Callable

from aiogram import Dispatcher, BaseMiddleware
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import BotCommand

from app.bot import bot
from app.db import async_session as SessionLocal, engine, Base
from app.config import settings
import app.models as _models_pkg

try:
    from app.services.reminders import tick_reminders
except Exception:
    async def tick_reminders(*_a, **_kw): return None

try:
    from app.scheduler import ensure_started  # type: ignore
except Exception:
    ensure_started = None  # type: ignore

# ‚Äî —Ä–æ—É—Ç–µ—Ä—ã ‚Äî
from app.handlers import start, language, privacy, journal, reminders, report, premium
from app.features import router as features_router

RU_COMMANDS = [
    BotCommand(command="start",   description="–ù–∞—á–∞—Ç—å"),
    BotCommand(command="journal", description="–°–¥–µ–ª–∞—Ç—å –∑–∞–ø–∏—Å—å"),
    BotCommand(command="stats",   description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",  description="–°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"),
    BotCommand(command="premium", description="–ü—Ä–µ–º–∏—É–º-—Å—Ç–∞—Ç—É—Å"),
]
UK_COMMANDS = [
    BotCommand(command="start",   description="–ü–æ—á–∞—Ç–∏"),
    BotCommand(command="journal", description="–ó—Ä–æ–±–∏—Ç–∏ –∑–∞–ø–∏—Å"),
    BotCommand(command="stats",   description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",  description="–°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è"),
    BotCommand(command="premium", description="–ü—Ä–µ–º—ñ—É–º-—Å—Ç–∞—Ç—É—Å"),
]
EN_COMMANDS = [
    BotCommand(command="start",   description="Start"),
    BotCommand(command="journal", description="New journal entry"),
    BotCommand(command="stats",   description="Stats"),
    BotCommand(command="remind",  description="Create reminder"),
    BotCommand(command="premium", description="Premium"),
]

try:
    from app.middlewares.lang import LangMiddleware
except Exception:
    class LangMiddleware(BaseMiddleware):
        async def __call__(self, handler, event, data):
            data.setdefault("lang","ru")
            return await handler(event, data)

class DBSessionMiddleware(BaseMiddleware):
    async def __call__(self, handler: Callable[[Any, Dict[str, Any]], Awaitable[Any]], event, data: Dict[str, Any]) -> Any:
        async with SessionLocal() as session:
            data["session"] = session
            return await handler(event, data)

async def _ensure_db() -> None:
    for _, name, _ in pkgutil.iter_modules(_models_pkg.__path__, _models_pkg.__name__ + "."):
        importlib.import_module(name)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def _set_commands() -> None:
    await bot.set_my_commands(RU_COMMANDS, language_code="ru")
    await bot.set_my_commands(UK_COMMANDS, language_code="uk")
    await bot.set_my_commands(EN_COMMANDS, language_code="en")

async def _reminders_loop() -> None:
    tick = max(1, int(os.getenv("REMINDER_TICK_SEC", str(getattr(settings, "reminder_tick_sec", 5)))))
    while True:
        try:
            async with SessionLocal() as session:
                await tick_reminders(session, bot)
        except Exception:
            logging.exception("reminders_loop error")
        await asyncio.sleep(tick)

def build_dispatcher() -> Dispatcher:
    dp = Dispatcher(storage=MemoryStorage())
    dp.update.outer_middleware(DBSessionMiddleware())
    dp.update.outer_middleware(LangMiddleware())

    # –ø–æ—Ä—è–¥–æ–∫ –∫—Ä–∏—Ç–∏—á–µ–Ω: —à–∏—Ä–æ–∫–∏–µ ¬´—Å–ª—É—à–∞—Ç–µ–ª–∏¬ª ‚Äî –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ
    dp.include_router(premium.router)
    dp.include_router(privacy.router)
    dp.include_router(language.router)
    dp.include_router(start.router)
    dp.include_router(journal.router)
    dp.include_router(report.router)
    dp.include_router(features_router)
    dp.include_router(reminders.router)    # —Å–∞–º—ã–π –ø–æ—Å–ª–µ–¥–Ω–∏–π
    return dp

async def main() -> None:
    logging.basicConfig(level=getattr(logging, os.getenv("LOG_LEVEL","INFO").upper(), logging.INFO))
    logging.info("Bootstrapping‚Ä¶")

    await _ensure_db()
    try:
        if ensure_started:
            ensure_started()
    except Exception:
        logging.exception("ensure_started failed")

    dp = build_dispatcher()
    await _set_commands()

    reminders_task = asyncio.create_task(_reminders_loop(), name="reminders_loop")
    logging.info("‚úÖ Bot is up. Starting polling‚Ä¶")
    try:
        await dp.start_polling(bot)
    finally:
        reminders_task.cancel()
        with contextlib.suppress(Exception):
            await reminders_task

if __name__ == "__main__":
    asyncio.run(main())
==========================================================================================
# backups_1764378738/premium.py
==========================================================================================
# app/handlers/premium.py
from __future__ import annotations

import os
import logging
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo
import re, unicodedata as _ud

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.filters import or_f
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

from app.config import settings
from app.keyboards import get_main_kb, is_premium_btn

logger = logging.getLogger(__name__)
router = Router()

def _is_premium_trigger(text: str | None) -> bool:
    if not text:
        return False
    s = _ud.normalize('NFKC', str(text)).strip().lower()
    s = re.sub(r'[^\w–∞-—è—ñ—ó—î“ë—ë]+', ' ', s, flags=re.IGNORECASE)
    s = re.sub(r'\s+', ' ', s).strip()
    return s in {'premium','–ø—Ä–µ–º–∏—É–º','–ø—Ä–µ–º—ñ—É–º'}


# –ö–∞–Ω–∞–ª –¥–ª—è —Ç—Ä–∏–∞–ª–∞
CHANNEL_USERNAME = (
    os.getenv("PREMIUM_CHANNEL")
    or getattr(settings, "premium_channel", None)
    or "@NoticesDiarY"
)
CHANNEL_URL = f"https://t.me/{CHANNEL_USERNAME.lstrip('@')}"

# i18n fallback
try:
    from app.i18n import t  # type: ignore
except Exception:  # pragma: no cover
    def t(lang: str, key: str, **fmt) -> str:  # type: ignore
        lang = (lang or "ru")[:2].lower()
        D = {
            "premium_on":      {"ru":"–ü—Ä–µ–º–∏—É–º —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω ‚úÖ","uk":"–ü—Ä–µ–º—ñ—É–º —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π ‚úÖ","en":"Premium is already active ‚úÖ"},
            "premium_on_till": {"ru":"–ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {dt} ({tz}) ‚úÖ","uk":"–ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {dt} ({tz}) ‚úÖ","en":"Premium is active until {dt} ({tz}) ‚úÖ"},
            "subscribe_offer": {"ru":"–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî –∏ –ø–æ–ª—É—á–∏ 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞ üéÅ","uk":"–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –ü—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî —ñ –æ—Ç—Ä–∏–º–∞–π 24 –≥–æ–¥–∏–Ω–∏ –ø—Ä–µ–º—ñ—É–º—É üéÅ","en":"Premium is off. Subscribe to our channel and get 24h of Premium üéÅ"},
            "sub_given":       {"ru":"–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞ ‚úÖ","uk":"–í—ñ—Ç–∞—é! –ü—ñ–¥–ø–∏—Å–∫—É –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ ‚Äî –ø—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ ‚úÖ","en":"Congrats! Subscription confirmed ‚Äî Premium activated for 24 hours ‚úÖ"},
            "sub_not_found":   {"ru":"–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫–∏. –ù–∞–∂–º–∏ ¬´–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è¬ª, –∑–∞—Ç–µ–º ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª.","uk":"–ù–µ –±–∞—á—É –ø—ñ–¥–ø–∏—Å–∫–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è¬ª, –ø–æ—Ç—ñ–º ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª.","en":"I can‚Äôt see your subscription. Tap ‚ÄúSubscribe‚Äù then ‚ÄúCheck‚Äù."},
            "btn_pay":         {"ru":"–û–ø–ª–∞—Ç–∏—Ç—å","uk":"–û–ø–ª–∞—Ç–∏—Ç–∏","en":"Pay"},
            "btn_sub":         {"ru":"–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è","uk":"–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è","en":"Subscribe"},
            "btn_check":       {"ru":"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å","uk":"–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏","en":"Check"},
        }
        val = D.get(key, {}).get(lang) or D.get(key, {}).get("ru") or key
        return val.format(**fmt) if fmt else val

_SUPPORTED = {"ru", "uk", "en"}

def _lang_of(user_row: dict | None, obj: Message | CallbackQuery | None) -> str:
    if isinstance(user_row, dict) and user_row.get("lang"):
        l = (user_row["lang"] or "ru")[:2].lower()
    else:
        code = None
        if isinstance(obj, Message):
            code = getattr(getattr(obj, "from_user", None), "language_code", None)
        elif isinstance(obj, CallbackQuery):
            code = getattr(getattr(obj, "from_user", None), "language_code", None) or \
                   getattr(getattr(getattr(obj, "message", None), "from_user", None), "language_code", None)
        l = (code or getattr(settings, "default_locale", "ru"))[:2].lower()
    return "uk" if l == "ua" else (l if l in _SUPPORTED else "ru")

async def _ensure_cols(session: AsyncSession) -> None:
    try:
        await session.execute(sql_text("ALTER TABLE users ADD COLUMN premium_until TIMESTAMP"))
    except Exception:
        pass
    try:
        await session.execute(sql_text("ALTER TABLE users ADD COLUMN is_premium INTEGER DEFAULT 0"))
    except Exception:
        pass
    try:
        await session.commit()
    except Exception:
        await session.rollback()

async def _fetch_user(session: AsyncSession, tg_id: int) -> dict:
    await _ensure_cols(session)
    row = (await session.execute(sql_text(
        "SELECT id, tg_id, lang, is_premium, premium_until, tz FROM users WHERE tg_id=:tg"
    ), {"tg": tg_id})).first()
    if row:
        id_, tg, lang, is_premium, premium_until, tz = row
        return {"id": id_, "tg_id": tg, "lang": lang, "is_premium": bool(is_premium),
                "premium_until": premium_until, "tz": tz or getattr(settings, "default_tz", "Europe/Kyiv")}
    await session.execute(sql_text("INSERT INTO users (tg_id, lang, is_premium) VALUES (:tg, :lang, 0)"),
                          {"tg": tg_id, "lang": "ru"})
    await session.commit()
    return {"id": None, "tg_id": tg_id, "lang": "ru", "is_premium": False,
            "premium_until": None, "tz": getattr(settings, "default_tz", "Europe/Kyiv")}

def _aware(v) -> datetime | None:
    if v is None:
        return None
    if isinstance(v, datetime):
        return v if v.tzinfo else v.replace(tzinfo=timezone.utc)
    try:
        dt = datetime.fromisoformat(str(v).replace("Z", "+00:00"))
        return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)
    except Exception:
        return None

def _is_active(u: dict) -> bool:
    if not u.get("is_premium"):
        return False
    until = _aware(u.get("premium_until"))
    return True if until is None else (datetime.now(timezone.utc) < until)

def _fmt_local(dt_utc: datetime, tz_name: str) -> str:
    try:
        return dt_utc.astimezone(ZoneInfo(tz_name)).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return dt_utc.astimezone(ZoneInfo("Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")

def _pay_kb(lang: str, tg_id: int) -> InlineKeyboardMarkup:
    base = getattr(settings, "public_url", None) or os.environ.get("PUBLIC_URL", "").strip()
    if not base.startswith("https://"):
        base = "https://example.com"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t(lang, "btn_pay"), url=f"{base}/pay?tg_id={tg_id}")]
    ])

def _subscribe_kb(lang: str, tg_id: int) -> InlineKeyboardMarkup:
    base = getattr(settings, "public_url", "") or "https://example.com"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t(lang, "btn_sub"),   url=CHANNEL_URL)],
        [InlineKeyboardButton(text=t(lang, "btn_check"), callback_data="premium:check")],
        [InlineKeyboardButton(text=t(lang, "btn_pay"),   url=f"{base}/pay?tg_id={tg_id}")],
    ])

async def _grant_24h(session: AsyncSession, tg_id: int) -> None:
    until = datetime.now(timezone.utc) + timedelta(days=1)
    await session.execute(sql_text(
        "UPDATE users SET is_premium=1, premium_until=:u WHERE tg_id=:tg"
    ), {"u": until, "tg": tg_id})
    await session.commit()

# ===== Public API =====
async def maybe_grant_trial(session: AsyncSession, tg_id: int) -> None:
    u = await _fetch_user(session, tg_id)
    if not _is_active(u):
        await _grant_24h(session, tg_id)

# ===== Handlers =====
@router.message(or_f(Command("premium"), F.text.func(_is_premium_trigger)))
async def cmd_premium(m: Message, session: AsyncSession):
    u = await _fetch_user(session, m.from_user.id)
    lang = _lang_of(u, m)

    logger.info("premium_button hit: user=%s lang=%s text=%r", m.from_user.id, lang, m.text)

    if _is_active(u):
        until = _aware(u.get("premium_until"))
        if until:
            dt_local = _fmt_local(until, u.get("tz") or "Europe/Kyiv")
            await m.answer(t(lang, "premium_on_till", dt=dt_local, tz=(u.get("tz") or "Europe/Kyiv")),
                           reply_markup=get_main_kb(lang))
            return
        await m.answer(t(lang, "premium_on"), reply_markup=get_main_kb(lang))
        return

    await m.answer(t(lang, "subscribe_offer"), reply_markup=_subscribe_kb(lang, m.from_user.id))

@router.callback_query(F.data == "premium:check")
async def premium_check(c: CallbackQuery, session: AsyncSession):
    u = await _fetch_user(session, c.from_user.id)
    lang = _lang_of(u, c)

    try:
        cm = await c.bot.get_chat_member(CHANNEL_USERNAME, c.from_user.id)
        status = getattr(cm, "status", None)
        status = getattr(status, "value", status)
        is_member = str(status) in {"member", "administrator", "creator"}
    except Exception:
        is_member = False
    finally:
        try:
            await c.answer()
        except Exception:
            pass

    if is_member:
        await _grant_24h(session, c.from_user.id)
        await c.message.answer(t(lang, "sub_given"), reply_markup=get_main_kb(lang))
    else:
        await c.message.answer(t(lang, "sub_not_found"),
                               reply_markup=_subscribe_kb(lang, c.from_user.id))
==========================================================================================
# locales/ru.json
==========================================================================================
{
  "premium_inactive": "–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –û—Ñ–æ—Ä–º–∏ –ø–æ–¥–ø–∏—Å–∫—É –∏–ª–∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π –ø—Ä–æ–±–Ω—ã–π –¥–µ–Ω—å.",
  "menu_premium": "üíé –ü—Ä–µ–º–∏—É–º",
  "menu_lang": "üåê –Ø–∑—ã–∫",
  "menu_policy": "üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
  "menu_bug": "üõ† –°–æ–æ–±—â–∏—Ç—å –æ –±–∞–≥–µ",
  "med_choose": "–í—ã–±–µ—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –º–µ–¥–∏—Ç–∞—Ü–∏–∏:",
  "med_started": "–ú–µ–¥–∏—Ç–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ {mins} –º–∏–Ω.",
  "med_finished": "–ú–µ–¥–∏—Ç–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ö–∞–∫ –æ—â—É—â–µ–Ω–∏—è? –ù–∞–ø–∏—à–∏ /journal",
  "cal_send": "–ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ –∏–ª–∏ —Ç–µ–∫—Å—Ç —Å —Å–æ—Å—Ç–∞–≤–æ–º –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä: \"–º–æ–ª–æ–∫–æ 300 –º–ª, –∞—Ä–∞—Ö–∏—Å 40 –≥, –±–∞–Ω–∞–Ω 120 –≥\").",
  "cal_total": "–ò—Ç–æ–≥–æ: {kcal} –∫–∫–∞–ª ‚Äî –ë:{p} –≥ –ñ:{f} –≥ –£:{c} –≥",
  "chat_on": "–†–µ–∂–∏–º –æ–±—â–µ–Ω–∏—è –≤–∫–ª—é—á—ë–Ω.",
  "chat_off": "–†–µ–∂–∏–º –æ–±—â–µ–Ω–∏—è –≤—ã–∫–ª—é—á–µ–Ω.",
  "chat_hint": "–ú–æ–∂–µ—à—å —Å–ø—Ä–æ—Å–∏—Ç—å: ¬´—á—Ç–æ –Ω–∞–¥–µ—Ç—å —Å–µ–≥–æ–¥–Ω—è?¬ª –∏–ª–∏ –ø—Ä–∏—Å–ª–∞—Ç—å —Ñ–æ—Ç–æ.",
  "chat_reply_generic": "–Ø –±—ã –≤—ã–±—Ä–∞–ª —Å–∏–Ω—é—é –∫–æ—Ñ—Ç—É –∏ —Ç—ë–º–Ω—ã–µ –¥–∂–∏–Ω—Å—ã ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ –∏ —É–º–µ—Å—Ç–Ω–æ.",
  "music_hello": "–ü—Ä–∏—à–ª–∏ –∞—É–¥–∏–æ, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –≤ –ø–ª–µ–π–ª–∏—Å—Ç –º–µ–¥–∏—Ç–∞—Ü–∏–∏. –ö–æ–º–∞–Ω–¥–∞: /music ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç—Ä–µ–∫–∏.",
  "music_saved": "–°–æ—Ö—Ä–∞–Ω—ë–Ω —Ç—Ä–µ–∫: {title}",
  "music_list_empty": "–ü–æ–∫–∞ –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤.",
  "music_list": "–¢–≤–æ–∏ —Ç—Ä–µ–∫–∏:\n{items}"
}

==========================================================================================
# locales/uk.json
==========================================================================================
{
  "premium_inactive": "–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –û—Ñ–æ—Ä–º–∏ –ø—ñ–¥–ø–∏—Å–∫—É –∞–±–æ –∞–∫—Ç–∏–≤—É–π –ø—Ä–æ–±–Ω–∏–π –¥–µ–Ω—å.",
  "menu_premium": "üíé –ü—Ä–µ–º—ñ—É–º",
  "menu_lang": "üåê –ú–æ–≤–∞",
  "menu_policy": "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
  "menu_bug": "üõ† –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
  "med_choose": "–û–±–µ—Ä–∏ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –º–µ–¥–∏—Ç–∞—Ü—ñ—ó:",
  "med_started": "–ú–µ–¥–∏—Ç–∞—Ü—ñ—è –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ {mins} —Ö–≤.",
  "med_finished": "–ú–µ–¥–∏—Ç–∞—Ü—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –Ø–∫ –≤—ñ–¥—á—É—Ç—Ç—è? –ù–∞–ø–∏—à–∏ /journal",
  "cal_send": "–ù–∞–¥—ñ—à–ª–∏ —Ñ–æ—Ç–æ –∞–±–æ —Ç–µ–∫—Å—Ç –∑—ñ —Å–∫–ª–∞–¥–æ–º —Ç–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—é (–Ω–∞–ø—Ä.: \"–º–æ–ª–æ–∫–æ 300 –º–ª, –∞—Ä–∞—Ö—ñ—Å 40 –≥, –±–∞–Ω–∞–Ω 120 –≥\").",
  "cal_total": "–†–∞–∑–æ–º: {kcal} –∫–∫–∞–ª ‚Äî –ë:{p} –≥ –ñ:{f} –≥ –í:{c} –≥",
  "chat_on": "–†–µ–∂–∏–º —Å–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è —É–≤—ñ–º–∫–Ω–µ–Ω–æ.",
  "chat_off": "–†–µ–∂–∏–º —Å–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω–æ.",
  "chat_hint": "–ú–æ–∂–µ—à —Å–ø–∏—Ç–∞—Ç–∏: \"—è–∫–∏–π –ª—É–∫ –≤–¥—è–≥—Ç–∏ —Å—å–æ–≥–æ–¥–Ω—ñ?\" –∞–±–æ –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ñ–æ—Ç–æ.",
  "chat_reply_generic": "–Ø –± –æ–±—Ä–∞–≤ —Å–∏–Ω—é –∫–æ—Ñ—Ç—É —Ç–∞ —Ç–µ–º–Ω—ñ –¥–∂–∏–Ω—Å–∏ ‚Äî —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–æ —ñ –¥–æ—Ä–µ—á–Ω–æ.",
  "music_hello": "–ù–∞–¥—ñ—à–ª–∏ –∞—É–¥—ñ–æ, —â–æ–± –¥–æ–¥–∞—Ç–∏ —É –ø–ª–µ–π–ª–∏—Å—Ç –º–µ–¥–∏—Ç–∞—Ü—ñ—ó. –ö–æ–º–∞–Ω–¥–∞: /music ‚Äî –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Ç—Ä–µ–∫–∏.",
  "music_saved": "–ó–±–µ—Ä–µ–∂–µ–Ω–æ —Ç—Ä–µ–∫: {title}",
  "music_list_empty": "–ü–æ–∫–∏ —â–æ –Ω–µ–º–∞—î —Ç—Ä–µ–∫—ñ–≤.",
  "music_list": "–¢–≤–æ—ó —Ç—Ä–µ–∫–∏:\n{items}"
}

==========================================================================================
# migrations/env.py
==========================================================================================
from __future__ import annotations
from logging.config import fileConfig
from alembic import context
from sqlalchemy.ext.asyncio import async_engine_from_config
from sqlalchemy import pool
from app.config import settings
target_metadata = None
config = context.config
config.set_main_option("sqlalchemy.url", settings.database_url)
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
def run_migrations_offline():
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url, target_metadata=target_metadata, literal_binds=True, dialect_opts={"paramstyle": "named"})
    with context.begin_transaction():
        context.run_migrations()
def run_migrations_online():
    connectable = async_engine_from_config(config.get_section(config.config_ini_section), prefix="sqlalchemy.", poolclass=pool.NullPool)
    async def do_run_migrations(connection):
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()
    import asyncio
    async def runner():
        async with connectable.connect() as conn:
            await do_run_migrations(conn)
    asyncio.run(runner())
if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

==========================================================================================
# migrations/versions/b0b54fc02dab_payments_table.py
==========================================================================================
"""payments table

Revision ID: b0b54fc02dab
Revises: 
Create Date: 2025-11-14 00:16:30.016965

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'b0b54fc02dab'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    pass


def downgrade() -> None:
    """Downgrade schema."""
    pass

==========================================================================================
# project_snapshot_20251129_012749.txt
==========================================================================================
# Project snapshot @ 2025-11-29 01:27:49
PWD: /Users/sverepov/Desktop/Projects/diary-bot

## Files (82):
.backup_20251114153210/app/handlers/language.py
.backup_20251114153210/app/handlers/premium.py
.backup_20251114153210/app/keyboards.py
.backup_20251114153210/app/services/nlp.py
.backup_20251114153210/app/services/reminders.py
.env
alembic.ini
app.py
app/__init__.py
app/api.py
app/api/__init__.py
app/api/coinbase.py
app/bot.py
app/commands.py
app/config.py
app/db/__init__.py
app/db/core.py
app/db/session.py
app/db_conflict.py
app/features/__init__.py
app/features/calories.py
app/features/chat_mode.py
app/features/meditation.py
app/features/music.py
app/handlers/__init__.py
app/handlers/common.py
app/handlers/erase.py
app/handlers/export.py
app/handlers/journal.py
app/handlers/language.py
app/handlers/premium.py
app/handlers/privacy.py
app/handlers/reminders.py
app/handlers/report.py
app/handlers/start.py
app/hooks.py
app/http.py
app/i18n.py
app/i18n/en.json
app/i18n/ru.json
app/i18n/uk.json
app/keyboards.py
app/main.py
app/middlewares/lang.py
app/models.py
app/models/__init__.py
app/models/bug_report.py
app/models/journal.py
app/models/mixins.py
app/models/payment.py
app/models/reminder.py
app/models/user.py
app/payments/__init__.py
app/payments/coinbase_webhook.py
app/payments/now.py
app/payments/nowp.py
app/payments/nowpayments.py
app/scheduler.py
app/services/__init__.py
app/services/exporter.py
app/services/i18n.py
app/services/nlp.py
app/services/payments.py
app/services/payments/__init__.py
app/services/payments/coinbase.py
app/services/reminders.py
app/texts.py
app/urls.py
app/web.py
app/webhooks/__init__.py
app/webhooks/coinbase.py
locales/ru.json
locales/uk.json
migrations/env.py
migrations/versions/b0b54fc02dab_payments_table.py
README.md
requirements.txt
scripts/dev.env
scripts_msgfmt.py
storage/music/319145673/index.json
storage/music/377555215/index.json
storage/music/6657238126/index.json

==========================================================================================
# .backup_20251114153210/app/handlers/language.py
==========================================================================================
# app/handlers/language.py
from __future__ import annotations

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.keyboards import get_main_kb, LANGUAGE_LABELS
from app.models.user import User

router = Router()

# –†–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ –∫–æ–¥—ã (–≤–≤–æ–¥ RU/UK/UA/EN -> —Å–æ—Ö—Ä–∞–Ω—è–µ–º ru/uk/en)
LANGS = {"RU": "ru", "UK": "uk", "UA": "uk", "EN": "en"}

PROMPTS = {
    "ru": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫: RU / UK / EN (–æ—Ç–ø—Ä–∞–≤—å –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º)",
    "uk": "–í–∏–±–µ—Ä–∏ –º–æ–≤—É: RU / UK / EN (–≤—ñ–¥–ø—Ä–∞–≤ –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º)",
    "en": "Choose language: RU / UK / EN (send one word)",
}

def _pick_locale(user: User | None) -> str:
    loc = (user.locale if user and getattr(user, "locale", None) else "ru")
    return loc if loc in PROMPTS else "ru"

async def _get_or_create_user(session: AsyncSession, tg_id: int) -> User:
    user = (await session.execute(
        select(User).where(User.tg_id == tg_id)
    )).scalar_one_or_none()
    if not user:
        user = User(tg_id=tg_id, locale="ru")
        session.add(user)
        await session.flush()
    return user

# –û—Ç–∫—Ä—ã—Ç—å –≤—ã–±–æ—Ä —è–∑—ã–∫–∞: /language
@router.message(Command("language"))
async def language_cmd(m: Message, session: AsyncSession):
    user = await _get_or_create_user(session, m.from_user.id)
    await m.answer(PROMPTS[_pick_locale(user)], reply_markup=None)

# –û—Ç–∫—Ä—ã—Ç—å –≤—ã–±–æ—Ä —è–∑—ã–∫–∞: –ø–æ –∫–Ω–æ–ø–∫–µ –∏–∑ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é (—Å —ç–º–æ–¥–∑–∏)
@router.message(F.text.in_(LANGUAGE_LABELS))
async def language_btn(m: Message, session: AsyncSession):
    user = await _get_or_create_user(session, m.from_user.id)
    await m.answer(PROMPTS[_pick_locale(user)], reply_markup=None)

# –û—Ç–∫—Ä—ã—Ç—å –≤—ã–±–æ—Ä —è–∑—ã–∫–∞: –µ—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –≤—Ä—É—á–Ω—É—é –Ω–∞–ø–∏—Å–∞–ª "language|—è–∑—ã–∫|–º–æ–≤–∞"
@router.message(F.text.regexp(r"(?i)^\s*(language|—è–∑—ã–∫|–º–æ–≤–∞)\s*$"))
async def language_word(m: Message, session: AsyncSession):
    user = await _get_or_create_user(session, m.from_user.id)
    await m.answer(PROMPTS[_pick_locale(user)], reply_markup=None)

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —è–∑—ã–∫–∞ –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º: RU/UK/UA/EN (—Ä–µ–≥–∏—Å—Ç—Ä –Ω–µ–≤–∞–∂–µ–Ω)
@router.message(F.text.regexp(r"(?i)^\s*(ru|uk|ua|en)\s*$"))
async def language_set(m: Message, session: AsyncSession):
    code = LANGS.get(m.text.strip().upper(), "ru")

    user = await _get_or_create_user(session, m.from_user.id)
    if user.locale != code:
        user.locale = code
        session.add(user)
        await session.commit()

    msg = {
        "ru": "–ì–æ—Ç–æ–≤–æ. –Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª—ë–Ω.",
        "uk": "–ì–æ—Ç–æ–≤–æ. –ú–æ–≤—É –æ–Ω–æ–≤–ª–µ–Ω–æ.",
        "en": "Done. Language updated.",
    }.get(code, "Done.")
    await m.answer(msg, reply_markup=get_main_kb(code))
==========================================================================================
# .backup_20251114153210/app/handlers/premium.py
==========================================================================================
# app/handlers/premium.py
from aiogram import Router
from aiogram.filters import Command
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo

from app.models.user import User
from app.models.journal import JournalEntry
from app.models.reminder import Reminder
from app.config import settings

from app.services.payments.coinbase import create_coinbase_charge, build_pay_kb

router = Router()

TEXTS = {
    "ru": {
        "trial_on":  "üéÅ –ü–æ–¥–∞—Ä–æ–∫: {hours} —á –ü—Ä–µ–º–∏—É–º–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã! –î–æ—Å—Ç—É–ø–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã.",
        "status_on": "üíé –ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {until} ({tz}). –¶–µ–Ω–∞ –ø–æ—Å–ª–µ ‚Äî ${price}/–º–µ—Å.",
        "status_off":"–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. ${price}/–º–µ—Å. –û—Ç–∫—Ä–æ—é—Ç—Å—è —ç–∫—Å–ø–æ—Ä—Ç –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã.",
        "start":     "/start",
    },
    "uk": {
        "trial_on":  "üéÅ –ü–æ–¥–∞—Ä—É–Ω–æ–∫: –ü—Ä–µ–º—ñ—É–º –Ω–∞ {hours} –≥–æ–¥ –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ! –î–æ—Å—Ç—É–ø–Ω—ñ –µ–∫—Å–ø–æ—Ä—Ç —ñ —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ –∑–≤—ñ—Ç–∏.",
        "status_on": "üíé –ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {until} ({tz}). –î–∞–ª—ñ ‚Äî ${price}/–º—ñ—Å.",
        "status_off":"–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. ${price}/–º—ñ—Å. –í—ñ–¥–∫—Ä–∏—é—Ç—å—Å—è –µ–∫—Å–ø–æ—Ä—Ç —ñ —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ –∑–≤—ñ—Ç–∏.",
        "start":     "/start",
    },
    "en": {
        "trial_on":  "üéÅ Gift: Premium for {hours}h activated! Export & advanced reports unlocked.",
        "status_on": "üíé Premium is active until {until} ({tz}). After that ‚Äî ${price}/mo.",
        "status_off":"Premium is inactive. ${price}/mo. Export & advanced reports will be available.",
        "start":     "/start",
    },
}

def _t(lang: str, key: str, **kw) -> str:
    return TEXTS.get(lang, TEXTS["ru"]).get(key, key).format(**kw)

def _pick_lang(user: User | None, fallback: str = None) -> str:
    loc = (getattr(user, "locale", None) or fallback or settings.default_locale or "ru").lower()
    return loc if loc in TEXTS else "ru"

def is_premium_active(user: User, now: datetime | None = None) -> bool:
    now = now or datetime.now(timezone.utc)
    return bool(user.premium_until and user.premium_until > now)

async def maybe_grant_trial(session: AsyncSession, user: User, bot) -> None:
    """
    –î–∞—ë–º —Ç—Ä–∏–∞–ª 1 —Ä–∞–∑, –∫–æ–≥–¥–∞ —É —é–∑–µ—Ä–∞ ‚â•2 –∑–∞–ø–∏—Å–µ–π –∏ ‚â•1 –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.
    –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–µ—Ä—ë—Ç—Å—è –∏–∑ settings.premium_trial_hours.
    """
    if user.premium_trial_granted:
        return

    j_count = (await session.execute(
        select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
    )).scalar() or 0

    r_count = (await session.execute(
        select(func.count()).select_from(Reminder).where(Reminder.user_id == user.id)
    )).scalar() or 0

    if j_count < 2 or r_count < 1:
        return

    user.premium_trial_granted = True
    user.premium_until = datetime.now(timezone.utc) + timedelta(hours=settings.premium_trial_hours)
    session.add(user)
    await session.commit()

    lang = _pick_lang(user)
    try:
        await bot.send_message(
            user.tg_id,
            _t(lang, "trial_on", hours=settings.premium_trial_hours),
        )
    except Exception:
        pass

@router.message(Command("premium"))
async def premium_status(m: Message, session: AsyncSession, lang: str | None = None):
    res = await session.execute(select(User).where(User.tg_id == m.from_user.id))
    user = res.scalar_one_or_none()
    if not user:
        return await m.answer(_t("ru", "start"))

    lang = lang or _pick_lang(user)

    if is_premium_active(user):
        try:
            tz = ZoneInfo(user.tz or settings.default_tz)
        except Exception:
            tz = ZoneInfo(settings.default_tz)
        local_until = user.premium_until.astimezone(tz)
        await m.answer(
            _t(
                lang,
                "status_on",
                until=local_until.strftime("%Y-%m-%d %H:%M"),
                tz=(user.tz or settings.default_tz),
                price=settings.premium_price_usd,
            )
        )
    else:
        await m.answer(_t(lang, "status_off", price=settings.premium_price_usd))

def _tr(lang: str, ru: str, uk: str, en: str) -> str:
    if lang == "uk":
        return uk
    if lang == "en":
        return en
    return ru

from sqlalchemy import select
from app.models.user import User

@router.message(Command("buy"))
async def premium_buy(m: Message, session: AsyncSession, lang: str | None = None):
    user = (await session.execute(select(User).where(User.tg_id == m.from_user.id))).scalar_one_or_none()
    if not user:
        return await m.answer("/start")
    lang = lang or (getattr(user, "locale", None) or "ru")
    price = settings.premium_price_usd
    try:
        pay, hosted = await create_coinbase_charge(session=session, user=user, plan="monthly", amount_usd=price, description="Diary Assistant Premium ‚Äî 1 month")
    except Exception:
        return await m.answer(_tr(lang, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á—ë—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", "–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ —Ä–∞—Ö—É–Ω–∫—É. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.", "Failed to create invoice. Try again later."))
    await m.answer(_tr(lang, f"–ü—Ä–µ–º–∏—É–º –Ω–∞ 30 –¥–Ω–µ–π ‚Äî ${price}. –ù–∞–∂–º–∏, —á—Ç–æ–±—ã –æ–ø–ª–∞—Ç–∏—Ç—å:", f"–ü—Ä–µ–º—ñ—É–º –Ω–∞ 30 –¥–Ω—ñ–≤ ‚Äî ${price}. –ù–∞—Ç–∏—Å–Ω–∏, —â–æ–± –æ–ø–ª–∞—Ç–∏—Ç–∏:", f"Premium for 30 days ‚Äî ${price}. Tap to pay:"), reply_markup=build_pay_kb(hosted))

==========================================================================================
# .backup_20251114153210/app/keyboards.py
==========================================================================================
# app/keyboards.py
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

# –¢–µ–∫—Å—Ç—ã –∫–Ω–æ–ø–æ–∫ –ø–æ –ª–æ–∫–∞–ª—è–º
_LOCALE_TEXTS = {
    "ru": {
        "language": "üåê –Ø–∑—ã–∫",
        "privacy":  "üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
        "report":   "üõ†Ô∏è –°–æ–æ–±—â–∏—Ç—å –æ–± –æ—à–∏–±–∫–µ",
        "premium":  "üíé –ü—Ä–µ–º–∏—É–º",
        "journal":  "üìù –ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å",
        "reminder": "‚è∞ –°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ",
        "stats":    "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        "placeholder": "–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ‚Ä¶",
    },
    "uk": {
        "language": "üåê –ú–æ–≤–∞",
        "privacy":  "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
        "report":   "üõ†Ô∏è –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
        "premium":  "üíé –ü—Ä–µ–º—ñ—É–º",
        "journal":  "üìù –ù–æ–≤–∏–π –∑–∞–ø–∏—Å",
        "reminder": "‚è∞ –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è",
        "stats":    "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        "placeholder": "–ù–∞–ø–∏—à—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è‚Ä¶",
    },
    "en": {
        "language": "üåê Language",
        "privacy":  "üîí Privacy",
        "report":   "üõ†Ô∏è Report bug",
        "premium":  "üíé Premium",
        "journal":  "üìù New entry",
        "reminder": "‚è∞ Create reminder",
        "stats":    "üìä Stats",
        "placeholder": "Write a message‚Ä¶",
    },
}

def _build_kb(loc: str) -> ReplyKeyboardMarkup:
    t = _LOCALE_TEXTS.get(loc, _LOCALE_TEXTS["ru"])
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=t["journal"]), KeyboardButton(text=t["reminder"])],
            [KeyboardButton(text=t["stats"]),   KeyboardButton(text=t["premium"])],
            [KeyboardButton(text=t["language"]), KeyboardButton(text=t["privacy"])],
            [KeyboardButton(text=t["report"])],
        ],
        resize_keyboard=True,
        input_field_placeholder=t["placeholder"],
    )

def get_main_kb(locale: str | None):
    """–í–µ—Ä–Ω—É—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –ø–æ –ª–æ–∫–∞–ª–∏ ('ru'|'uk'|'en')."""
    loc = (locale or "ru").lower()
    return _build_kb(loc)

# –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∏–º–ø–æ—Ä—Ç–æ–º
get_main_kb = get_main_kb

# –ù–∞–±–æ—Ä—ã –ª–µ–π–±–ª–æ–≤ (–¥–ª—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö)
PRIVACY_LABELS  = { _LOCALE_TEXTS[k]["privacy"]  for k in _LOCALE_TEXTS }
LANGUAGE_LABELS = { _LOCALE_TEXTS[k]["language"] for k in _LOCALE_TEXTS }
REPORT_LABELS   = { _LOCALE_TEXTS[k]["report"]   for k in _LOCALE_TEXTS }
PREMIUM_LABELS  = { _LOCALE_TEXTS[k]["premium"]  for k in _LOCALE_TEXTS }
JOURNAL_LABELS  = { _LOCALE_TEXTS[k]["journal"]  for k in _LOCALE_TEXTS }
REMINDER_LABELS = { _LOCALE_TEXTS[k]["reminder"] for k in _LOCALE_TEXTS }
STATS_LABELS    = { _LOCALE_TEXTS[k]["stats"]    for k in _LOCALE_TEXTS }

# –£–¥–æ–±–Ω—ã–µ —Ö–µ–ª–ø–µ—Ä—ã
def is_privacy_btn(text: str)  -> bool: return (text or "").strip() in PRIVACY_LABELS
def is_language_btn(text: str) -> bool: return (text or "").strip() in LANGUAGE_LABELS
def is_report_btn(text: str)   -> bool: return (text or "").strip() in REPORT_LABELS
def is_premium_btn(text: str)  -> bool: return (text or "").strip() in PREMIUM_LABELS
def is_journal_btn(text: str)  -> bool: return (text or "").strip() in JOURNAL_LABELS
def is_reminder_btn(text: str) -> bool: return (text or "").strip() in REMINDER_LABELS
def is_stats_btn(text: str)    -> bool: return (text or "").strip() in STATS_LABELS
==========================================================================================
# .backup_20251114153210/app/services/nlp.py
==========================================================================================
from __future__ import annotations

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, time
from typing import Optional, Literal, List
from zoneinfo import ZoneInfo

# =======================
# Public API
# =======================

@dataclass
class ParsedReminder:
    """
    –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ–∑–¥–∞–Ω–∏—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.
    - –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ: next_run_utc –∑–∞–ø–æ–ª–Ω–µ–Ω
    - –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–µ—Å—è: cron –∑–∞–ø–æ–ª–Ω–µ–Ω (—Ñ–æ—Ä–º–∞—Ç CRON: "m h d * dow")
    """
    what: str
    raw_when: str
    next_run_utc: Optional[datetime] = None
    cron: Optional[str] = None


@dataclass
class ToggleRequest:
    """
    –ó–∞–ø—Ä–æ—Å –Ω–∞ –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.
    - action: 'enable' | 'disable'
    - query: —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è (case-insensitive), –µ—Å–ª–∏ –∞–¥—Ä–µ—Å–Ω–æ–µ
    - all: true, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∫–æ –≤—Å–µ–º
    """
    action: Literal["enable", "disable"]
    query: Optional[str] = None
    all: bool = False


@dataclass
class ParseResult:
    """
    –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ª—é–±–æ–π NLP-–∫–æ–º–∞–Ω–¥—ã:
      - intent: 'create' | 'enable' | 'disable'
      - reminder: –¥–ª—è intent='create'
      - toggle:   –¥–ª—è intent in {'enable','disable'}
    """
    intent: Literal["create", "enable", "disable"]
    reminder: Optional[ParsedReminder] = None
    toggle: Optional[ToggleRequest] = None


def parse_any(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParseResult]:
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å:
      1) –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ (enable/disable)
      2) —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (create)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ParseResult –∏–ª–∏ None.
    """
    tgl = parse_toggle(text)
    if tgl:
        return ParseResult(intent=tgl.action, toggle=tgl)

    rem = parse_remind(text, user_tz=user_tz, now=now)
    if rem:
        return ParseResult(intent="create", reminder=rem)

    return None


# =======================
# Reminder create (RU/UK/EN)
# =======================

def parse_remind(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParsedReminder]:
    """
    –ü–æ–Ω–∏–º–∞–µ—Ç:
      RU:  "–Ω–∞–ø–æ–º–Ω–∏ –ø–æ–∑–≤–æ–Ω–∏—Ç—å –º–∞–º–µ —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç"
           "–Ω–∞–ø–æ–º–Ω–∏ –æ–ø–ª–∞—Ç–∏—Ç—å —Å—á–µ—Ç –∑–∞–≤—Ç—Ä–∞ –≤ 09:30"
           "–Ω–∞–ø–æ–º–Ω–∏ —Ç—Ä–µ–Ω—é –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 7:00"
           "–Ω–∞–ø–æ–º–Ω–∏ –≤–æ–¥—É –ø–æ –±—É–¥–Ω—è–º –≤ 10"
           "–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç –∫–∞–∂–¥—É—é —Å—Ä–µ–¥—É –≤ 18:30"
           "–Ω–∞–ø–æ–º–Ω–∏ —É–±–æ—Ä–∫—É –ø–æ –≤—ã—Ö–æ–¥–Ω—ã–º –≤ 12"
           "–Ω–∞–ø–æ–º–Ω–∏ –ø–ª–∞—Ç–µ–∂ –∫–∞–∂–¥–æ–≥–æ 5-–≥–æ —á–∏—Å–ª–∞ –≤ 10"
      UK:  "–Ω–∞–≥–∞–¥–∞–π –º–µ–Ω—ñ –≤–æ–¥—É —â–æ–¥–Ω—è –æ 9", "—É –≤–∏—Ö—ñ–¥–Ω—ñ –æ 12", "—â–æ–º—ñ—Å—è—Ü—è 5 —á–∏—Å–ª–∞ –æ 10"
      EN:  "remind me to call mom in 2 hours", "every wednesday at 6:30pm",
           "weekends at noon", "every month on the 5th at 10"
    """
    tz = ZoneInfo(user_tz)
    now = now or datetime.now(tz)

    text_norm = _normalize(text)

    # –°–Ω–∞—á–∞–ª–∞ ‚Äî –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è (cron)
    cron = _parse_recurring_cron(text_norm)
    if cron:
        what = _extract_what(text_norm, recurring=True)
        if not what:
            return None
        return ParsedReminder(what=what, raw_when=text.strip(), cron=cron)

    # –û–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–µ
    dt = _parse_once_datetime(text_norm, now, tz)
    if dt:
        what = _extract_what(text_norm, recurring=False)
        if not what:
            return None
        return ParsedReminder(
            what=what,
            raw_when=text.strip(),
            next_run_utc=dt.astimezone(ZoneInfo("UTC")),
        )

    return None


# =======================
# Toggle (enable/disable)
# =======================

_TOGGLE_ON_WORDS  = r"(?:–≤–∫–ª—é—á–∏|–≤–∫–ª|—É–≤—ñ–º–∫–Ω–∏|—É–≤—ñ–º–∫|on|enable)"
_TOGGLE_OFF_WORDS = r"(?:–≤—ã–∫–ª—é—á–∏|–≤—ã–∫–ª|–≤—ñ–¥–∫–ª—é—á–∏|–≤–∏–º–∫–Ω–∏|–≤–∏–º–∫|off|disable)"
_REMINDER_WORDS = r"(?:–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏(?:–µ|—è)|–Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è|reminder(?:s)?)"
_ALL_WORDS = r"(?:–≤—Å–µ|—É—Å—ñ|–≤—Å—ñ|all)"

_RE_TOGGLE = re.compile(
    rf"(?i)\b(?P<act>{_TOGGLE_ON_WORDS}|{_TOGGLE_OFF_WORDS})\b"
    rf"(?:\s+{_REMINDER_WORDS})?"
    rf"(?:\s+(?:–ø—Ä–æ|–Ω–∞|–ø–æ|about|for))?"
    rf"(?:\s+(?P<all>{_ALL_WORDS}))?"
    rf"(?:\s*(?P<query>.+))?$"
)

def parse_toggle(text: str) -> Optional[ToggleRequest]:
    """–ü–∞—Ä—Å–∏—Ç –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π (RU/UK/EN)."""
    s = _normalize(text)
    m = _RE_TOGGLE.match(s)
    if not m:
        return None

    act = m.group("act")
    action: Literal["enable", "disable"] = "enable" if re.search(rf"^{_TOGGLE_ON_WORDS}$", act, flags=re.I) else "disable"

    is_all = bool(m.group("all") and m.group("all").strip())
    query = (m.group("query") or "").strip()

    if is_all:
        return ToggleRequest(action=action, query=None, all=True)
    if not query:
        return ToggleRequest(action=action, query=None, all=True)

    return ToggleRequest(action=action, query=query, all=False)


# =======================
# Internals
# =======================

# –¢—Ä–∏–≥–≥–µ—Ä—ã —Å–æ–∑–¥–∞–Ω–∏—è
_TRIGGERS = r"(?:–Ω–∞–ø–æ–º–Ω–∏|–Ω–∞–≥–∞–¥–∞–π|remind(?:\s+me\s+to)?)"

# –°–ª—É–∂–µ–±–Ω—ã–µ ¬´—Å—Ü–µ–ø–∫–∏¬ª
_RE_IN = r"(?:—á–µ—Ä–µ–∑|–∑–∞|in)"
_RE_AT = r"(?:–≤|–æ|at|on)"  # 'on' –¥–ª—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π 'on Monday at 6pm'
_RE_TODAY = r"(?:—Å–µ–≥–æ–¥–Ω—è|—Å—å–æ–≥–æ–¥–Ω—ñ|today)"
_RE_TOMORROW = r"(?:–∑–∞–≤—Ç—Ä–∞|tomorrow)"
_RE_EVERY = r"(?:–∫–∞–∂–¥\w+|—â–æ–¥–Ω—è|—â–æ—Ç–∏–∂–Ω—è|—â–æ—Å\w+|every|weekdays|daily|–µ–∂–µ–¥–Ω–µ–≤–Ω–æ)"

# –î–Ω–∏ –Ω–µ–¥–µ–ª–∏
_DOW_MAP = {
    # RU
    "–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫": 1, "–≤—Ç–æ—Ä–Ω–∏–∫": 2, "—Å—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä–≥": 4, "–ø—è—Ç–Ω–∏—Ü–∞": 5, "—Å—É–±–±–æ—Ç–∞": 6, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ": 0, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω–∏–µ": 0,
    # UK
    "–ø–æ–Ω–µ–¥—ñ–ª–æ–∫": 1, "–≤—ñ–≤—Ç–æ—Ä–æ–∫": 2, "—Å–µ—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä": 4, "–ø º—è—Ç–Ω–∏—Ü—è": 5, "–ø'—è—Ç–Ω–∏—Ü—è": 5, "—Å—É–±–æ—Ç–∞": 6, "–Ω–µ–¥—ñ–ª—è": 0,
    # EN
    "monday": 1, "tuesday": 2, "wednesday": 3, "thursday": 4, "friday": 5, "saturday": 6, "sunday": 0,
}
_WEEKDAY_SET = set(_DOW_MAP.keys())

# –í—Ä–µ–º—è: "9", "9:05", "21:30", "6pm", "6:30pm", "–ø–æ–ª–Ω–æ—á—å", "–ø–æ–ª–¥–µ–Ω—å"
_RE_TIME = re.compile(r"\b(?P<h>\d{1,2})(?::(?P<m>\d{2}))?\s*(?P<ampm>am|pm)?\b", re.I)
_SPECIAL_TIME = {
    "–ø–æ–ª–¥–µ–Ω—å": (12, 0),
    "–ø–æ–ª—É–¥–µ–Ω—å": (12, 0),
    "noon": (12, 0),
    "–ø–æ–ª–Ω–æ—á—å": (0, 0),
    "–æ–ø—ñ–≤–Ω–æ—á—ñ": (0, 0),
    "midnight": (0, 0),
}

# –î–∞—Ç—ã
_RE_DATE_DOT = re.compile(r"\b(?P<d>\d{1,2})\.(?P<m>\d{1,2})(?:\.(?P<y>\d{4}))?\b")
_RE_DATE_ISO = re.compile(r"\b(?P<y>\d{4})-(?P<m>\d{1,2})-(?P<d>\d{1,2})\b")

# –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
_RE_REL = re.compile(
    rf"\b{_RE_IN}\s+"
    r"(?:(?P<hours>\d+)\s*(?:—á–∞—Å(?:–∞|–æ–≤)?|–≥–æ–¥(?:–∏–Ω–∏)?|h|hours?)\s*)?"
    r"(?:(?P<minutes>\d+)\s*(?:–º–∏–Ω—É—Ç(?:—ã)?|—Ö–≤(?:–∏–ª–∏–Ω)?|m|mins?|minutes?)\s*)?"
    r"(?:(?P<days>\d+)\s*(?:–¥–Ω(?:—è|–µ–π|—ñ–≤)?|days?)\s*)?"
    r"(?:(?P<weeks>\d+)\s*(?:–Ω–µ–¥–µ–ª(?:—è|–∏|—å)|—Ç–∏–∂–Ω(?:—ñ|—ñ–≤)|weeks?)\s*)?"
    r"\b",
    re.I,
)

# –ï–∂–µ–º–µ—Å—è—á–Ω—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏: "–∫–∞–∂–¥–æ–≥–æ 5-–≥–æ (—á–∏—Å–ª–∞) –≤ 10", "every month on the 5th at 10"
_RE_MONTHLY = re.compile(
    r"""(?ix)
    \b(?:
        –∫–∞–∂–¥—ã–π\s+–º–µ—Å—è—Ü|–∫–∞–∂–¥–æ–≥–æ\s+–º–µ—Å—è—Ü–∞|—â–æ–º—ñ—Å—è—Ü—è|every\s+month
    )\b
    (?:\s+(?:–Ω–∞|on))?
    (?:\s*(?:\b(?P<dom1>\d{1,2})(?:-?(?:–≥–æ|–µ|th|st|nd|rd))?\b|\b(?P<dom2>\d{1,2})\s+—á–∏—Å–ª–∞\b))?
    """,
)

# Weekends: "–ø–æ –≤—ã—Ö–æ–¥–Ω—ã–º", "–Ω–∞ –≤—ã—Ö–æ–¥–Ω—ã—Ö", "—É –≤–∏—Ö—ñ–¥–Ω—ñ", "–Ω–∞ –≤–∏—Ö—ñ–¥–Ω–∏—Ö", "weekends"
_RE_WEEKENDS = re.compile(r"\b(?:–ø–æ\s+–≤—ã—Ö–æ–¥–Ω(?:—ã–º|—ã—Ö)|–Ω–∞\s+–≤—ã—Ö–æ–¥–Ω—ã—Ö|—É\s+–≤–∏—Ö—ñ–¥–Ω—ñ|–Ω–∞\s+–≤–∏—Ö—ñ–¥–Ω–∏—Ö|weekends?)\b", re.I)

def _normalize(text: str) -> str:
    t = text.strip().lower()
    t = re.sub(r"\s+", " ", t)
    t = t.replace("‚Äô", "'")
    return t

def _extract_what(text_norm: str, recurring: bool) -> Optional[str]:
    """
    –ë–µ—Ä—ë–º –≤—Å—ë –ø–æ—Å–ª–µ —Ç—Ä–∏–≥–≥–µ—Ä–∞ –¥–æ –º–∞—Ä–∫–µ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏/–ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç–∏.
    """
    markers = [
        r"\b" + _RE_IN + r"\b",
        r"\b" + _RE_AT + r"\b",
        r"\b" + _RE_TODAY + r"\b",
        r"\b" + _RE_TOMORROW + r"\b",
        r"\b" + _RE_EVERY + r"\b",
        r"\b" + "|".join(map(re.escape, _WEEKDAY_SET)) + r"\b",
        r"\b–ø–æ –±—É–¥–Ω—è–º\b",
        r"\bweekdays\b",
        r"\bdaily\b",
        r"\b—â–æ–¥–Ω—è\b",
        r"\bweekends?\b",
        r"\b–ø–æ –≤—ã—Ö–æ–¥–Ω(?:—ã–º|—ã—Ö)\b",
        r"\b—â–æ–º—ñ—Å—è—Ü—è\b",
        r"\b–∫–∞–∂–¥—ã–π –º–µ—Å—è—Ü\b",
        r"\bevery month\b",
    ]
    m = re.search(rf"{_TRIGGERS}\s+(?:me\s+to\s+)?", text_norm)
    if not m:
        return None
    start = m.end()

    end = len(text_norm)
    for mk in markers:
        mm = re.search(mk, text_norm[start:])
        if mm:
            end = min(end, start + mm.start())

    what = text_norm[start:end].strip(" ,.;:‚Äî-\"'¬´¬ª")
    return what or None

def _parse_time_fragment(s: str) -> Optional[time]:
    # —Å–ø–µ—Ü-—Å–ª–æ–≤–∞
    for key, (hh, mm) in _SPECIAL_TIME.items():
        if re.search(rf"\b{re.escape(key)}\b", s, flags=re.I):
            return time(hour=hh, minute=mm)

    m = _RE_TIME.search(s)
    if not m:
        return None
    h = int(m.group("h"))
    mnt = int(m.group("m") or 0)
    ampm = (m.group("ampm") or "").lower()
    if ampm == "pm" and 1 <= h <= 11:
        h += 12
    if ampm == "am" and h == 12:
        h = 0
    if not (0 <= h <= 23 and 0 <= mnt <= 59):
        return None
    return time(hour=h, minute=mnt)

def _apply_time(base: datetime, t: time) -> datetime:
    return base.replace(hour=t.hour, minute=t.minute, second=0, microsecond=0)

def _parse_once_datetime(text_norm: str, now: datetime, tz: ZoneInfo) -> Optional[datetime]:
    # "—á–µ—Ä–µ–∑ X ..."
    m = _RE_REL.search(text_norm)
    if m and any(m.group(g) for g in ("minutes", "hours", "days", "weeks")):
        dt = now
        if m.group("minutes"): dt += timedelta(minutes=int(m.group("minutes")))
        if m.group("hours"):   dt += timedelta(hours=int(m.group("hours")))
        if m.group("days"):    dt += timedelta(days=int(m.group("days")))
        if m.group("weeks"):   dt += timedelta(weeks=int(m.group("weeks")))
        return dt

    # –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –¥–∞—Ç–∞
    date_dt = None
    mi = _RE_DATE_ISO.search(text_norm)
    md = _RE_DATE_DOT.search(text_norm)
    if mi:
        y, mo, d = int(mi.group("y")), int(mi.group("m")), int(mi.group("d"))
        date_dt = datetime(y, mo, d, tzinfo=tz)
    elif md:
        d, mo = int(md.group("d")), int(md.group("m"))
        y = int(md.group("y")) if md.group("y") else now.year
        date_dt = datetime(y, mo, d, tzinfo=tz)

    tm = _parse_time_fragment(text_norm)
    if date_dt:
        dt = _apply_time(date_dt, tm or time(9, 0))
        return dt

    # today / tomorrow
    if re.search(rf"\b{_RE_TODAY}\b", text_norm):
        dt = _apply_time(now, tm or time(9, 0))
        if tm is None and dt < now:
            dt = dt + timedelta(hours=1)
        return dt

    if re.search(rf"\b{_RE_TOMORROW}\b", text_norm):
        base = (now + timedelta(days=1)).replace(hour=9, minute=0, second=0, microsecond=0)
        if tm:
            base = _apply_time(base, tm)
        return base

    # –ø—Ä–æ—Å—Ç–æ "–≤ 14:30" ‚Äî –±–ª–∏–∂–∞–π—à–µ–µ —Ç–∞–∫–æ–µ –≤—Ä–µ–º—è
    if tm:
        dt = _apply_time(now, tm)
        if dt <= now:
            dt += timedelta(days=1)
        return dt

    return None

def _parse_recurring_cron(text_norm: str) -> Optional[str]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç cron:
      - daily / –∫–∞–∂–¥—ã–π –¥–µ–Ω—å / —â–æ–¥–Ω—è / –µ–∂–µ–¥–Ω–µ–≤–Ω–æ  -> "m h * * *"
      - weekdays / –ø–æ –±—É–¥–Ω—è–º                      -> "m h * * 1-5"
      - weekends / –ø–æ –≤—ã—Ö–æ–¥–Ω—ã–º                    -> "m h * * 6,0"
      - specific weekday(s)                       -> "m h * * dow[,dow...]"
      - monthly day-of-month                      -> "m h d * *"
    –¢—Ä–µ–±—É–µ—Ç —É–∫–∞–∑–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏.
    """
    tm = _parse_time_fragment(text_norm)
    if not tm:
        return None
    minute = tm.minute
    hour = tm.hour

    # daily
    if re.search(r"\b(daily|—â–æ–¥–Ω—è|–∫–∞–∂–¥—ã–π –¥–µ–Ω—å|–µ–∂–µ–¥–Ω–µ–≤–Ω–æ)\b", text_norm):
        return f"{minute} {hour} * * *"

    # weekdays
    if re.search(r"\b(weekdays|–ø–æ –±—É–¥–Ω—è–º)\b", text_norm):
        return f"{minute} {hour} * * 1-5"

    # weekends
    if _RE_WEEKENDS.search(text_norm):
        return f"{minute} {hour} * * 6,0"

    # monthly (every month on Nth ...)
    mm = _RE_MONTHLY.search(text_norm)
    if mm:
        dom_raw = mm.group("dom1") or mm.group("dom2")
        if dom_raw:
            d = int(dom_raw)
            if 1 <= d <= 31:
                return f"{minute} {hour} {d} * *"
        # –µ—Å–ª–∏ –¥–µ–Ω—å –Ω–µ —É–∫–∞–∑–∞–Ω, –Ω–µ —Å—Ç—Ä–æ–∏–º –∫—Ä–æ–Ω (—á—Ç–æ–±—ã –Ω–µ –≥–∞–¥–∞—Ç—å)

    # every/–∫–∞–∂–¥—É—é/—â–æ—Å–µ—Ä–µ–¥–∏ + weekday(s)
    if re.search(r"\b(–∫–∞–∂–¥\w+|—â–æ—Å\w+|every|on)\b", text_norm):
        dows = _find_all_weekdays(text_norm)
        if dows:
            unique = sorted(set(dows))
            dow_str = ",".join(str(x) for x in unique)
            return f"{minute} {hour} * * {dow_str}"

    # –ø—Ä–æ—Å—Ç–æ ¬´—Å—Ä–µ–¥—É –≤ 18:00¬ª (–±–µ–∑ "–∫–∞–∂–¥—É—é"), –ª–∏–±–æ "monday at 9"
    dows = _find_all_weekdays(text_norm)
    if dows and re.search(rf"\b{_RE_AT}\b", text_norm):
        unique = sorted(set(dows))
        dow_str = ",".join(str(x) for x in unique)
        return f"{minute} {hour} * * {dow_str}"

    return None

def _find_weekday(text_norm: str) -> Optional[int]:
    pos = -1
    val = None
    for name, dow in _DOW_MAP.items():
        m = re.search(rf"\b{name}\b", text_norm)
        if m and m.start() > pos:
            pos = m.start()
            val = dow
    return val

def _find_all_weekdays(text_norm: str) -> List[int]:
    """–ù–∞—Ö–æ–¥–∏—Ç –≤—Å–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –¥–Ω–µ–π –Ω–µ–¥–µ–ª–∏ –≤ —Å—Ç—Ä–æ–∫–µ (–¥–ª—è '–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –∏ —Å—Ä–µ–¥—É')."""
    found: List[int] = []
    for name, dow in _DOW_MAP.items():
        if re.search(rf"\b{name}\b", text_norm):
            found.append(dow)
    return found


__all__ = [
    "ParsedReminder",
    "ToggleRequest",
    "ParseResult",
    "parse_any",
    "parse_remind",
    "parse_toggle",
]
==========================================================================================
# .backup_20251114153210/app/services/reminders.py
==========================================================================================
# app/services/reminders.py
from __future__ import annotations

import asyncio
import logging
from datetime import datetime, timezone
from typing import Optional, Sequence, Tuple

from aiogram import Bot
from croniter import croniter
from sqlalchemy import select, and_, update
from sqlalchemy.ext.asyncio import AsyncSession
from zoneinfo import ZoneInfo

from app.models.reminder import Reminder
from app.models.user import User

log = logging.getLogger("reminders")

# –°–∫–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏–π –º–∞–∫—Å–∏–º—É–º –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞ –æ–¥–∏–Ω —Ç–∏–∫
SEND_LIMIT_PER_TICK = 100
# –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏, —á—Ç–æ–±—ã –±–µ—Ä–µ–∂–Ω–æ –æ—Ç–Ω–æ—Å–∏—Ç—å—Å—è –∫ –ª–∏–º–∏—Ç–∞–º Telegram
SEND_SLEEP_SECONDS = 0.03


async def compute_next_run(
    cron: Optional[str],
    from_dt_utc: datetime,
    user_tz: Optional[str] = "UTC",
) -> Optional[datetime]:
    """
    –í–µ—Ä–Ω—ë—Ç –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è (UTC) –ø–æ cron-–≤—ã—Ä–∞–∂–µ–Ω–∏—é, –∑–∞–¥–∞–Ω–Ω–æ–º—É –≤ –õ–û–ö–ê–õ–¨–ù–û–ú –≤—Ä–µ–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    """
    if not cron:
        return None
    try:
        tz = ZoneInfo(user_tz or "UTC")
        base_local = from_dt_utc.astimezone(tz)
        it = croniter(cron, base_local)
        next_local = datetime.fromtimestamp(it.get_next(), tz=tz)
        return next_local.astimezone(timezone.utc)
    except Exception as e:
        log.warning("compute_next_run failed for cron=%r tz=%r: %s", cron, user_tz, e)
        return None


async def _seed_missing_next_runs(session: AsyncSession, now_utc: datetime) -> int:
    """
    –ü—Ä–æ—Å—Ç–∞–≤–ª—è–µ—Ç next_run –≤—Å–µ–º –∞–∫—Ç–∏–≤–Ω—ã–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è–º, –≥–¥–µ –æ–Ω –µ—â—ë –ø—É—Å—Ç.
    """
    q = (
        select(Reminder.id, Reminder.cron, User.tz)
        .join(User, User.id == Reminder.user_id)
        .where(
            and_(
                Reminder.is_active.is_(True),
                Reminder.cron.is_not(None),
                Reminder.next_run.is_(None),
            )
        )
        .limit(500)
    )
    res = await session.execute(q)
    rows: Sequence[Tuple[int, str, Optional[str]]] = res.all()

    updated = 0
    for rid, cron_expr, tz in rows:
        nxt = await compute_next_run(cron_expr, now_utc, tz)
        if nxt:
            await session.execute(
                update(Reminder).where(Reminder.id == rid).values(next_run=nxt)
            )
            updated += 1

    if updated:
        await session.commit()
    return updated


async def tick_reminders(session: AsyncSession, bot: Bot, now: Optional[datetime] = None):
    """
    –û—Å–Ω–æ–≤–Ω–æ–π —Ç–∏–∫–µ—Ä:
      1) –î–æ—Å–µ—è—Ç—å next_run —Ç–∞–º, –≥–¥–µ –µ–≥–æ –Ω–µ—Ç —É –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏—Ö.
      2) –ó–∞–±—Ä–∞—Ç—å due-–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π (skip locked), —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –≤–æ—Ä–∫–µ—Ä–∞—Ö.
      3) –û—Ç–ø—Ä–∞–≤–∏—Ç—å, –ø–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å (cron) –∏–ª–∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å (one-shot).
    """
    now_utc = now or datetime.now(timezone.utc)

    # 1) —Å–∏–¥–¥–∏–Ω–≥
    try:
        await _seed_missing_next_runs(session, now_utc)
    except Exception as e:
        log.exception("seed_missing_next_runs failed: %s", e)

    # 2) –∑–∞–±–∏—Ä–∞–µ–º due –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π
    q = (
        select(Reminder, User.tg_id, User.tz)
        .join(User, User.id == Reminder.user_id)
        .where(
            and_(
                Reminder.is_active.is_(True),
                Reminder.next_run.is_not(None),
                Reminder.next_run <= now_utc,
            )
        )
        .order_by(Reminder.next_run.asc())
        .limit(SEND_LIMIT_PER_TICK)
        .with_for_update(skip_locked=True)
    )

    # –Ω–∞—á–∏–Ω–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é, —á—Ç–æ–±—ã –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∏–º–µ–ª–∞ —Å–º—ã—Å–ª
    async with session.begin():
        res = await session.execute(q)
        due: Sequence[Tuple[Reminder, int, Optional[str]]] = res.all()

        if not due:
            return

        for r, chat_id, tz in due:
            try:
                await bot.send_message(chat_id, f"üîî {r.title}")
            except Exception as send_err:
                # –ù–µ —Ñ–µ–π–ª–∏–º –≤–µ—Å—å —Ç–∏–∫ ‚Äî –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º
                log.warning("Failed to send reminder id=%s to %s: %s", r.id, chat_id, send_err)

            # –ü–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ/–¥–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è
            if r.cron:
                nxt = await compute_next_run(r.cron, now_utc, tz)
                if nxt:
                    r.next_run = nxt
                else:
                    r.is_active = False
                    r.next_run = None
            else:
                # –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ ‚Äî –≤—ã–∫–ª—é—á–∞–µ–º –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
                r.is_active = False
                r.next_run = None

            session.add(r)
            await asyncio.sleep(SEND_SLEEP_SECONDS)
        # –ö–æ–º–º–∏—Ç –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –ø–æ –≤—ã—Ö–æ–¥—É –∏–∑ context manager
==========================================================================================
# .env
==========================================================================================
TG_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
TELEGRAM_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
PUBLIC_URL=https://ilda-comelier-pliantly.ngrok-free.dev

==========================================================================================
# alembic.ini
==========================================================================================
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the tzdata library which can be installed by adding
# `alembic[tz]` to the pip requirements.
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os


# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.
sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the module runner, against the "ruff" module
# hooks = ruff
# ruff.type = module
# ruff.module = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Alternatively, use the exec runner to execute a binary found on your PATH
# hooks = ruff
# ruff.type = exec
# ruff.executable = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

==========================================================================================
# app.py
==========================================================================================
import os, json, sqlite3, base64, requests
from datetime import datetime, date
from fastapi import FastAPI, Request, Header, HTTPException, Query
from fastapi.responses import RedirectResponse, HTMLResponse, PlainTextResponse, JSONResponse
from dotenv import load_dotenv
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.exceptions import InvalidSignature

load_dotenv(".env")
MONO_TOKEN = os.getenv("MONO_TOKEN")
PUBLIC_BASE_URL = os.getenv("PUBLIC_BASE_URL","https://your.domain")
SUB_PRICE_UAH = int(float(os.getenv("SUB_PRICE_UAH","99"))*100)
ADMIN_TOKEN = os.getenv("ADMIN_TOKEN","change-me-admin")
MONO_BASE = "https://api.monobank.ua"

con = sqlite3.connect("data/payments.sqlite3", check_same_thread=False)
con.execute("create table if not exists invoices(invoice_id text primary key, tg_id text, amount int, ccy int, reference text, status text, created_at text, paid_at text, refunded int default 0, refund_amount int default 0)")
con.execute("create table if not exists events(id integer primary key autoincrement, invoice_id text, kind text, payload text, created_at text)")
con.commit()

app = FastAPI()
_pubkey = None

def pubkey():
    global _pubkey
    if _pubkey is None:
        r = requests.get(f"{MONO_BASE}/api/merchant/pubkey", timeout=15)
        r.raise_for_status()
        _pubkey = serialization.load_pem_public_key(r.json()["key"].encode())
    return _pubkey

@app.get("/health")
def health(): return {"ok":True}

@app.get("/pay")
def pay(tg_id: str = Query(...)):
    return RedirectResponse(f"/pay/mono?tg_id={tg_id}", status_code=303)

@app.get("/pay/mono")
def pay_mono(tg_id: str = Query(...)):
    if not MONO_TOKEN: raise HTTPException(500, "MONO_TOKEN missing")
    amount = SUB_PRICE_UAH
    reference = f"sub_{tg_id}_{date.today():%Y-%m}"
    payload = {
        "amount": amount,
        "ccy": 980,
        "merchantPaymInfo": {"reference": reference, "destination": "FlowDiary Premium"},
        "redirectUrl": f"{PUBLIC_BASE_URL}/payments/mono/return",
        "successUrl":  f"{PUBLIC_BASE_URL}/payments/success",
        "failUrl":     f"{PUBLIC_BASE_URL}/payments/fail",
        "webHookUrl":  f"{PUBLIC_BASE_URL}/api/mono/webhook",
        "validity": 3600,
        "paymentType": "debit"
    }
    r = requests.post(f"{MONO_BASE}/api/merchant/invoice/create",
                      headers={"X-Token": MONO_TOKEN, "Content-Type":"application/json"},
                      json=payload, timeout=20)
    data = r.json()
    if r.status_code != 200 or "pageUrl" not in data:
        raise HTTPException(502, detail=data)
    con.execute("insert or replace into invoices(invoice_id,tg_id,amount,ccy,reference,status,created_at) values(?,?,?,?,?,?,?)",
                (data["invoiceId"], tg_id, amount, 980, reference, "created", datetime.utcnow().isoformat()))
    con.commit()
    return RedirectResponse(data["pageUrl"], status_code=303)

@app.post("/api/mono/webhook")
async def mono_webhook(request: Request, x_sign: str | None = Header(None)):
    raw = await request.body()
    if not x_sign: raise HTTPException(400, "X-Sign missing")
    try:
        pubkey().verify(base64.b64decode(x_sign), raw, ec.ECDSA(hashes.SHA256()))
    except (InvalidSignature, ValueError):
        raise HTTPException(403, "Bad signature")
    event = json.loads(raw.decode())
    invoice_id = event.get("invoiceId")
    status = event.get("status")
    con.execute("insert into events(invoice_id,kind,payload,created_at) values(?,?,?,?)",
                (invoice_id, "webhook", json.dumps(event, ensure_ascii=False), datetime.utcnow().isoformat()))
    if invoice_id and status:
        con.execute("update invoices set status=? where invoice_id=?", (status, invoice_id))
        if status == "success":
            con.execute("update invoices set paid_at=? where invoice_id=?", (datetime.utcnow().isoformat(), invoice_id))
        if status in ("reversed","refunded"):
            con.execute("update invoices set refunded=1 where invoice_id=?", (invoice_id,))
    con.commit()
    return PlainTextResponse("ok")

@app.get("/payments/mono/return")
def mono_return(): return HTMLResponse("<h3>–°–ø–∞—Å–∏–±–æ! –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–ª–∞—Ç—ë–∂‚Ä¶</h3>")

@app.get("/payments/success")
def success(): return HTMLResponse("<h3>–û–ø–ª–∞—Ç–∞ –ø—Ä–∏–Ω—è—Ç–∞. –ú–æ–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –≤–∫–ª–∞–¥–∫—É.</h3>")

@app.get("/payments/fail")
def fail(): return HTMLResponse("<h3>–û–ø–ª–∞—Ç–∞ –Ω–µ –ø—Ä–æ—à–ª–∞ –∏–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞.</h3>")

@app.post("/admin/mono/refund")
async def admin_refund(request: Request, x_admin_token: str | None = Header(None)):
    if x_admin_token != ADMIN_TOKEN: raise HTTPException(403, "forbidden")
    body = await request.json()
    invoice_id = body.get("invoiceId")
    amount = body.get("amount")
    if not invoice_id: raise HTTPException(400, "invoiceId required")
    payload = {"invoiceId": invoice_id}
    if amount is not None: payload["amount"] = int(amount)
    r = requests.post(f"{MONO_BASE}/api/merchant/return",
                      headers={"X-Token": MONO_TOKEN, "Content-Type":"application/json"},
                      json=payload, timeout=20)
    if r.status_code != 200:
        raise HTTPException(502, detail=r.json() if r.content else {})
    con.execute("update invoices set refunded=1, refund_amount=? where invoice_id=?",
                (payload.get("amount",0), invoice_id))
    con.commit()
    return JSONResponse({"ok":True, "data":r.json()})

@app.get("/admin/mono/status")
def admin_status(invoiceId: str, x_admin_token: str | None = Header(None)):
    if x_admin_token != ADMIN_TOKEN: raise HTTPException(403, "forbidden")
    r = requests.get(f"{MONO_BASE}/api/merchant/invoice/status",
                     params={"invoiceId": invoiceId},
                     headers={"X-Token": MONO_TOKEN}, timeout=15)
    return JSONResponse(r.json())

==========================================================================================
# app/__init__.py
==========================================================================================

==========================================================================================
# app/api.py
==========================================================================================
from fastapi import FastAPI
from app.webhooks.coinbase import router as coinbase_router

app = FastAPI()
app.include_router(coinbase_router)

@app.get('/healthz')
async def healthz():
    return {'ok': True}

==========================================================================================
# app/api/__init__.py
==========================================================================================

==========================================================================================
# app/api/coinbase.py
==========================================================================================
from fastapi import APIRouter, Request, HTTPException
from sqlalchemy import select
from datetime import datetime, timezone, timedelta
import hmac, hashlib, json

from app.config import settings
from app.db import async_session
from app.models.user import User
from app.models.payment import Payment

router = APIRouter(prefix="/payments/coinbase", tags=["payments"])

@router.post("/webhook")
async def coinbase_webhook(request: Request):
    raw = await request.body()
    sig = request.headers.get("X-CC-Webhook-Signature", "")
    calc = hmac.new(settings.coinbase_webhook_secret.encode(), raw, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(calc, sig):
        raise HTTPException(status_code=400, detail="bad signature")
    try:
        payload = json.loads(raw.decode("utf-8"))
    except Exception:
        raise HTTPException(status_code=400, detail="bad json")
    evt = payload.get("event") or {}
    if evt.get("type") != "charge:confirmed":
        return {"ok": True}
    data = evt.get("data") or {}
    metadata = data.get("metadata") or {}
    pricing_local = (data.get("pricing") or {}).get("local") or {}
    try:
        user_id = int(metadata["user_id"])
        ext_id = str(data["id"])
        amount_cents = int(round(float(pricing_local["amount"]) * 100))
        currency = str(pricing_local["currency"])
    except Exception:
        raise HTTPException(status_code=400, detail="bad payload")
    async with async_session() as session, session.begin():
        exists = await session.execute(select(Payment.id).where(Payment.external_id == ext_id))
        if exists.scalar_one_or_none():
            return {"ok": True}
        pay = Payment(
            user_id=user_id,
            provider="coinbase",
            plan="monthly",
            amount_cents=amount_cents,
            currency=currency,
            status="succeeded",
            external_id=ext_id,
            payload=json.dumps(payload, ensure_ascii=False),
            paid_at=datetime.now(timezone.utc),
        )
        session.add(pay)
        await _extend_premium(session, user_id, months=1)
    return {"ok": True}

async def _extend_premium(session, user_id: int, months: int = 1):
    res = await session.execute(select(User).where(User.id == user_id))
    user = res.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=404, detail="user not found")
    now = datetime.now(timezone.utc)
    base = user.premium_until if getattr(user, "premium_until", None) and user.premium_until > now else now
    user.premium_until = base + timedelta(days=30 * months)
    session.add(user)

==========================================================================================
# app/bot.py
==========================================================================================
# app/bot.py
from aiogram import Bot
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.client.session.aiohttp import AiohttpSession
from app.config import settings

def _default_props() -> DefaultBotProperties:
    try:
        return DefaultBotProperties(parse_mode=ParseMode.HTML, link_preview_is_disabled=True)
    except TypeError:
        return DefaultBotProperties(parse_mode=ParseMode.HTML)

# –í–ê–ñ–ù–û: timeout ‚Äî —ç—Ç–æ —á–∏—Å–ª–æ —Å–µ–∫—É–Ω–¥, –∞ –Ω–µ ClientTimeout
_session = AiohttpSession(timeout=25)

bot = Bot(
    token=settings.tg_token,
    session=_session,
    default=_default_props(),
)

__all__ = ["bot"]
==========================================================================================
# app/commands.py
==========================================================================================
from aiogram.types import BotCommand, BotCommandScopeDefault

EN = [
    BotCommand(command="start",     description="Start"),
    BotCommand(command="journal",   description="New journal entry"),
    BotCommand(command="stats",     description="Stats"),
    BotCommand(command="remind",    description="Create reminder"),
    BotCommand(command="premium",   description="Premium"),
    BotCommand(command="meditation",description="Meditation timer"),
    BotCommand(command="music",     description="My music / playlist"),
]

RU = [
    BotCommand(command="start",     description="–ù–∞—á–∞—Ç—å"),
    BotCommand(command="journal",   description="–ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å"),
    BotCommand(command="stats",     description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",    description="–°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"),
    BotCommand(command="premium",   description="–ü—Ä–µ–º–∏—É–º"),
    BotCommand(command="meditation",description="–ú–µ–¥–∏—Ç–∞—Ü–∏—è (—Ç–∞–π–º–µ—Ä)"),
    BotCommand(command="music",     description="–ú–æ—è –º—É–∑—ã–∫–∞ / –ø–ª–µ–π–ª–∏—Å—Ç"),
]

UK = [
    BotCommand(command="start",     description="–ü–æ—á–∞—Ç–∏"),
    BotCommand(command="journal",   description="–°—Ç–≤–æ—Ä–∏—Ç–∏ –∑–∞–ø–∏—Å"),
    BotCommand(command="stats",     description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",    description="–°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è"),
    BotCommand(command="premium",   description="–ü—Ä–µ–º—ñ—É–º"),
    BotCommand(command="meditation",description="–ú–µ–¥–∏—Ç–∞—Ü—ñ—è (—Ç–∞–π–º–µ—Ä)"),
    BotCommand(command="music",     description="–ú–æ—è –º—É–∑–∏–∫–∞ / –ø–ª–µ–π–ª–∏—Å—Ç"),
]

async def setup_bot_commands(bot):
    await bot.delete_my_commands(scope=BotCommandScopeDefault())
    try:
        await bot.delete_my_commands(language_code="ru")
    except:
        pass
    try:
        await bot.delete_my_commands(language_code="uk")
    except:
        pass
    await bot.set_my_commands(EN)
    await bot.set_my_commands(RU, language_code="ru")
    await bot.set_my_commands(UK, language_code="uk")

==========================================================================================
# app/config.py
==========================================================================================
# app/config.py
import os, json, time, subprocess, urllib.request
from typing import Optional

def _as_bool(v: Optional[str], default=False) -> bool:
    if v is None: return default
    return str(v).strip().lower() in {"1","true","yes","y","on"}

def _as_int(v: Optional[str], default: int) -> int:
    try: return int(str(v).strip())
    except Exception: return default

def _discover_ngrok_https() -> str:
    try:
        with urllib.request.urlopen("http://127.0.0.1:4040/api/tunnels", timeout=2) as r:
            data = json.load(r)
        for t in data.get("tunnels", []):
            u = t.get("public_url", "")
            if u.startswith("https://"):
                return u.rstrip("/")
    except Exception:
        pass
    return ""

class Settings:
    def __init__(self) -> None:
        self.tg_token = (
            os.getenv("TG_TOKEN") or os.getenv("TELEGRAM_TOKEN") or os.getenv("BOT_TOKEN")
            or os.getenv("TELEGRAM_BOT_TOKEN") or os.getenv("TOKEN") or ""
        )
        self._public_url = (os.getenv("PUBLIC_URL") or "").strip().rstrip("/")

        self.default_locale = (os.getenv("DEFAULT_LOCALE") or os.getenv("APP_DEFAULT_LOCALE") or "ru").strip().lower()
        if self.default_locale == "ua": self.default_locale = "uk"
        if self.default_locale not in {"ru","uk","en"}: self.default_locale = "ru"

        self.default_tz = (os.getenv("DEFAULT_TZ") or os.getenv("APP_DEFAULT_TZ") or "Europe/Kyiv").strip() or "Europe/Kyiv"
        self.premium_channel = (os.getenv("PREMIUM_CHANNEL") or "@NoticesDiarY").strip()

        self.music_focus_url = (os.getenv("MUSIC_FOCUS_URL") or "https://www.youtube.com/watch?v=jfKfPfyJRdk").strip()
        self.music_sleep_url = (os.getenv("MUSIC_SLEEP_URL") or "https://www.youtube.com/watch?v=5qap5aO4i9A").strip()

        self.reminder_tick_sec = _as_int(os.getenv("REMINDER_TICK_SEC"), 5)
        self.debug = _as_bool(os.getenv("DEBUG"), False)

    def ensure_public_url(self) -> str:
        if self._public_url: return self._public_url
        u = _discover_ngrok_https()
        if not u:
            try:
                subprocess.Popen(["ngrok","http","8000"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                time.sleep(2.5)
                u = _discover_ngrok_https()
            except Exception:
                u = ""
        if u:
            self._public_url = u
            os.environ["PUBLIC_URL"] = u
        return self._public_url

    @property
    def public_url(self) -> str:
        return self.ensure_public_url()

settings = Settings()
==========================================================================================
# app/db/__init__.py
==========================================================================================
from .core import engine, Base, init_db, async_session, Session

==========================================================================================
# app/db/core.py
==========================================================================================
import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base

def _normalize_url(u: str) -> str:
    if u.startswith("sqlite:///") and "+aiosqlite" not in u:
        return u.replace("sqlite://", "sqlite+aiosqlite://", 1)
    return u

DB_URL = _normalize_url(os.getenv("DB_URL", "sqlite:///dev.db"))

engine = create_async_engine(DB_URL, future=True, echo=False)
Base = declarative_base()
async_session = async_sessionmaker(bind=engine, expire_on_commit=False, class_=AsyncSession)
Session = async_session

async def init_db():
    async with engine.begin() as conn:
        # —Å–æ–∑–¥–∞–¥–∏–º ORM-—Ç–∞–±–ª–∏—Ü—ã, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
        await conn.run_sync(Base.metadata.create_all)
        # –∏ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Å–æ–∑–¥–∞–¥–∏–º –∫—Ä–∏—Ç–∏—á–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –¥–ª—è –±–æ—Ç–∞
        await conn.exec_driver_sql("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER UNIQUE,
            tz TEXT DEFAULT 'Europe/Kyiv'
        )""")
        await conn.exec_driver_sql("""
        CREATE TABLE IF NOT EXISTS reminder (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            title TEXT,
            cron TEXT,
            next_run TEXT,
            is_active INTEGER DEFAULT 1,
            FOREIGN KEY(user_id) REFERENCES users(id)
        )""")

==========================================================================================
# app/db/session.py
==========================================================================================
import os
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import DeclarativeBase

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./db.sqlite3")

class Base(DeclarativeBase):
    pass

engine = create_async_engine(DATABASE_URL, echo=False, future=True)
async_session = async_sessionmaker(bind=engine, expire_on_commit=False, class_=AsyncSession)

==========================================================================================
# app/db_conflict.py
==========================================================================================
from __future__ import annotations

from typing import AsyncIterator

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import DeclarativeBase
from app.config import settings


class Base(DeclarativeBase):
    pass


def _normalize_url(url: str) -> str:
    """–ü—Ä–∏–≤–æ–¥–∏–º URL –∫ async-–¥—Ä–∞–π–≤–µ—Ä–∞–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é."""
    if not url:
        return "sqlite+aiosqlite:///./dev.db"
    if url.startswith("postgres://"):
        url = url.replace("postgres://", "postgresql://", 1)
    if url.startswith("postgresql://"):
        url = url.replace("postgresql://", "postgresql+asyncpg://", 1)
    if url.startswith("sqlite:///") and "+aiosqlite" not in url:
        url = url.replace("sqlite:///", "sqlite+aiosqlite:///", 1)
    return url


DATABASE_URL = _normalize_url(settings.database_url)

engine = create_async_engine(
    DATABASE_URL,
    echo=bool(getattr(settings, "sqlalchemy_echo", False)),
    pool_pre_ping=True,
    future=True,
)

async_session_maker = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


def async_session() -> AsyncSession:
    """–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `async with async_session() as s:`"""
    return async_session_maker()


# –î–ª—è FastAPI Depends, –µ—Å–ª–∏ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è
async def get_session() -> AsyncIterator[AsyncSession]:
    async with async_session() as s:
        yield s


async def init_models() -> None:
    """
    –°–æ–∑–¥–∞—ë—Ç —Ç–∞–±–ª–∏—Ü—ã (–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ).
    –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥–µ–ª–∏, —á—Ç–æ–±—ã –æ–Ω–∏ –æ–∫–∞–∑–∞–ª–∏—Å—å –≤ Base.metadata.
    """
    try:
        # –ø–æ–¥—Ö–≤–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ –¥–µ–∫–ª–∞—Ä–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü
        from app.models import user as _user  # noqa: F401
        from app.models import payment as _payment  # noqa: F401
    except Exception:
        # –µ—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª–µ–π –∏–Ω–∞—è ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        pass

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


__all__ = [
    "Base",
    "engine",
    "async_session_maker",
    "async_session",
    "get_session",
    "init_models",
    "DATABASE_URL",
]
==========================================================================================
# app/features/__init__.py
==========================================================================================
from aiogram import Router
from .meditation import router as meditation_router
from .music import router as music_router

router = Router()
router.include_router(meditation_router)
router.include_router(music_router)

==========================================================================================
# app/features/calories.py
==========================================================================================
from __future__ import annotations
import os, re, httpx
from aiogram import Router, types, F
from aiogram.filters import Command
from app.i18n import tr, detect_lang
router = Router()
FALLBACK = {
    "–º–æ–ª–æ–∫–æ": dict(kcal=60, p=3.2, f=3.2, c=4.7),
    "–±–∞–Ω–∞–Ω": dict(kcal=89, p=1.1, f=0.3, c=23),
    "–∞—Ä–∞—Ö–∏—Å": dict(kcal=567, p=26, f=49, c=16),
    "–≥—Ä–µ—á–∫–∞": dict(kcal=343, p=13.3, f=3.4, c=71.5)
}
@router.message(Command("calories"))
async def cal_start(m: types.Message):
    lang = detect_lang(m.from_user.language_code)
    await m.answer(tr("cal_send", lang))
@router.message(F.text.regexp(r".+").as_("txt"))
async def cal_text(m: types.Message, txt: str):
    keys = ["–º–æ–ª–æ–∫–æ","–±–∞–Ω–∞–Ω","–∞—Ä–∞—Ö–∏—Å","–≥—Ä–µ—á","milk","banana","peanut","buckwheat"]
    if not any(w in txt.lower() for w in keys):
        return
    lang = detect_lang(m.from_user.language_code)
    res = await analyze_text(txt)
    await m.answer(tr("cal_total", lang, kcal=res["kcal"], p=res["p"], f=res["f"], c=res["c"]))
async def analyze_text(text: str) -> dict:
    key = os.getenv("NUTRITION_API_KEY")
    if key:
        try:
            async with httpx.AsyncClient(timeout=15) as cl:
                r = await cl.post("https://api.calorieninjas.com/v1/nutrition?query="+text, headers={"X-Api-Key": key})
                r.raise_for_status()
                items = r.json().get("items", [])
                kcal = sum(i.get("calories",0) for i in items)
                p = sum(i.get("protein_g",0) for i in items)
                f = sum(i.get("fat_total_g",0) for i in items)
                c = sum(i.get("carbohydrates_total_g",0) for i in items)
                return dict(kcal=round(kcal), p=round(p,1), f=round(f,1), c=round(c,1))
        except Exception:
            pass
    grams = []
    for name, meta in FALLBACK.items():
        m = re.search(rf"{name}\s*(\d+)\s*(–≥|g|–≥—Ä|ml|–º–ª)?", text.lower())
        if m:
            qty = int(m.group(1))
            unit = (m.group(2) or "g").lower()
            g = qty if unit in ["–≥","g","–≥—Ä"] else qty
            grams.append((g, meta))
    kcal=p=f=c=0.0
    for g, meta in grams:
        factor = g/100.0
        kcal += meta["kcal"]*factor
        p += meta["p"]*factor
        f += meta["f"]*factor
        c += meta["c"]*factor
    return dict(kcal=round(kcal), p=round(p,1), f=round(f,1), c=round(c,1))

==========================================================================================
# app/features/chat_mode.py
==========================================================================================
from __future__ import annotations
import json, pathlib
from aiogram import Router, types, F
from aiogram.filters import Command
from app.i18n import tr, detect_lang
router = Router()
STORE = pathlib.Path("data/user_flags.json")
def _load():
    if STORE.exists():
        return json.loads(STORE.read_text(encoding="utf-8"))
    return {}
def _save(d):
    STORE.write_text(json.dumps(d, ensure_ascii=False, indent=2), encoding="utf-8")
@router.message(Command("chat_on"))
async def chat_on(m: types.Message):
    lang = detect_lang(m.from_user.language_code)
    d = _load(); d[str(m.from_user.id)] = True; _save(d)
    await m.answer(tr("chat_on", lang) + "\n" + tr("chat_hint", lang))
@router.message(Command("chat_off"))
async def chat_off(m: types.Message):
    lang = detect_lang(m.from_user.language_code)
    d = _load(); d[str(m.from_user.id)] = False; _save(d)
    await m.answer(tr("chat_off", lang))
@router.message(F.content_type.in_({"text","photo"}))
async def smart_chat(m: types.Message):
    d = _load()
    if not d.get(str(m.from_user.id)):
        return
    lang = detect_lang(m.from_user.language_code)
    await m.reply(tr("chat_reply_generic", lang))

==========================================================================================
# app/features/meditation.py
==========================================================================================

from __future__ import annotations
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

router = Router()

TXT = {
    "menu":   {"ru": "–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü–∏–∏:", "uk": "–í–∏–±–µ—Ä–∏ —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü—ñ—ó:", "en": "Choose meditation mode:"},
    "focus":  {"ru": "–§–æ–∫—É—Å", "uk": "–§–æ–∫—É—Å", "en": "Focus"},
    "calm":   {"ru": "–°–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ", "uk": "–°–ø–æ–∫—ñ–π", "en": "Calm"},
    "sleep":  {"ru": "–°–æ–Ω", "uk": "–°–æ–Ω", "en": "Sleep"},
    "open":   {"ru": "–û—Ç–∫—Ä—ã—Ç—å ‚ñ∂Ô∏è", "uk": "–í—ñ–¥–∫—Ä–∏—Ç–∏ ‚ñ∂Ô∏è", "en": "Open ‚ñ∂Ô∏è"},
    "back":   {"ru": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "uk": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "en": "‚¨ÖÔ∏è Back"},
    "dur":    {"ru": "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:", "uk": "–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å:", "en": "Duration:"},
    "d5":     {"ru": "5 –º–∏–Ω", "uk": "5 —Ö–≤", "en": "5 min"},
    "d10":    {"ru": "10 –º–∏–Ω", "uk": "10 —Ö–≤", "en": "10 min"},
    "d15":    {"ru": "15 –º–∏–Ω", "uk": "15 —Ö–≤", "en": "15 min"},
    "started":{"ru": "–°—Ç–∞—Ä—Ç. –°–µ—Å—Å–∏—è {dur} –≤ —Ä–µ–∂–∏–º–µ ¬´{mode}¬ª. –¢—Ä–µ–∫ –Ω–∏–∂–µ.", 
               "uk": "–°—Ç–∞—Ä—Ç. –°–µ—Å—ñ—è {dur} —É —Ä–µ–∂–∏–º—ñ ¬´{mode}¬ª. –¢—Ä–µ–∫ –Ω–∏–∂—á–µ.", 
               "en": "Started. {dur} session in ‚Äú{mode}‚Äù mode. Track below."}
}

MODES = ("focus","calm","sleep")
DURATIONS = {"d5": 5, "d10": 10, "d15": 15}

async def _lang(obj, session: AsyncSession) -> str:
    tg = getattr(getattr(obj,'from_user',None),'id',None)
    row = await session.execute(sql_text('SELECT lang FROM users WHERE tg_id=:tg'), {'tg': tg})
    code = row.scalar_one_or_none() or getattr(getattr(obj,'from_user',None),'language_code',None)
    code = (code or 'ru')[:2].lower()
    return code if code in {'ru','uk','en'} else 'ru'

def _urls():
    # –ø—Ä–æ—Å—Ç—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã, –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ settings/env
    focus = "https://www.youtube.com/watch?v=jfKfPfyJRdk"
    calm  = "https://www.youtube.com/watch?v=5qap5aO4i9A"
    sleep = "https://www.youtube.com/watch?v=lTRiuFIWV54"
    return {"focus": focus, "calm": calm, "sleep": sleep}

def _menu_kb(l: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text=TXT["focus"][l], callback_data="med:mode:focus"),
        InlineKeyboardButton(text=TXT["calm"][l],  callback_data="med:mode:calm"),
        InlineKeyboardButton(text=TXT["sleep"][l], callback_data="med:mode:sleep"),
    ]])

def _dur_kb(l: str, mode: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=TXT["dur"][l], callback_data="noop")],
        [
            InlineKeyboardButton(text=TXT["d5"][l],  callback_data=f"med:dur:{mode}:d5"),
            InlineKeyboardButton(text=TXT["d10"][l], callback_data=f"med:dur:{mode}:d10"),
            InlineKeyboardButton(text=TXT["d15"][l], callback_data=f"med:dur:{mode}:d15"),
        ],
        [InlineKeyboardButton(text=TXT["back"][l], callback_data="med:back")]
    ])

def _open_kb(l: str, mode: str) -> InlineKeyboardMarkup:
    url = _urls()[mode]
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text=TXT["open"][l], url=url),
    ]])

@router.message(Command("meditation"))
@router.message(F.text.lower().in_({"üßò meditation","üßò –º–µ–¥–∏—Ç–∞—Ü–∏—è","üßò –º–µ–¥–∏—Ç–∞—Ü—ñ—è","meditation","–º–µ–¥–∏—Ç–∞—Ü–∏—è","–º–µ–¥–∏—Ç–∞—Ü—ñ—è"}))
async def cmd_meditation(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    await m.answer(TXT["menu"][l], reply_markup=_menu_kb(l))

@router.callback_query(F.data.startswith("med:"))
async def on_med_choice(c: CallbackQuery, session: AsyncSession):
    l = await _lang(c, session)
    data = c.data.split(":")
    # –ù–ò–ß–ï–ì–û –Ω–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º ‚Äî —Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    if data[1] == "mode":
        mode = data[2]
        if mode not in MODES:
            await c.answer(); return
        await c.answer()
        await c.message.answer(TXT["dur"][l] + " " + {"focus":TXT["focus"][l],"calm":TXT["calm"][l],"sleep":TXT["sleep"][l]}[mode],
                               reply_markup=_dur_kb(l, mode))
        return
    if data[1] == "dur":
        mode, dkey = data[2], data[3]
        mins = DURATIONS.get(dkey, 5)
        mode_title = {"focus":TXT["focus"][l],"calm":TXT["calm"][l],"sleep":TXT["sleep"][l]}[mode]
        await c.answer()
        await c.message.answer(TXT["started"][l].format(dur=f"{mins} –º–∏–Ω" if l=='ru' else (f"{mins} —Ö–≤" if l=='uk' else f"{mins} min"),
                                                        mode=mode_title))
        await c.message.answer(TXT["open"][l], reply_markup=_open_kb(l, mode))
        return
    if data[1] == "back":
        await c.answer()
        await c.message.answer(TXT["menu"][l], reply_markup=_menu_kb(l))
        return

==========================================================================================
# app/features/music.py
==========================================================================================
from __future__ import annotations

import os
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import (
    Message, CallbackQuery,
    InlineKeyboardMarkup, InlineKeyboardButton
)
from aiogram.exceptions import TelegramBadRequest
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

router = Router()

SUPPORTED = {"ru", "uk", "en"}

TXT = {
    "menu": {
        "ru": "–í—ã–±–µ—Ä–∏ –ø–ª–µ–π–ª–∏—Å—Ç:",
        "uk": "–û–±–µ—Ä—ñ—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç:",
        "en": "Choose a playlist:",
    },
    "focus_btn": {"ru": "–§–æ–∫—É—Å", "uk": "–§–æ–∫—É—Å", "en": "Focus"},
    "sleep_btn": {"ru": "–°–æ–Ω", "uk": "–°–æ–Ω", "en": "Sleep"},
    "my_btn":    {"ru": "–ú–æ–π –ø–ª–µ–π–ª–∏—Å—Ç", "uk": "–ú—ñ–π –ø–ª–µ–π–ª–∏—Å—Ç", "en": "My playlist"},
    "add_btn":   {"ru": "–î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫", "uk": "–î–æ–¥–∞—Ç–∏ —Ç—Ä–µ–∫", "en": "Add a track"},
    "open_focus": {"ru": "–û—Ç–∫—Ä—ã—Ç—å Focus ‚ñ∂Ô∏è", "uk": "–í—ñ–¥–∫—Ä–∏—Ç–∏ Focus ‚ñ∂Ô∏è", "en": "Open Focus ‚ñ∂Ô∏è"},
    "open_sleep": {"ru": "–û—Ç–∫—Ä—ã—Ç—å Sleep ‚ñ∂Ô∏è", "uk": "–í—ñ–¥–∫—Ä–∏—Ç–∏ Sleep ‚ñ∂Ô∏è", "en": "Open Sleep ‚ñ∂Ô∏è"},
    "back": {"ru": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "uk": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "en": "‚¨ÖÔ∏è Back"},
    "send_audio_hint": {
        "ru": "–ü—Ä–∏—à–ª–∏ –º–Ω–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª(—ã) ‚Äî –¥–æ–±–∞–≤–ª—é –≤ —Ç–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç.",
        "uk": "–ù–∞–¥—ñ—à–ª–∏ –∞—É–¥—ñ–æ—Ñ–∞–π–ª(–∏) ‚Äî –¥–æ–¥–∞–º —É —Ç–≤—ñ–π –ø–ª–µ–π–ª–∏—Å—Ç.",
        "en": "Send me audio file(s) ‚Äî I will add them to your playlist.",
    },
    "saved": {"ru": "–°–æ—Ö—Ä–∞–Ω–∏–ª –≤ —Ç–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç ‚úÖ",
              "uk": "–ó–±–µ—Ä—ñ–≥ —É —Ç–≤—ñ–π –ø–ª–µ–π–ª–∏—Å—Ç ‚úÖ",
              "en": "Saved to your playlist ‚úÖ"},
    "empty": {"ru": "–ü–æ–∫–∞ –ø—É—Å—Ç–æ. ",
              "uk": "–ü–æ–∫–∏ –ø–æ—Ä–æ–∂–Ω—å–æ. ",
              "en": "No tracks yet. "},
    "your_tracks": {"ru": "–¢–≤–æ–∏ —Ç—Ä–µ–∫–∏:",
                    "uk": "–¢–≤–æ—ó —Ç—Ä–µ–∫–∏:",
                    "en": "Your tracks:"},
}

# ---------- i18n ----------
def _norm(l: str | None) -> str:
    l = (l or "ru")[:2].lower()
    return l if l in SUPPORTED else "ru"

async def _lang(m: Message | CallbackQuery, session: AsyncSession) -> str:
    if isinstance(m, Message):
        tg = getattr(getattr(m, "from_user", None), "id", None)
        code = getattr(getattr(m, "from_user", None), "language_code", None)
    else:
        tg = (getattr(getattr(m, "from_user", None), "id", None)
              or getattr(getattr(m.message, "from_user", None), "id", None))
        code = (getattr(getattr(m, "from_user", None), "language_code", None)
                or getattr(getattr(m.message, "from_user", None), "language_code", None))

    db_lang = None
    if tg is not None:
        try:
            res = await session.execute(
                sql_text("SELECT lang FROM users WHERE tg_id=:tg"), {"tg": tg}
            )
            db_lang = res.scalar_one_or_none()
        except Exception:
            db_lang = None
    return _norm(db_lang or code or "ru")

# ---------- URLs ----------
def _urls():
    try:
        from app.config import settings as cfg
    except Exception:
        cfg = None
    focus = (getattr(cfg, "music_focus_url", None)
             or os.getenv("MUSIC_FOCUS_URL")
             or "https://www.youtube.com/watch?v=jfKfPfyJRdk")
    sleep = (getattr(cfg, "music_sleep_url", None)
             or os.getenv("MUSIC_SLEEP_URL")
             or "https://www.youtube.com/watch?v=5qap5aO4i9A")
    return str(focus), str(sleep)

# ---------- Keyboards ----------
def _menu_kb(l: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text=TXT["focus_btn"][l], callback_data="music:focus"),
            InlineKeyboardButton(text=TXT["sleep_btn"][l], callback_data="music:sleep"),
        ],
        [
            InlineKeyboardButton(text=TXT["my_btn"][l],  callback_data="music:my"),
            InlineKeyboardButton(text=TXT["add_btn"][l], callback_data="music:add"),
        ],
    ])

def _open_kb(l: str, kind: str) -> InlineKeyboardMarkup:
    focus, sleep = _urls()
    url = focus if kind == "focus" else sleep
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=TXT[f"open_{kind}"][l], url=url)],
        [InlineKeyboardButton(text=TXT["back"][l], callback_data="music:back")],
    ])

def _numbers_kb(l: str, items: list[tuple[int, str]]) -> InlineKeyboardMarkup:
    # items: list of (id, title). –ù–∞ –∫–Ω–æ–ø–∫–∞—Ö ‚Äî 1..5..10
    row, kb = [], []
    for idx, (iid, _title) in enumerate(items, start=1):
        row.append(InlineKeyboardButton(text=str(idx), callback_data=f"music:play/{iid}"))
        if len(row) == 5:
            kb.append(row); row = []
    if row:
        kb.append(row)
    kb.append([InlineKeyboardButton(text=TXT["back"][l], callback_data="music:back")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

# ---------- DB helpers ----------
async def _dialect(session: AsyncSession) -> str:
    try:
        return session.bind.sync_engine.dialect.name
    except Exception:
        return "sqlite"

async def _ensure_schema(session: AsyncSession):
    d = await _dialect(session)
    if d == "sqlite":
        ddl = """
        CREATE TABLE IF NOT EXISTS user_tracks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER NOT NULL,
            title TEXT,
            file_id TEXT NOT NULL,
            created_at TEXT DEFAULT (CURRENT_TIMESTAMP)
        );
        CREATE UNIQUE INDEX IF NOT EXISTS ux_user_tracks_tg_file
            ON user_tracks (tg_id, file_id);
        CREATE INDEX IF NOT EXISTS ix_user_tracks_tg_id
            ON user_tracks (tg_id);
        """
    else:  # postgres / etc.
        ddl = """
        CREATE TABLE IF NOT EXISTS user_tracks (
            id BIGSERIAL PRIMARY KEY,
            tg_id BIGINT NOT NULL,
            title TEXT,
            file_id TEXT NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
        CREATE UNIQUE INDEX IF NOT EXISTS ux_user_tracks_tg_file
            ON user_tracks (tg_id, file_id);
        CREATE INDEX IF NOT EXISTS ix_user_tracks_tg_id
            ON user_tracks (tg_id);
        """
    # –í—ã–ø–æ–ª–Ω–∏–º –±–ª–æ–∫–æ–º: SQLite ¬´–ø—Ä–æ–≥–ª–æ—Ç–∏—Ç¬ª –Ω–µ—Å–∫–æ–ª—å–∫–æ statement-–æ–≤, PG —Ç–æ–∂–µ –æ–∫
    for stmt in filter(None, (s.strip() for s in ddl.split(";"))):
        if stmt:
            await session.execute(sql_text(stmt))
    await session.commit()

async def _save_track(session: AsyncSession, tg: int, title: str, fid: str):
    await _ensure_schema(session)
    d = await _dialect(session)
    if d == "sqlite":
        q = "INSERT OR IGNORE INTO user_tracks (tg_id, title, file_id) VALUES (:tg, :t, :f)"
    else:
        q = ("INSERT INTO user_tracks (tg_id, title, file_id) VALUES (:tg, :t, :f) "
             "ON CONFLICT (tg_id, file_id) DO NOTHING")
    await session.execute(sql_text(q), {"tg": tg, "t": title, "f": fid})
    await session.commit()

async def _list_tracks(session: AsyncSession, tg: int, limit: int = 10) -> list[tuple[int, str]]:
    await _ensure_schema(session)
    res = await session.execute(
        sql_text("SELECT id, COALESCE(title,'Track') FROM user_tracks "
                 "WHERE tg_id=:tg ORDER BY id DESC LIMIT :lim"),
        {"tg": tg, "lim": limit}
    )
    return [(row[0], row[1]) for row in res.fetchall()]

async def _get_track(session: AsyncSession, tg: int, track_id: int) -> tuple[str, str] | None:
    await _ensure_schema(session)
    res = await session.execute(
        sql_text("SELECT file_id, COALESCE(title,'Track') "
                 "FROM user_tracks WHERE id=:i AND tg_id=:tg"),
        {"i": track_id, "tg": tg}
    )
    row = res.fetchone()
    return (row[0], row[1]) if row else None

# ---------- handlers ----------
@router.message(Command("music"))
@router.message(F.text.in_({"üéµ Music", "üéµ –ú—É–∑–∏–∫–∞", "üéµ –ú—É–∑—ã–∫–∞", "music", "–º—É–∑—ã–∫–∞", "–º—É–∑–∏–∫–∞"}))
async def cmd_music(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    await m.answer(TXT["menu"][l], reply_markup=_menu_kb(l))

@router.callback_query(F.data.startswith("music:"))
async def on_music_choice(c: CallbackQuery, session: AsyncSession):
    l = await _lang(c, session)
    kind = c.data.split(":", 1)[1]

    # –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º ¬´—á–∞—Å–∏–∫–∏¬ª
    try:
        await c.answer()
    except TelegramBadRequest:
        pass

    if kind == "back":
        await c.message.answer(TXT["menu"][l], reply_markup=_menu_kb(l))
        return

    if kind in {"focus", "sleep"}:
        await c.message.answer(TXT["menu"][l], reply_markup=_open_kb(l, kind))
        return

    if kind == "add":
        await c.message.answer(TXT["send_audio_hint"][l])
        return

    if kind == "my":
        tg = getattr(getattr(c, "from_user", None), "id", None)
        rows = await _list_tracks(session, tg) if tg else []
        if not rows:
            await c.message.answer(TXT["empty"][l] + TXT["send_audio_hint"][l])
        else:
            await c.message.answer(TXT["your_tracks"][l], reply_markup=_numbers_kb(l, rows))
        return

    if kind.startswith("play/"):
        _, sid = kind.split("/", 1)
        try:
            track_id = int(sid)
        except Exception:
            return
        tg = getattr(getattr(c, "from_user", None), "id", None)
        if tg is None:
            return
        got = await _get_track(session, tg, track_id)
        if got:
            fid, title = got
            await c.message.answer_audio(audio=fid, caption=title or None)
        return

@router.message(F.audio)
async def on_audio_inbox(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    tg = getattr(getattr(m, "from_user", None), "id", None)
    if tg is None:
        return
    title = (getattr(m.audio, "title", None)
             or getattr(m.audio, "file_name", None)
             or getattr(m.audio, "performer", None)
             or "Track")
    await _save_track(session, tg, title, m.audio.file_id)
    await m.answer(TXT["saved"][l])

# —Ç–∞–∫–∂–µ –ø—Ä–∏–º–µ–º mp3 –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç (—á–∞—Å—Ç–æ –ø—Ä–∏—Å—ã–ª–∞—é—Ç –∏–º–µ–Ω–Ω–æ —Ç–∞–∫)
@router.message(F.document.mime_type.startswith("audio/"))
async def on_audio_document(m: Message, session: AsyncSession):
    l = await _lang(m, session)
    tg = getattr(getattr(m, "from_user", None), "id", None)
    if tg is None:
        return
    title = (getattr(m.document, "file_name", None) or "Track")
    await _save_track(session, tg, title, m.document.file_id)
    await m.answer(TXT["saved"][l])
==========================================================================================
# app/handlers/__init__.py
==========================================================================================

==========================================================================================
# app/handlers/common.py
==========================================================================================
# app/handlers/cancel.py
from aiogram import Router
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message

from app.keyboards import get_main_kb  # —É–∂–µ –µ—Å—Ç—å —É –Ω–∞—Å

router = Router(name="cancel")

# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º /cancel –∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
_CANCEL_WORDS = {
    "ru": {"–æ—Ç–º–µ–Ω–∞", "—Å—Ç–æ–ø", "cancel", "/cancel"},
    "uk": {"—Å–∫–∞—Å—É–≤–∞—Ç–∏", "–≤—ñ–¥–º—ñ–Ω–∞", "cancel", "/cancel"},
    "en": {"cancel", "stop", "/cancel"},
}
_MSG = {
    "ru": "–û–∫, –æ—Ç–º–µ–Ω–∏–ª. –¢—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é.",
    "uk": "–û–∫, —Å–∫–∞—Å—É–≤–∞–≤. –¢–∏ –≤ –≥–æ–ª–æ–≤–Ω–æ–º—É –º–µ–Ω—é.",
    "en": "Okay, canceled. You're in the main menu.",
}

def _is_cancel_text(text: str) -> bool:
    t = text.strip().lower()
    # –æ–±—â–∏–π –ø—É–ª —Å–ª–æ–≤, —á—Ç–æ–±—ã –Ω–µ –≥–æ—Ä–æ–¥–∏—Ç—å –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
    universe = set().union(*_CANCEL_WORDS.values())
    return t in universe

@router.message(Command("cancel"))
@router.message(lambda m: m.text and _is_cancel_text(m.text))
async def cancel_any(m: Message, state: FSMContext, lang: str):
    # lang –ø—Ä–∏—Ö–æ–¥–∏—Ç –∏–∑ LangMiddleware (data["lang"])
    await state.clear()
    msg = _MSG.get(lang, _MSG["ru"])
    await m.answer(msg, reply_markup=get_main_kb(lang))
==========================================================================================
# app/handlers/erase.py
==========================================================================================
# app/handlers/erase.py
from __future__ import annotations

import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional

from aiogram import Router
from aiogram.filters import Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.types import Message
from sqlalchemy import select, delete, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.models.journal import JournalEntry
from app.models.reminder import Reminder
from app.models.bug_report import BugReport

router = Router()


class EraseFSM(StatesGroup):
    confirm = State()


_L10N = {
    "prompt": {
        "ru": "‚ùóÔ∏è–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–≤–æ–∏ –∑–∞–ø–∏—Å–∏/—Ä–µ–ø–æ—Ä—Ç—ã/–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è?\n\n–ù–∞–ø–∏—à–∏: <code>{phrase}</code>\n–ò–ª–∏ /cancel ‚Äî —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å.\n\n(–ö–æ–¥ –¥–µ–π—Å—Ç–≤—É–µ—Ç 2 –º–∏–Ω—É—Ç—ã.)",
        "uk": "‚ùóÔ∏è–í–∏–¥–∞–ª–∏—Ç–∏ –≤—Å—ñ —Ç–≤–æ—ó –∑–∞–ø–∏—Å–∏/—Ä–µ–ø–æ—Ä—Ç–∏/–Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è?\n\n–ù–∞–ø–∏—à–∏: <code>{phrase}</code>\n–ê–±–æ /cancel ‚Äî —â–æ–± —Å–∫–∞—Å—É–≤–∞—Ç–∏.\n\n(–ö–æ–¥ –¥—ñ—î 2 —Ö–≤–∏–ª–∏–Ω–∏.)",
        "en": "‚ùóÔ∏èDelete all your entries/reports/reminders?\n\nType: <code>{phrase}</code>\nOr /cancel to abort.\n\n(The code is valid for 2 minutes.)",
    },
    "canceled": {
        "ru": "–û—Ç–º–µ–Ω–∏–ª. –ù–∏—á–µ–≥–æ –Ω–µ —É–¥–∞–ª—è–ª.",
        "uk": "–°–∫–∞—Å—É–≤–∞–≤. –ù—ñ—á–æ–≥–æ –Ω–µ –≤–∏–¥–∞–ª—è–≤.",
        "en": "Canceled. Nothing was deleted.",
    },
    "need_start": {
        "ru": "–ù–∞–∂–º–∏ /start",
        "uk": "–ù–∞—Ç–∏—Å–Ω–∏ /start",
        "en": "Press /start",
    },
    "expired": {
        "ru": "‚è± –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞ –∏—Å—Ç—ë–∫. –í—ã–∑–æ–≤–∏ /erase —Å–Ω–æ–≤–∞.",
        "uk": "‚è± –¢–µ—Ä–º—ñ–Ω –¥—ñ—ó –∫–æ–¥—É –º–∏–Ω—É–≤. –í–∏–∫–ª–∏—á /erase —â–µ —Ä–∞–∑.",
        "en": "‚è± The code expired. Run /erase again.",
    },
    "wrong": {
        "ru": "–ù—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å —Ä–æ–≤–Ω–æ: <code>{phrase}</code> ‚Äî –∏–ª–∏ /cancel",
        "uk": "–ü–æ—Ç—Ä—ñ–±–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç–∏ —Ä—ñ–≤–Ω–æ: <code>{phrase}</code> ‚Äî –∞–±–æ /cancel",
        "en": "You must type exactly: <code>{phrase}</code> ‚Äî or /cancel",
    },
    "done": {
        "ru": "‚úÖ –ì–æ—Ç–æ–≤–æ. –í—Å–µ —Ç–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã.\n(–ê–∫–∫–∞—É–Ω—Ç –æ—Å—Ç–∞–≤–∏–ª, –º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º.)\n\n–£–¥–∞–ª–µ–Ω–æ: –∑–∞–º–µ—Ç–æ–∫ ‚Äî {j}, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π ‚Äî {r}, —Ä–µ–ø–æ—Ä—Ç–æ–≤ ‚Äî {b}.",
        "uk": "‚úÖ –ì–æ—Ç–æ–≤–æ. –£—Å—ñ —Ç–≤–æ—ó –¥–∞–Ω—ñ –≤–∏–¥–∞–ª–µ–Ω–æ.\n(–ê–∫–∞—É–Ω—Ç –ª–∏—à–∏–≤, –º–æ–∂–Ω–∞ –¥–∞–ª—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è –±–æ—Ç–æ–º.)\n\n–í–∏–¥–∞–ª–µ–Ω–æ: –Ω–æ—Ç–∞—Ç–æ–∫ ‚Äî {j}, –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å ‚Äî {r}, —Ä–µ–ø–æ—Ä—Ç—ñ–≤ ‚Äî {b}.",
        "en": "‚úÖ Done. All your data is deleted.\n(Account kept; you can continue using the bot.)\n\nDeleted: entries ‚Äî {j}, reminders ‚Äî {r}, reports ‚Äî {b}.",
    },
}


def _lang(m: Message, user: Optional[User]) -> str:
    return (getattr(user, "language", None) or getattr(getattr(m, "from_user", None), "language_code", None) or "ru").lower()


def _t(key: str, lang: str, **kwargs) -> str:
    tpl = _L10N[key].get(lang) or _L10N[key]["ru"]
    return tpl.format(**kwargs)


@router.message(Command("erase"))
async def erase_start(m: Message, state: FSMContext):
    # –ì–µ–Ω–µ—Ä–∏–º –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—É—é —Ñ—Ä–∞–∑—É –≤–∏–¥–∞ "DELETE ABC123"
    token = secrets.token_hex(3).upper()  # 6 —Å–∏–º–≤–æ–ª–æ–≤
    phrase = f"DELETE {token}"
    expires_at = datetime.now(timezone.utc) + timedelta(minutes=2)

    await state.set_state(EraseFSM.confirm)
    await state.update_data(phrase=phrase, expires_at=expires_at.isoformat())

    # –Ø–∑—ã–∫ –≤–æ–∑—å–º—ë–º –∏–∑ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–∑–∂–µ, —Ç—É—Ç –ø–æ–∫–∞ –±–µ–∑ session
    await m.answer(_t("prompt", _lang(m, None), phrase=phrase), parse_mode="HTML")


@router.message(Command("cancel"))
async def erase_cancel(m: Message, state: FSMContext):
    await state.clear()
    await m.answer(_t("canceled", _lang(m, None)))


@router.message(EraseFSM.confirm)
async def erase_do(m: Message, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    phrase = data.get("phrase")
    expires_at_s = data.get("expires_at")

    # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
    if not phrase or not expires_at_s:
        await state.clear()
        return await m.answer(_t("expired", _lang(m, None)))

    try:
        expires_at = datetime.fromisoformat(expires_at_s)
    except Exception:
        await state.clear()
        return await m.answer(_t("expired", _lang(m, None)))

    # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    lang = _lang(m, user)

    if not user:
        await state.clear()
        return await m.answer(_t(lang, "need_start"))

    text = (m.text or "").strip()
    if text.lower() == "/cancel":
        await state.clear()
        return await m.answer(_t(lang, "canceled"))

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞
    if datetime.now(timezone.utc) > expires_at:
        await state.clear()
        return await m.answer(_t(lang, "expired"))

    # –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
    if text != phrase:
        return await m.answer(_t("wrong", lang, phrase=phrase), parse_mode="HTML")

    # –ü–æ—Å—á–∏—Ç–∞–µ–º, —á—Ç–æ–±—ã –æ—Ç—á–∏—Ç–∞—Ç—å—Å—è
    j_cnt = await session.scalar(
        select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
    )
    r_cnt = await session.scalar(
        select(func.count()).select_from(Reminder).where(Reminder.user_id == user.id)
    )
    b_cnt = await session.scalar(
        select(func.count()).select_from(BugReport).where(BugReport.user_id == user.id)
    )

    # –£–¥–∞–ª—è–µ–º
    async with session.begin():
        await session.execute(
            delete(JournalEntry).where(JournalEntry.user_id == user.id).execution_options(synchronize_session=False)
        )
        await session.execute(
            delete(Reminder).where(Reminder.user_id == user.id).execution_options(synchronize_session=False)
        )
        await session.execute(
            delete(BugReport).where(BugReport.user_id == user.id).execution_options(synchronize_session=False)
        )

    await state.clear()
    await m.answer(_t("done", lang, j=j_cnt or 0, r=r_cnt or 0, b=b_cnt or 0))
==========================================================================================
# app/handlers/export.py
==========================================================================================
from __future__ import annotations

import io
import json
import gzip
from datetime import datetime, timezone
from typing import Optional

from aiogram import Router
from aiogram.filters import Command
from aiogram.types import Message, BufferedInputFile
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.config import settings
from app.models.user import User
from app.models.journal import JournalEntry
from app.models.reminder import Reminder
from app.models.bug_report import BugReport  # –í–ê–ñ–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º BugReport

router = Router()


# –ü—Ä–æ—Å—Ç–µ–Ω—å–∫–∞—è –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è 2 —Å–æ–æ–±—â–µ–Ω–∏–π
_L10N = {
    "export_disabled": {
        "ru": "–≠–∫—Å–ø–æ—Ä—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –≤—ã–∫–ª—é—á–µ–Ω.",
        "uk": "–ï–∫—Å–ø–æ—Ä—Ç —Ç–∏–º—á–∞—Å–æ–≤–æ –≤–∏–º–∫–Ω–µ–Ω–æ.",
        "en": "Export is temporarily disabled.",
    },
    "press_start": {
        "ru": "–ù–∞–∂–º–∏ /start",
        "uk": "–ù–∞—Ç–∏—Å–Ω–∏ /start",
        "en": "Press /start",
    },
}


def _t(key: str, lang: Optional[str]) -> str:
    lang = (lang or settings.default_locale or "ru").lower()
    return _L10N.get(key, {}).get(lang, _L10N[key]["ru"])


def _ser_dt(dt: Optional[datetime]) -> Optional[str]:
    """ISO8601 UTC, –±–µ–∑–æ–ø–∞—Å–Ω–æ –¥–ª—è naive/aware –¥–∞—Ç."""
    if not dt:
        return None
    if dt.tzinfo is None:
        return dt.replace(tzinfo=timezone.utc).isoformat().replace("+00:00", "Z")
    return dt.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")


@router.message(Command("export"))
async def export_data(m: Message, session: AsyncSession):
    # –ù–∞ –ø—Ä–æ–¥–µ –º–æ–∂–Ω–æ –≤—ã–∫–ª—é—á–∞—Ç—å —ç–∫—Å–ø–æ—Ä—Ç —Ñ–ª–∞–≥–æ–º
    if not settings.enable_exporter:
        # –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–∫–∞–∑–∞—Ç—å –Ω–∞ —è–∑—ã–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_lang = getattr(getattr(m, "from_user", None), "language_code", None)
        return await m.answer(_t("export_disabled", user_lang))

    # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    if not user:
        user_lang = getattr(getattr(m, "from_user", None), "language_code", None)
        return await m.answer(_t("press_start", user_lang))

    # –ó–∞–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    entries = (
        await session.execute(
            select(JournalEntry)
            .where(JournalEntry.user_id == user.id)
            .order_by(JournalEntry.id)
        )
    ).scalars().all()

    reminders = (
        await session.execute(
            select(Reminder).where(Reminder.user_id == user.id).order_by(Reminder.id)
        )
    ).scalars().all()

    reports = (
        await session.execute(
            select(BugReport).where(BugReport.user_id == user.id).order_by(BugReport.id)
        )
    ).scalars().all()

    payload = {
        "user": {
            "id": user.id,
            "tg_id": user.tg_id,
            "language": getattr(user, "language", None),
            "consent_accepted_at": _ser_dt(getattr(user, "consent_accepted_at", None)),
        },
        "journal": [
            {
                "id": e.id,
                "text": e.text,
                "created_at": _ser_dt(getattr(e, "created_at", None)),
            }
            for e in entries
        ],
        "reminders": [
            {
                "id": r.id,
                "text": r.text,
                "due_at": _ser_dt(getattr(r, "due_at", None)),
                "sent_at": _ser_dt(getattr(r, "sent_at", None)),
            }
            for r in reminders
        ],
        "reports": [
            {
                "id": r.id,
                "text": r.text,
                "created_at": _ser_dt(getattr(r, "created_at", None)),
            }
            for r in reports
        ],
        "meta": {
            "exported_at": _ser_dt(datetime.now(timezone.utc)),
            "counts": {
                "journal": len(entries),
                "reminders": len(reminders),
                "reports": len(reports),
            },
            "version": "1",
        },
    }

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    fname_base = f"diary_export_{user.tg_id}_{datetime.now(timezone.utc).strftime('%Y%m%dT%H%M%SZ')}"
    raw = json.dumps(payload, ensure_ascii=False, indent=2).encode("utf-8")

    # –¢–µ–ª–µ–≥—Ä–∞–º-–ª–∏–º–∏—Ç –¥–ª—è –±–æ—Ç–æ–≤ ~50 –ú–ë. –ü–æ–¥—Å—Ç—Ä–∞—Ö—É–µ–º—Å—è gzip‚Äô–æ–º, –µ—Å–ª–∏ > 8 –ú–ë.
    if len(raw) > 8 * 1024 * 1024:
        buf = io.BytesIO()
        with gzip.GzipFile(fileobj=buf, mode="wb") as gz:
            gz.write(raw)
        data = buf.getvalue()
        fname = f"{fname_base}.json.gz"
    else:
        data = raw
        fname = f"{fname_base}.json"

    await m.answer_document(BufferedInputFile(data, filename=fname))
==========================================================================================
# app/handlers/journal.py
==========================================================================================
# app/handlers/journal.py
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

from app.models.user import User
from app.models.journal import JournalEntry
try:
    from app.handlers.premium import maybe_grant_trial
except Exception:
    async def maybe_grant_trial(*a, **k):
        return False
from app.keyboards import get_main_kb

router = Router()

class JournalFSM(StatesGroup):
    waiting_text = State()

def _tr(lang: str | None, ru: str, uk: str, en: str) -> str:
    l = (lang or "ru").lower()
    if l == "uk":
        return uk
    if l == "en":
        return en
    return ru

@router.message(Command("journal"))
async def journal_prompt(m: Message, state: FSMContext, lang: str):
    # –í—Ö–æ–¥–∏–º –≤ —Ä–µ–∂–∏–º –ø—Ä–∏—ë–º–∞ –æ–¥–Ω–æ–π –∑–∞–ø–∏—Å–∏
    await state.set_state(JournalFSM.waiting_text)
    await m.answer(
        _tr(
            lang,
            "–ù–∞–ø–∏—à–∏ 2‚Äì3 –º—ã—Å–ª–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n\n/cancel ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å",
            "–ù–∞–ø–∏—à–∏ 2‚Äì3 –¥—É–º–∫–∏ –∑–∞ —Å—å–æ–≥–æ–¥–Ω—ñ –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.\n\n/cancel ‚Äî —Å–∫–∞—Å—É–≤–∞—Ç–∏",
            "Send 2‚Äì3 thoughts for today in one message.\n\n/cancel ‚Äî cancel",
        )
    )

@router.message(Command("cancel"))
async def journal_cancel(m: Message, state: FSMContext, lang: str):
    await state.clear()
    await m.answer(
        _tr(
            lang,
            "–û—Ç–º–µ–Ω–∏–ª. –ó–∞–ø–∏—Å—å –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.",
            "–°–∫–∞—Å—É–≤–∞–≤. –ó–∞–ø–∏—Å –Ω–µ –∑–±–µ—Ä–µ–∂–µ–Ω–æ.",
            "Cancelled. Entry not saved.",
        ),
        reply_markup=get_main_kb(lang),
    )

@router.message(JournalFSM.waiting_text, F.text)
async def journal_save(
    m: Message,
    state: FSMContext,
    session: AsyncSession,
    lang: str,
):
    # –Æ–∑–µ—Ä –∏ —Å–æ–≥–ª–∞—Å–∏–µ
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()

    if not user or not user.consent_accepted_at:
        await state.clear()
        return await m.answer(
            _tr(
                lang,
                "–ù—É–∂–Ω–æ –ø—Ä–∏–Ω—è—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É: –Ω–∞–∂–º–∏ üîí Privacy",
                "–ü–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫—É: –Ω–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
                "You need to accept the policy: tap üîí Privacy",
            ),
            reply_markup=get_main_kb(getattr(user, "locale", None) or lang if user else lang),
        )

    text = (m.text or "").strip()
    if len(text) < 3:
        # —Å–ª–∏—à–∫–æ–º –ø—É—Å—Ç–æ ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –∏ –ø—Ä–æ—Å–∏–º –¥–æ–ø–∏—Å–∞—Ç—å
        return await m.answer(
            _tr(
                lang,
                "–ö–æ—Ä–æ—Ç–∫–æ–≤–∞—Ç–æ. –î–æ–±–∞–≤—å –¥–µ—Ç–∞–ª–µ–π –∏ –æ—Ç–ø—Ä–∞–≤—å –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
                "–ó–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫–æ. –î–æ–¥–∞–π –¥–µ—Ç–∞–ª–µ–π —ñ –Ω–∞–¥—ñ—à–ª–∏ –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.",
                "Too short. Add a bit more detail and send again in one message.",
            )
        )

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–ø–∏—Å—å
    entry = JournalEntry(user_id=user.id, text=text)
    session.add(entry)
    await session.commit()

    # –ü—Ä–µ–º–∏—É–º-—Ç—Ä–∏–∞–ª (–º—è–≥–∫–æ, –±–µ–∑ –ø–∞–¥–µ–Ω–∏–π)
    try:
        await maybe_grant_trial(session, user, m.bot)
    except Exception:
        pass

    await state.clear()

    # –ü—Ä–æ—Å—Ç–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    total = (
        await session.execute(
            select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
        )
    ).scalar() or 0

    await m.answer(
        _tr(
            lang,
            f"–°–æ—Ö—Ä–∞–Ω–∏–ª. –ó–∞–ø–∏—Å–µ–π –≤—Å–µ–≥–æ: {total}.\n\n/stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, /remind ‚Äî —Å–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.",
            f"–ó–±–µ—Ä—ñ–≥. –ó–∞–ø–∏—Å—ñ–≤ –≤—Å—å–æ–≥–æ: {total}.\n\n/stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, /remind ‚Äî —Å—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è.",
            f"Saved. Total entries: {total}.\n\n/stats ‚Äî stats, /remind ‚Äî create a reminder.",
        ),
        reply_markup=get_main_kb(getattr(user, "locale", None) or lang),
    )

@router.message(Command("stats"))
async def journal_stats(m: Message, session: AsyncSession, lang: str):
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    if not user:
        return await m.answer(_tr(lang, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"))

    total = (
        await session.execute(
            select(func.count()).select_from(JournalEntry).where(JournalEntry.user_id == user.id)
        )
    ).scalar() or 0

    await m.answer(
        _tr(
            lang,
            f"–ó–∞–ø–∏—Å–µ–π –≤—Å–µ–≥–æ: {total}. –ü—Ä–æ–¥–æ–ª–∂–∞–π –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!",
            f"–ó–∞–ø–∏—Å—ñ–≤ –≤—Å—å–æ–≥–æ: {total}. –ü—Ä–æ–¥–æ–≤–∂—É–π —É —Ç–æ–º—É –∂ –¥—É—Å—ñ!",
            f"Total entries: {total}. Keep it up!",
        )
    )
==========================================================================================
# app/handlers/language.py
==========================================================================================
# app/handlers/language.py
from __future__ import annotations
from aiogram import Router, F
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.user import User
from app.keyboards import get_main_kb, is_language_btn

router = Router()

ALIASES = {
    "ru":"ru","rus":"ru","—Ä—É":"ru","—Ä—É—Å":"ru","—Ä—É—Å—Å–∫–∏–π":"ru","—Ä–æ—Å—ñ–π—Å—å–∫–∞":"ru",
    "uk":"uk","ua":"uk","—É–∫":"uk","—É–∫—Ä":"uk","—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞":"uk","—É–∫—Ä–∞–∏–Ω—Å–∫–∏–π":"uk",
    "en":"en","eng":"en","–∞–Ω–≥–ª":"en","–∞–Ω–≥–ª–∏–π—Å–∫–∏–π":"en","–∞–Ω–≥–ª—ñ–π—Å—å–∫–∞":"en","english":"en",
}
PROMPT = {
    "ru": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫: RU / UK / EN (–º–æ–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å: —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / english)",
    "uk": "–í–∏–±–µ—Ä–∏ –º–æ–≤—É: RU / UK / EN (–º–æ–∂–Ω–∞ –Ω–∞–ø–∏—Å–∞—Ç–∏: —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / —Ä—É—Å—Å–∫–∏–π / english)",
    "en": "Choose language: RU / UK / EN (you can type: english / —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞)",
}

def _pick_locale(u: User | None) -> str:
    l = (u.locale if u and getattr(u, "locale", None) else "ru").split("-")[0].lower()
    if l == "ua": l = "uk"
    return l if l in {"ru","uk","en"} else "ru"

@router.message(F.text.func(lambda s: s and (s.strip().lower() in {"/language","language","—è–∑—ã–∫","–º–æ–≤–∞"} or is_language_btn(s))))
async def language_start(m: Message, session: AsyncSession):
    user = (await session.execute(select(User).where(User.tg_id == m.from_user.id))).scalar_one_or_none()
    loc = _pick_locale(user)
    await m.answer(PROMPT[loc], reply_markup=None)

@router.message(F.text.func(lambda s: (s or "").strip().lower() in ALIASES))
async def language_set(m: Message, session: AsyncSession):
    code = ALIASES[(m.text or "").strip().lower()]
    user = (await session.execute(select(User).where(User.tg_id == m.from_user.id))).scalar_one_or_none()
    if not user:
        user = User(tg_id=m.from_user.id, locale=code, lang=code)
        session.add(user)
    else:
        user.locale = code
        user.lang = code
        session.add(user)
    await session.commit()
    msg = {"ru":"–ì–æ—Ç–æ–≤–æ. –Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª—ë–Ω.","uk":"–ì–æ—Ç–æ–≤–æ. –ú–æ–≤—É –æ–Ω–æ–≤–ª–µ–Ω–æ.","en":"Done. Language updated."}[code]
    await m.answer(msg, reply_markup=get_main_kb(code))
==========================================================================================
# app/handlers/premium.py
==========================================================================================
# app/handlers/premium.py
from __future__ import annotations
import os
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

from app.config import settings
from app.keyboards import get_main_kb, is_premium_btn

router = Router()

CHANNEL_USERNAME = (
    os.getenv("PREMIUM_CHANNEL")
    or getattr(settings, "premium_channel", None)
    or "@NoticesDiarY"
)
CHANNEL_URL = f"https://t.me/{CHANNEL_USERNAME.lstrip('@')}"

# ‚Äî i18n fallback ‚Äî
try:
    from app.lang import t  # type: ignore
except Exception:
    try:
        from app.i18n import t  # type: ignore
    except Exception:
        _DEF = {
            "premium_on": {
                "ru": "–ü—Ä–µ–º–∏—É–º —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω ‚úÖ",
                "uk": "–ü—Ä–µ–º—ñ—É–º —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π ‚úÖ",
                "en": "Premium is already active ‚úÖ",
            },
            "premium_on_till": {
                "ru": "–ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω –¥–æ {dt} ({tz}) ‚úÖ",
                "uk": "–ü—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–Ω–∏–π –¥–æ {dt} ({tz}) ‚úÖ",
                "en": "Premium is active until {dt} ({tz}) ‚úÖ",
            },
            "subscribe_offer": {
                "ru": "–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî –∏ –ø–æ–ª—É—á–∏ 24 —á–∞—Å–∞ –ø—Ä–µ–º–∏—É–º–∞ üéÅ",
                "uk": "–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –ü—ñ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª ‚Äî —ñ –æ—Ç—Ä–∏–º–∞–π 24 –≥–æ–¥–∏–Ω–∏ –ø—Ä–µ–º—ñ—É–º—É üéÅ",
                "en": "Premium is off. Subscribe to our channel and get 24h of Premium üéÅ",
            },
            "sub_given": {
                "ru": "–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî –ø—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞ ‚úÖ",
                "uk": "–í—ñ—Ç–∞—é! –ü—ñ–¥–ø–∏—Å–∫—É –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ ‚Äî –ø—Ä–µ–º—ñ—É–º –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ ‚úÖ",
                "en": "Congrats! Subscription confirmed ‚Äî Premium activated for 24 hours ‚úÖ",
            },
            "sub_not_found": {
                "ru": "–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫–∏. –ù–∞–∂–º–∏ ¬´–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è¬ª, –∑–∞—Ç–µ–º ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å¬ª.",
                "uk": "–ù–µ –±–∞—á—É –ø—ñ–¥–ø–∏—Å–∫–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è¬ª, –ø–æ—Ç—ñ–º ¬´–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏¬ª.",
                "en": "I can‚Äôt see your subscription. Tap ‚ÄúSubscribe‚Äù then ‚ÄúCheck‚Äù.",
            },
            "btn_pay":   {"ru":"–û–ø–ª–∞—Ç–∏—Ç—å","uk":"–û–ø–ª–∞—Ç–∏—Ç–∏","en":"Pay"},
            "btn_sub":   {"ru":"–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è","uk":"–ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è","en":"Subscribe"},
            "btn_check": {"ru":"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å","uk":"–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏","en":"Check"},
        }
        def t(lang: str, key: str, **fmt) -> str:
            l = (lang or "ru")[:2].lower()
            v = _DEF.get(key, {})
            if isinstance(v, dict):
                txt = v.get(l) or v.get("ru") or key
                return txt.format(**fmt) if fmt else txt
            return str(v)

_SUPPORTED = {"ru","uk","en"}

def _lang_of(u: dict | None, m: Message | CallbackQuery | None) -> str:
    if isinstance(u, dict) and u.get("lang"):
        l = (u["lang"] or "ru")[:2].lower()
    else:
        code = None
        if isinstance(m, Message):
            code = getattr(getattr(m, "from_user", None), "language_code", None)
        elif isinstance(m, CallbackQuery):
            code = getattr(getattr(m, "from_user", None), "language_code", None) or getattr(getattr(m.message, "from_user", None), "language_code", None)
        l = (code or getattr(settings, "default_locale", "ru"))[:2].lower()
    if l == "ua": l = "uk"
    return l if l in _SUPPORTED else "ru"

async def _ensure_premium_columns(session: AsyncSession) -> None:
    for ddl in (
        "ALTER TABLE users ADD COLUMN premium_until TIMESTAMP",
        "ALTER TABLE users ADD COLUMN is_premium INTEGER DEFAULT 0",
    ):
        try:
            await session.execute(sql_text(ddl))
        except Exception:
            pass
    try: await session.commit()
    except Exception: await session.rollback()

async def _fetch_user(session: AsyncSession, tg_id: int) -> dict:
    await _ensure_premium_columns(session)
    row = (await session.execute(sql_text(
        "SELECT id, tg_id, lang, is_premium, premium_until, tz FROM users WHERE tg_id=:tg"
    ), {"tg": tg_id})).first()
    if row:
        id_, tg, lang, is_premium, premium_until, tz = row
        return {
            "id": id_, "tg_id": tg, "lang": lang, "is_premium": bool(is_premium),
            "premium_until": premium_until, "tz": tz or getattr(settings, "default_tz", "Europe/Kyiv")
        }
    await session.execute(sql_text("INSERT INTO users (tg_id, lang, is_premium) VALUES (:tg, :lang, 0)"),
                          {"tg": tg_id, "lang": "ru"})
    await session.commit()
    return {"id": None, "tg_id": tg_id, "lang": "ru", "is_premium": False, "premium_until": None,
            "tz": getattr(settings, "default_tz", "Europe/Kyiv")}

def _to_dt_aware(v) -> datetime | None:
    if v is None: return None
    if isinstance(v, datetime):
        return v if v.tzinfo else v.replace(tzinfo=timezone.utc)
    try:
        dt = datetime.fromisoformat(str(v).replace("Z","+00:00"))
        return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)
    except Exception:
        return None

def _is_active(u: dict) -> bool:
    if not u.get("is_premium"): return False
    until = _to_dt_aware(u.get("premium_until"))
    return True if until is None else (datetime.now(timezone.utc) < until)

def _fmt_local(dt_utc: datetime, tz_name: str) -> str:
    try: return dt_utc.astimezone(ZoneInfo(tz_name)).strftime("%Y-%m-%d %H:%M")
    except Exception: return dt_utc.astimezone(ZoneInfo("Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")

def _pay_kb(lang: str, tg_id: int) -> InlineKeyboardMarkup:
    base = getattr(settings, "public_url", None) or os.environ.get("PUBLIC_URL", "").strip()
    if not base.startswith("https://"): base = "https://example.com"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t(lang,"btn_pay"), url=f"{base}/pay?tg_id={tg_id}")]
    ])

def _subscribe_kb(lang: str, tg_id: int) -> InlineKeyboardMarkup:
    base = getattr(settings, "public_url", "") or "https://example.com"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=t(lang,"btn_sub"), url=CHANNEL_URL)],
        [InlineKeyboardButton(text=t(lang,"btn_check"), callback_data="premium:check")],
        [InlineKeyboardButton(text=t(lang,"btn_pay"), url=f"{base}/pay?tg_id={tg_id}")],
    ])

async def _grant_24h(session: AsyncSession, tg_id: int) -> None:
    await _ensure_premium_columns(session)
    until = datetime.now(timezone.utc) + timedelta(days=1)
    await session.execute(sql_text("UPDATE users SET is_premium=1, premium_until=:u WHERE tg_id=:tg"),
                          {"u": until, "tg": tg_id})
    await session.commit()

async def _user_is_channel_member(bot, user_id: int) -> bool:
    try:
        cm = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        status = getattr(cm, "status", None)
        status = getattr(status, "value", status)
        return str(status) in {"member","administrator","creator"}
    except Exception:
        return False

async def maybe_grant_trial(session: AsyncSession, tg_id: int) -> None:
    u = await _fetch_user(session, tg_id)
    if not _is_active(u):
        await _grant_24h(session, tg_id)

PREMIUM_TRIGGERS = {"premium","üíé premium","–ø—Ä–µ–º–∏—É–º","üíé –ø—Ä–µ–º–∏—É–º","–ø—Ä–µ–º—ñ—É–º","üíé –ø—Ä–µ–º—ñ—É–º"}

@router.message(Command("premium"))
@router.message(F.text.func(lambda s: s and (s.strip().lower() in PREMIUM_TRIGGERS or is_premium_btn(s))))
async def cmd_premium(m: Message, session: AsyncSession):
    u = await _fetch_user(session, m.from_user.id)
    lang = _lang_of(u, m)

    if _is_active(u):
        until = _to_dt_aware(u.get("premium_until"))
        if until:
            dt_local = _fmt_local(until, u.get("tz") or "Europe/Kyiv")
            await m.answer(t(lang,"premium_on_till", dt=dt_local, tz=(u.get("tz") or "Europe/Kyiv")),
                           reply_markup=get_main_kb(lang))
            return
        await m.answer(t(lang,"premium_on"), reply_markup=get_main_kb(lang))
        return

    await m.answer(t(lang,"subscribe_offer"), reply_markup=_subscribe_kb(lang, m.from_user.id))

@router.callback_query(F.data == "premium:check")
async def premium_check(c: CallbackQuery, session: AsyncSession):
    u = await _fetch_user(session, c.from_user.id)
    lang = _lang_of(u, c)
    try:
        is_member = await _user_is_channel_member(c.bot, c.from_user.id)
        await c.answer()
    except Exception:
        is_member = False
        await c.answer()
    if is_member:
        await _grant_24h(session, c.from_user.id)
        await c.message.answer(t(lang,"sub_given"), reply_markup=get_main_kb(lang))
    else:
        await c.message.answer(t(lang,"sub_not_found"), reply_markup=_subscribe_kb(lang, c.from_user.id))
==========================================================================================
# app/handlers/privacy.py
==========================================================================================
# app/handlers/privacy.py
from __future__ import annotations

from datetime import datetime, timezone
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text as sql_text

from app.keyboards import (
    get_main_kb, PRIVACY_LABELS,
)
from app.models.user import User

router = Router()

TXT = {
    "ru": (
        "–≠—Ç–æ –∂—É—Ä–Ω–∞–ª-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, –Ω–µ —Ç–µ—Ä–∞–ø–∏—è –∏ –Ω–µ –º–µ–¥—É—Å–ª—É–≥–∞.\n"
        "–ù–∞–∂–∏–º–∞—è <b>Agree</b>, –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ –∏ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ –ü–æ–ª–∏—Ç–∏–∫—É.\n"
        "–ö–æ–º–∞–Ω–¥—ã: /journal ‚Äî –∑–∞–ø–∏—Å—å, /remind ‚Äî –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ, /stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞.\n\n"
        "–û—Ç–≤–µ—Ç—å: <b>Agree</b> / <b>Disagree</b>"
    ),
    "uk": (
        "–¶–µ —â–æ–¥–µ–Ω–Ω–∏–∫-–∞—Å–∏—Å—Ç–µ–Ω—Ç, –Ω–µ —Ç–µ—Ä–∞–ø—ñ—è —ñ –Ω–µ –º–µ–¥–∏—á–Ω–∞ –ø–æ—Å–ª—É–≥–∞.\n"
        "–ù–∞—Ç–∏—Å–∫–∞—é—á–∏ <b>Agree</b>, –≤–∏ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂—É—î—Ç–µ —Ä–æ–∑—É–º—ñ–Ω–Ω—è —ñ –ø—Ä–∏–π–º–∞—î—Ç–µ –ü–æ–ª—ñ—Ç–∏–∫—É.\n"
        "–ö–æ–º–∞–Ω–¥–∏: /journal ‚Äî –∑–∞–ø–∏—Å, /remind ‚Äî –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è, /stats ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞.\n\n"
        "–í—ñ–¥–ø–æ–≤—ñ–¥—å: <b>Agree</b> / <b>Disagree</b>"
    ),
    "en": (
        "This is a journal assistant, not therapy or a medical service.\n"
        "By pressing <b>Agree</b> you confirm understanding and accept the Policy.\n"
        "Commands: /journal ‚Äî entry, /remind ‚Äî reminder, /stats ‚Äî stats.\n\n"
        "Reply: <b>Agree</b> / <b>Disagree</b>"
    ),
}

AGREE  = {"agree", "–ø—Ä–∏–Ω—è—Ç—å", "—Å–æ–≥–ª–∞—Å–µ–Ω", "–∑–≥–æ–¥–µ–Ω", "–ø—Ä–∏–π–º–∞—é", "ok", "–¥–∞"}
DECLINE= {"disagree", "–æ—Ç–∫–ª–æ–Ω–∏—Ç—å", "–Ω–µ —Å–æ–≥–ª–∞—Å–µ–Ω", "–≤—ñ–¥—Ö–∏–ª–∏—Ç–∏", "–Ω—ñ", "no"}

def _lang_of(user: User | None, m: Message) -> str:
    if user and getattr(user, "locale", None):
        l = (user.locale or "ru")[:2].lower()
    else:
        l = (getattr(getattr(m, "from_user", None), "language_code", "") or "ru")[:2].lower()
    return "uk" if l == "ua" else (l if l in {"ru","uk","en"} else "ru")

def _yn_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="Agree"), KeyboardButton(text="Disagree")]],
        resize_keyboard=True
    )

@router.message(Command("privacy"))
@router.message(F.text.in_(PRIVACY_LABELS))
async def show_privacy(m: Message, session: AsyncSession):
    user = (await session.execute(
        sql_text("SELECT id, locale FROM users WHERE tg_id=:tg"), {"tg": m.from_user.id}
    )).first()
    u = None
    if user:
        # –ø—Ä–æ—Å—Ç–æ–π –æ–±—ä–µ–∫—Ç-–∑–∞–≥–ª—É—à–∫–∞ —Å –Ω—É–∂–Ω—ã–º–∏ –ø–æ–ª—è–º–∏
        class U: ...
        u = U(); u.locale = user[1]

    lang = _lang_of(u, m)
    await m.answer(TXT[lang], reply_markup=_yn_kb())

@router.message(F.text.func(lambda s: (s or "").strip().lower() in AGREE | DECLINE))
async def privacy_answer(m: Message, session: AsyncSession):
    txt = (m.text or "").strip().lower()
    is_agree = txt in AGREE

    if is_agree:
        await session.execute(
            sql_text("UPDATE users SET consent_accepted_at=:ts WHERE tg_id=:tg"),
            {"ts": datetime.now(timezone.utc), "tg": m.from_user.id},
        )
        await session.commit()

    # –≤–µ—Ä–Ω—ë–º –æ—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é –Ω–∞ —Ç–µ–∫—É—â–µ–º —è–∑—ã–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    row = (await session.execute(
        sql_text("SELECT COALESCE(locale,'ru') FROM users WHERE tg_id=:tg"),
        {"tg": m.from_user.id}
    )).first()
    lang = (row[0] if row else "ru")[:2].lower()
    if lang == "ua": lang = "uk"

    msg = {
        True: {"ru": "–°–ø–∞—Å–∏–±–æ! –ü–æ–ª–∏—Ç–∏–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞ ‚úÖ", "uk": "–î—è–∫—É—é! –ü–æ–ª—ñ—Ç–∏–∫–∞ –ø—Ä–∏–π–Ω—è—Ç–∞ ‚úÖ", "en": "Thanks! Policy accepted ‚úÖ"},
        False: {"ru": "–û–∫. –ü–æ–ª–∏—Ç–∏–∫–∞ –Ω–µ –ø—Ä–∏–Ω—è—Ç–∞.", "uk": "–û–∫. –ü–æ–ª—ñ—Ç–∏–∫–∞ –Ω–µ –ø—Ä–∏–π–Ω—è—Ç–∞.", "en": "Okay. Policy not accepted."},
    }[is_agree].get(lang, "OK")

    await m.answer(msg, reply_markup=get_main_kb(lang))
==========================================================================================
# app/handlers/reminders.py
==========================================================================================
# app/handlers/remind.py
from __future__ import annotations

from datetime import datetime, timezone
from zoneinfo import ZoneInfo

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, and_

from app.models.user import User
from app.models.reminder import Reminder
from app.services.nlp import parse_any
from app.services.reminders import (
    compute_next_run,
    to_local,
    to_utc,
    now_utc as now_utc_fn,  # –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ–º –∏–º–µ–Ω–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
)
from app.handlers.premium import maybe_grant_trial

router = Router()

SUPPORTED = {"ru", "uk", "en"}


def _tr(lang: str | None, ru: str, uk: str, en: str) -> str:
    l = (lang or "ru").lower()[:2]
    if l == "uk":
        return uk
    if l == "en":
        return en
    return ru


async def _get_lang(session: AsyncSession, m: Message, fallback: str | None = None) -> str:
    """–ë–µ—Ä—ë–º —è–∑—ã–∫ –∏–∑ –ë–î (users.lang) -> –∏–∑ Telegram -> fallback -> ru."""
    tg = getattr(getattr(m, "from_user", None), "id", None)
    code = getattr(getattr(m, "from_user", None), "language_code", None)
    db_lang = None
    if tg:
        try:
            res = await session.execute(select(User.lang).where(User.tg_id == tg))
            db_lang = res.scalar_one_or_none()
        except Exception:
            db_lang = None
    l = (db_lang or code or fallback or "ru")[:2].lower()
    return l if l in SUPPORTED else "ru"


def _fmt_local(dt_utc: datetime, tz_name: str) -> str:
    return to_local(dt_utc, tz_name).strftime("%Y-%m-%d %H:%M")


# ----- HELP -----
@router.message(Command("remind"))
async def remind_help(m: Message, session: AsyncSession, lang: str | None = None):
    l = lang or await _get_lang(session, m)
    await m.answer(
        _tr(
            l,
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            "‚Ä¢ ¬´–Ω–∞–ø–æ–º–Ω–∏ –≤–æ–¥—É –≤ 12:00¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–ø–æ–º–Ω–∏ –ø–æ–∑–≤–æ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç –ø–æ –±—É–¥–Ω—è–º –≤ 10:00¬ª\n"
            "‚Ä¢ ¬´–≤—ã–∫–ª—é—á–∏ –≤—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è¬ª / ¬´–≤–∫–ª—é—á–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤–æ–¥–∞¬ª",
            "–ü—Ä–∏–∫–ª–∞–¥–∏:\n"
            "‚Ä¢ ¬´–Ω–∞–≥–∞–¥–∞–π –≤–æ–¥—É –æ 12:00¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–≥–∞–¥–∞–π –ø–æ–¥–∑–≤–æ–Ω–∏—Ç–∏ —á–µ—Ä–µ–∑ 15 —Ö–≤–∏–ª–∏–Ω¬ª\n"
            "‚Ä¢ ¬´–Ω–∞–≥–∞–¥–∞–π –∑–≤—ñ—Ç –ø–æ –±—É–¥–Ω—è—Ö –æ 10:00¬ª\n"
            "‚Ä¢ ¬´–≤–∏–º–∫–Ω–∏ –≤—Å—ñ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è¬ª / ¬´—É–≤—ñ–º–∫–Ω–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –≤–æ–¥–∞¬ª",
            "Examples:\n"
            "‚Ä¢ ‚Äúremind water at 12:00‚Äù\n"
            "‚Ä¢ ‚Äúremind to call in 15 minutes‚Äù\n"
            "‚Ä¢ ‚Äúremind report weekdays at 10:00‚Äù\n"
            "‚Ä¢ ‚Äúdisable all reminders‚Äù / ‚Äúenable reminders water‚Äù",
        ),
        parse_mode=None,
    )


# ----- TRIGGERS -----
_TRIGGER_WORDS: tuple[str, ...] = (
    "–Ω–∞–ø–æ–º–Ω–∏",
    "–Ω–∞–≥–∞–¥–∞–π",
    "remind",
    "–≤–∫–ª—é—á–∏",
    "–≤–∫–ª",
    "—É–≤—ñ–º–∫–Ω–∏",
    "enable",
    "on",
    "–≤—ã–∫–ª—é—á–∏",
    "–≤—ã–∫–ª",
    "–≤—ñ–¥–∫–ª—é—á–∏",
    "–≤–∏–º–∫–Ω–∏",
    "disable",
    "off",
)


def _has_trigger(s: str | None) -> bool:
    return bool(s) and any(w in s.lower() for w in _TRIGGER_WORDS)


@router.message(F.text.func(_has_trigger))
async def remind_parse(m: Message, session: AsyncSession, lang: str | None = None):
    # 1) –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å + —Å–æ–≥–ª–∞—Å–∏–µ
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()

    l = lang or await _get_lang(session, m)

    if not user or not user.consent_accepted_at:
        return await m.answer(
            _tr(
                l,
                "–ù—É–∂–Ω–æ –ø—Ä–∏–Ω—è—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É: –Ω–∞–∂–º–∏ üîí Privacy",
                "–ü–æ—Ç—Ä—ñ–±–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–∏ –ø–æ–ª—ñ—Ç–∏–∫—É: –Ω–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
                "You need to accept the policy: tap üîí Privacy",
            ),
            parse_mode=None,
        )

    tz_name = user.tz or "Europe/Kyiv"
    now_utc = now_utc_fn()  # UTC –º–æ–º–µ–Ω—Ç
    now_local = now_utc.astimezone(ZoneInfo(tz_name))  # –ª–æ–∫–∞–ª—å–Ω—ã–π ¬´—Å–µ–π—á–∞—Å¬ª –¥–ª—è –ø–∞—Ä—Å–µ—Ä–∞

    # 2) –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥: create / enable / disable
    parsed = parse_any(m.text, user_tz=tz_name, now=now_local)
    if not parsed:
        return await m.answer(
            _tr(
                l,
                "–ù–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –ù–∞–ø–∏—à–∏: ¬´–Ω–∞–ø–æ–º–Ω–∏ <—á—Ç–æ> –≤/—á–µ—Ä–µ–∑ <–∫–æ–≥–¥–∞>¬ª –∏–ª–∏ ¬´–≤–∫–ª—é—á–∏/–≤—ã–∫–ª—é—á–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è [–ø—Ä–æ <—á—Ç–æ>]¬ª.",
                "–ù–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤ –∫–æ–º–∞–Ω–¥—É. –ù–∞–ø–∏—à–∏: ¬´–Ω–∞–≥–∞–¥–∞–π <—â–æ> –æ/—á–µ—Ä–µ–∑ <–∫–æ–ª–∏>¬ª –∞–±–æ ¬´—É–≤—ñ–º–∫–Ω–∏/–≤–∏–º–∫–Ω–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è [–ø—Ä–æ <—â–æ>]¬ª.",
                "Didn't understand. Use ‚Äúremind <what> at/in <when>‚Äù or ‚Äúenable/disable reminders [about <what>]‚Äù.",
            ),
            parse_mode=None,
        )

    # === ENABLE / DISABLE ===
    if parsed.intent in ("enable", "disable"):
        action_enable = parsed.intent == "enable"
        q = (parsed.toggle.query or "").strip() if getattr(parsed, "toggle", None) else ""
        is_all = bool(getattr(parsed, "toggle", None) and parsed.toggle.all)

        filters = [Reminder.user_id == user.id]
        if not is_all and q:
            cond = getattr(Reminder.title, "ilike", None)
            filters.append(cond(f"%{q}%") if cond else Reminder.title.like(f"%{q}%"))

        to_update = (
            await session.execute(select(Reminder).where(and_(*filters)))
        ).scalars().all()

        if not to_update:
            return await m.answer(
                _tr(l, "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à—ë–ª –ø–æ –∑–∞–ø—Ä–æ—Å—É.", "–ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π—à–æ–≤ –∑–∞ –∑–∞–ø–∏—Ç–æ–º.", "Found nothing to update."),
                parse_mode=None,
            )

        await session.execute(update(Reminder).where(and_(*filters)).values(is_active=action_enable))

        if action_enable:
            changed = 0
            for r in to_update:
                if r.cron and (r.next_run is None or r.next_run <= now_utc):
                    nxt = compute_next_run(r.cron, now_utc, tz_name)
                    if nxt:
                        r.next_run = nxt
                        session.add(r)
                        changed += 1
            await session.commit()
        else:
            await session.commit()

        cnt = len(to_update)
        return await m.answer(
            _tr(
                l,
                f"{'–í–∫–ª—é—á–∏–ª' if action_enable else '–í—ã–∫–ª—é—á–∏–ª'} {cnt} –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.",
                f"{'–£–≤—ñ–º–∫–Ω—É–≤' if action_enable else '–í–∏–º–∫–Ω—É–≤'} {cnt} –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å.",
                f"{'Enabled' if action_enable else 'Disabled'} {cnt} reminder(s).",
            )
        )

    # === CREATE ===
    pr = parsed.reminder
    if not pr:
        return await m.answer(
            _tr(l, "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.", "–ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑—ñ–±—Ä–∞—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è.", "Couldn't parse the reminder."),
            parse_mode=None,
        )

    next_run_utc: datetime | None = None
    cron: str | None = None

    if pr.cron:
        cron = pr.cron
        next_run_utc = compute_next_run(cron, now_utc, tz_name)
        if not next_run_utc:
            return await m.answer(
                _tr(
                    l,
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã—á–∏—Å–ª–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ü—Ä–∏–º–µ—Ä: ¬´–∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 09:00¬ª, ¬´–ø–æ –±—É–¥–Ω—è–º –≤ 10:00¬ª.",
                    "–ù–µ –≤–¥–∞–ª–æ—Å—è –æ–±—á–∏—Å–ª–∏—Ç–∏ —Ä–æ–∑–∫–ª–∞–¥. –ü—Ä–∏–∫–ª–∞–¥: ¬´—â–æ–¥–Ω—è –æ 09:00¬ª, ¬´–ø–æ –±—É–¥–Ω—è—Ö –æ 10:00¬ª.",
                    "Couldn't compute schedule. E.g., ‚Äúdaily at 09:00‚Äù, ‚Äúweekdays at 10:00‚Äù.",
                ),
                parse_mode=None,
            )
    else:
        dt = getattr(pr, "next_run_utc", None)
        if not isinstance(dt, datetime):
            return await m.answer(
                _tr(
                    l,
                    "–ù–µ –ø–æ–Ω—è–ª –≤—Ä–µ–º—è. –ü—Ä–∏–º–µ—Ä—ã: ¬´–≤ 12:30¬ª, ¬´–∑–∞–≤—Ç—Ä–∞ –≤ 9¬ª, ¬´—á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç¬ª.",
                    "–ù–µ –∑—Ä–æ–∑—É–º—ñ–≤ —á–∞—Å. –ü—Ä–∏–∫–ª–∞–¥–∏: ¬´–æ 12:30¬ª, ¬´–∑–∞–≤—Ç—Ä–∞ –æ 9¬ª, ¬´—á–µ—Ä–µ–∑ 15 —Ö–≤–∏–ª–∏–Ω¬ª.",
                    "Couldn't recognise time. Examples: ‚Äúat 12:30‚Äù, ‚Äútomorrow 9‚Äù, ‚Äúin 15 minutes‚Äù.",
                ),
                parse_mode=None,
            )
        next_run_utc = to_utc(dt, tz_name)

    # –î–µ–¥—É–ø: –∞–∫—Ç–∏–≤–Ω–æ–µ —Å —Ç–µ–º –∂–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º –∏ —Ç–∞–∫–∏–º –∂–µ —Ç–∏–ø–æ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
    dup = (
        await session.execute(
            select(Reminder).where(
                and_(
                    Reminder.user_id == user.id,
                    Reminder.is_active.is_(True),
                    Reminder.title == pr.what,
                    (Reminder.cron == cron) if cron else (Reminder.cron.is_(None)),
                )
            )
        )
    ).scalar_one_or_none()

    if dup:
        dup.next_run = next_run_utc
        session.add(dup)
        await session.commit()
        local_str = _fmt_local(next_run_utc, tz_name)
        return await m.answer(
            _tr(
                l,
                f"–û–±–Ω–æ–≤–∏–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: ¬´{pr.what}¬ª. –ë–ª–∏–∂–∞–π—à–µ–µ: {local_str} ({tz_name}).",
                f"–û–Ω–æ–≤–∏–≤ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è: ¬´{pr.what}¬ª. –ù–∞–π–±–ª–∏–∂—á–µ: {local_str} ({tz_name}).",
                f"Updated reminder: ‚Äú{pr.what}‚Äù. Next: {local_str} ({tz_name}).",
            )
        )

    r = Reminder(user_id=user.id, title=pr.what, cron=cron, next_run=next_run_utc, is_active=True)
    session.add(r)
    await session.commit()

    # –¢—Ä–∏–∞–ª –∑–∞ –ª—é–±–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ –∏–Ω–∞—á–µ ‚Äî –ø–æ–º–µ–Ω—è–µ–º –ø—Ä–∞–≤–∏–ª–æ)
    try:
        await maybe_grant_trial(session, user.tg_id)
    except Exception:
        pass

    local_str = _fmt_local(next_run_utc, tz_name)
    if cron:
        return await m.answer(
            _tr(
                l,
                f"–ì–æ—Ç–æ–≤–æ! –ë—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å: ¬´{pr.what}¬ª. –ü–µ—Ä–≤—ã–π —Ä–∞–∑: {local_str} ({tz_name}).",
                f"–ì–æ—Ç–æ–≤–æ! –ù–∞–≥–∞–¥—É–≤–∞—Ç–∏–º—É: ¬´{pr.what}¬ª. –ü–µ—Ä—à–∏–π —Ä–∞–∑: {local_str} ({tz_name}).",
                f"Done! I‚Äôll remind: ‚Äú{pr.what}‚Äù. First run: {local_str} ({tz_name}).",
            )
        )
    else:
        return await m.answer(
            _tr(
                l,
                f"–ì–æ—Ç–æ–≤–æ! –ù–∞–ø–æ–º–Ω—é: {pr.what} –≤ {local_str} ({tz_name}).",
                f"–ì–æ—Ç–æ–≤–æ! –ù–∞–≥–∞–¥–∞—é: {pr.what} –æ {local_str} ({tz_name}).",
                f"Done! I‚Äôll remind: {pr.what} at {local_str} ({tz_name}).",
            )
        )


# ----- LIST -----
@router.message(Command("reminders"))
async def reminders_list(m: Message, session: AsyncSession, lang: str | None = None):
    user = (
        await session.execute(select(User).where(User.tg_id == m.from_user.id))
    ).scalar_one_or_none()
    l = lang or await _get_lang(session, m)
    if not user:
        return await m.answer(_tr(l, "–ù–∞–∂–º–∏ /start", "–ù–∞—Ç–∏—Å–Ω–∏ /start", "Press /start"), parse_mode=None)

    tz_name = user.tz or "Europe/Kyiv"
    now_utc = now_utc_fn()

    rows = (await session.execute(select(Reminder).where(Reminder.user_id == user.id))).scalars().all()
    if not rows:
        return await m.answer(
            _tr(
                l,
                "–ü–æ–∫–∞ –Ω–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π. –ü—Ä–∏–º–µ—Ä: ¬´–Ω–∞–ø–æ–º–Ω–∏ –≤–æ–¥—É –≤ 12:00¬ª.",
                "–ü–æ–∫–∏ –Ω–µ–º–∞—î –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å. –ü—Ä–∏–∫–ª–∞–¥: ¬´–Ω–∞–≥–∞–¥–∞–π –≤–æ–¥—É –æ 12:00¬ª.",
                "No reminders yet. Example: ‚Äúremind water at 12:00‚Äù.",
            ),
            parse_mode=None,
        )

    # –ê–∫—Ç–∏–≤–Ω—ã–µ –≤–≤–µ—Ä—Ö, –∑–∞—Ç–µ–º –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è; None –≤ –∫–æ–Ω–µ—Ü
    rows.sort(key=lambda r: (0 if r.is_active else 1, r.next_run.timestamp() if r.next_run else float("inf")))

    lines: list[str] = []
    for r in rows[:10]:
        status = "‚úÖ" if r.is_active else "‚è∏Ô∏è"
        when = "-"
        if r.next_run:
            when = _fmt_local(r.next_run, tz_name)
            if r.next_run <= now_utc:
                when += " ‚ö†Ô∏è"
        elif r.cron and r.is_active:
            nxt = compute_next_run(r.cron, now_utc, tz_name)
            when = _fmt_local(nxt, tz_name) if nxt else "-"
        lines.append(f"{status} {r.title} ‚Äî {when}")

    await m.answer("\n".join(lines), parse_mode=None)
==========================================================================================
# app/handlers/report.py
==========================================================================================
# app/handlers/report.py
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, ForceReply
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.bug_report import BugReport
from app.models.user import User
from app.keyboards import get_main_kb
from app.config import settings

router = Router()

class ReportFSM(StatesGroup):
    waiting_text = State()

TEXTS = {
    "ru": {
        "ask": (
            "–û–ø–∏—à–∏, —á—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç/—á—Ç–æ —É–ª—É—á—à–∏—Ç—å. –ú–æ–∂–Ω–æ –ø—Ä–∏–ª–æ–∂–∏—Ç—å —Å–∫—Ä–∏–Ω/—Ñ–∞–π–ª.\n"
            "–û—Ç–ø—Ä–∞–≤—å —Å–æ–æ–±—â–µ–Ω–∏–µ–º –Ω–∏–∂–µ üëá"
        ),
        "saved": "–°–ø–∞—Å–∏–±–æ! –†–µ–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –ú—ã –ø–æ—Å–º–æ—Ç—Ä–∏–º –∏ –æ—Ç–≤–µ—Ç–∏–º.",
        "start_first": "–ù–∞–∂–º–∏ /start ‚Äî –∏ –ø–æ–≤—Ç–æ—Ä–∏ —Ä–µ–ø–æ—Ä—Ç.",
        "empty": "–ù—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å –ø–∞—Ä—É —Å–ª–æ–≤ –∫ —Ä–µ–ø–æ—Ä—Ç—É. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ üëá",
    },
    "uk": {
        "ask": (
            "–û–ø–∏—à—ñ—Ç—å, —â–æ –Ω–µ –ø—Ä–∞—Ü—é—î/—â–æ –ø–æ–∫—Ä–∞—â–∏—Ç–∏. –ú–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ —Å–∫—Ä—ñ–Ω/—Ñ–∞–π–ª.\n"
            "–ù–∞–¥—ñ—à–ª—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–∏–∂—á–µ üëá"
        ),
        "saved": "–î—è–∫—É—î–º–æ! –†–µ–ø–æ—Ä—Ç –∑–±–µ—Ä–µ–∂–µ–Ω–æ. –ü–µ—Ä–µ–≥–ª—è–Ω–µ–º–æ —ñ –≤—ñ–¥–ø–æ–≤—ñ–º–æ.",
        "start_first": "–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å /start ‚Äî —ñ –ø–æ–≤—Ç–æ—Ä—ñ—Ç—å —Ä–µ–ø–æ—Ä—Ç.",
        "empty": "–ü–æ—Ç—Ä—ñ–±–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç–∏ –∫—ñ–ª—å–∫–∞ —Å–ª—ñ–≤ –¥–æ —Ä–µ–ø–æ—Ä—Ç—É. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ üëá",
    },
    "en": {
        "ask": (
            "Describe what‚Äôs broken / what to improve. You may attach a screenshot/file.\n"
            "Send your message below üëá"
        ),
        "saved": "Thanks! Bug report saved. We‚Äôll review and reply.",
        "start_first": "Please press /start and send the report again.",
        "empty": "Please add a few words to the report. Try again üëá",
    },
}

def _t(lang: str, key: str) -> str:
    return TEXTS.get(lang, TEXTS["ru"]).get(key, key)

# ---- –¢—Ä–∏–≥–≥–µ—Ä—ã –æ—Ç–∫—Ä—ã—Ç–∏—è —Ñ–æ—Ä–º—ã —Ä–µ–ø–æ—Ä—Ç–∞ ----
# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º: /report, /bug, –∏ —Ç–µ–∫—Å—Ç—ã –∫–Ω–æ–ø–æ–∫ RU/UK/EN —Å/–±–µ–∑ –≤–∞—Ä–∏–∞—Ü–∏–∏ —ç–º–æ–¥–∑–∏ (FE0F)
report_triggers = (
    F.text.regexp(r"(?i)^\s*/(report|bug)\s*$")
    | F.text.regexp(r"(?i)^\s*üõ†\ufe0f?\s*report\s*bug\s*$")
    | F.text.regexp(r"(?i)^\s*üõ†\ufe0f?\s*–ø–æ–≤—ñ–¥–æ–º–∏—Ç–∏\s*–ø—Ä–æ\s*–±–∞–≥\s*$")
    | F.text.regexp(r"^\s*üõ†\ufe0f?\s*Report bug\s*$")
    | F.text.regexp(r"^\s*üõ†\ufe0f?\s*–ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥\s*$")
)

@router.message(Command("report"))
@router.message(Command("bug"))
@router.message(report_triggers)
async def ask_report(m: Message, state: FSMContext, lang: str):
    await state.set_state(ReportFSM.waiting_text)
    await m.answer(_t(lang, "ask"), reply_markup=ForceReply(selective=True))

# ---- –ü—Ä–∏—ë–º —Ä–µ–ø–æ—Ä—Ç–∞: —Ç–µ–∫—Å—Ç –ò–õ–ò –≤–ª–æ–∂–µ–Ω–∏–µ (photo/document/video) ----
content_any = (F.text | F.caption | F.photo | F.document | F.video | F.animation | F.voice | F.audio)

@router.message(ReportFSM.waiting_text, content_any)
async def save_report(m: Message, state: FSMContext, session: AsyncSession, lang: str):
    # –ù–∞–π—Ç–∏ user.id –ø–æ tg_id ‚Äî FK –≤ BugReport
    res = await session.execute(select(User.id).where(User.tg_id == m.from_user.id))
    user_id = res.scalar_one_or_none()
    if not user_id:
        await state.clear()
        return await m.answer(_t(lang, "start_first"), reply_markup=get_main_kb(lang))

    # –¢–µ–∫—Å—Ç –±–µ—Ä—ë–º –∏–∑ text –∏–ª–∏ caption
    text = (m.text or m.caption or "").strip()
    if not text:
        # –µ—Å–ª–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ —á–∏—Å—Ç–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ –±–µ–∑ –ø–æ–¥–ø–∏—Å–∏ ‚Äî –º—è–≥–∫–æ –ø–æ–ø—Ä–æ—Å–∏–º –¥–æ–±–∞–≤–∏—Ç—å –ø–∞—Ä—É —Å–ª–æ–≤
        return await m.answer(_t(lang, "empty"), reply_markup=ForceReply(selective=True))

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î (—Ö—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—É—é —á–∞—Å—Ç—å)
    br = BugReport(user_id=user_id, text=text)
    session.add(br)
    await session.commit()

    # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ ‚Äî —É–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–∞ –∏ –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª —Å –≤–ª–æ–∂–µ–Ω–∏—è–º–∏
    admin_id = None
    try:
        admin_id = int(settings.bot_admin_tg_id) if settings.bot_admin_tg_id else None
    except Exception:
        admin_id = None

    if admin_id:
        uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else str(m.from_user.id)
        preview = (text[:800] + "‚Ä¶") if len(text) > 800 else text

        # 1) –ö–æ—Ä–æ—Ç–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        try:
            await m.bot.send_message(
                admin_id,
                f"üêû Bug report from {uname}\n\n{preview}"
            )
        except Exception:
            pass

        # 2) –ö–æ–ø–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ –≤—Å–µ–º–∏ –≤–ª–æ–∂–µ–Ω–∏—è–º–∏ (–µ—Å–ª–∏ –±—ã–ª–∏)
        try:
            await m.bot.copy_message(
                chat_id=admin_id,
                from_chat_id=m.chat.id,
                message_id=m.message_id
            )
        except Exception:
            # –æ–∫, –±–µ–∑ –ø–∞–Ω–∏–∫–∏ ‚Äî –∏–Ω–æ–≥–¥–∞ –Ω–µ–ª—å–∑—è —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å (–∫–∞–Ω–∞–ª—ã/–ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏)
            pass

    await state.clear()
    await m.answer(_t(lang, "saved"), reply_markup=get_main_kb(lang))

# –ù–µ–±–æ–ª—å—à–æ–π UX: –µ—Å–ª–∏ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ ¬´/cancel¬ª
@router.message(ReportFSM.waiting_text, Command("cancel"))
async def cancel_report(m: Message, state: FSMContext, lang: str):
    await state.clear()
    await m.answer(get_main_kb(lang).input_field_placeholder or "–û–∫, –æ—Ç–º–µ–Ω–∏–ª.", reply_markup=get_main_kb(lang))
==========================================================================================
# app/handlers/start.py
==========================================================================================
# app/handlers/start.py
from __future__ import annotations

import re
from zoneinfo import ZoneInfo
from aiogram import Router
from aiogram.types import Message
from aiogram.filters import CommandStart
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.keyboards import get_main_kb
from app.config import settings

router = Router()

_TEXTS = {
    "ru": {
        "hello_need_privacy": (
            "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –¥–Ω–µ–≤–Ω–∏–∫-–ø–æ–º–æ—â–Ω–∏–∫.\n"
            "–ù–∞–∂–º–∏ <b>üîí –ü–æ–ª–∏—Ç–∏–∫–∞</b>, —á—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å —É—Å–ª–æ–≤–∏—è –∏ –Ω–∞—á–∞—Ç—å.\n"
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
        "hello_ready": (
            "–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å –∑–∞–ø–∏—Å—å –∫–æ–º–∞–Ω–¥–æ–π /journal.\n"
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
    },
    "uk": {
        "hello_need_privacy": (
            "–ü—Ä–∏–≤—ñ—Ç! –¶–µ —â–æ–¥–µ–Ω–Ω–∏–∫-–ø–æ–º—ñ—á–Ω–∏–∫.\n"
            "–ù–∞—Ç–∏—Å–Ω–∏ <b>üîí –ü–æ–ª—ñ—Ç–∏–∫–∞</b>, —â–æ–± –ø—Ä–∏–π–Ω—è—Ç–∏ —É–º–æ–≤–∏ —ñ –ø–æ—á–∞—Ç–∏.\n"
            "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
        "hello_ready": (
            "–ó –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è–º! –ú–æ–∂–µ—à –ø–∏—Å–∞—Ç–∏ –∑–∞–ø–∏—Å –∫–æ–º–∞–Ω–¥–æ—é /journal.\n"
            "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
    },
    "en": {
        "hello_need_privacy": (
            "Hi! This is a journal assistant.\n"
            "Press <b>üîí Privacy</b> to accept the policy and start.\n"
            "Main menu is below."
        ),
        "hello_ready": (
            "Welcome back! You can write an entry with /journal.\n"
            "Main menu is below."
        ),
    },
}

_SUPPORTED_LOCALES = {"ru", "uk", "en"}


def _norm_locale(x: str | None) -> str:
    s = (x or "").split("-")[0].lower()
    if s == "ua":
        s = "uk"
    return s if s in _SUPPORTED_LOCALES else "ru"


def _is_valid_tz(tz: str | None) -> bool:
    if not tz:
        return False
    try:
        ZoneInfo(tz)
        return True
    except Exception:
        return False


def _pick_locale(user: User | None) -> str:
    # settings.default_locale —É –Ω–∞—Å —É–∂–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω –≤ app/config.py
    return _norm_locale((getattr(user, "locale", None)) or settings.default_locale or "ru")


def _parse_start_payload(text: str | None) -> tuple[str | None, str | None]:
    """
    Deep-link: /start lang=uk tz=Europe/Kyiv
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (lang, tz) –∏–ª–∏ (None, None)
    """
    if not text:
        return None, None
    parts = text.split(maxsplit=1)
    payload = parts[1] if len(parts) > 1 else ""
    if not payload:
        return None, None
    m_lang = re.search(r"(?:^|\s)lang=(ru|uk|en|ua)\b", payload, re.I)
    m_tz = re.search(r"(?:^|\s)tz=([\w/\-+]+)", payload, re.I)
    lang = _norm_locale(m_lang.group(1)) if m_lang else None
    tz = m_tz.group(1) if m_tz else None
    return lang, tz


@router.message(CommandStart())
async def cmd_start(m: Message, session: AsyncSession):
    # upsert –ø–æ tg_id
    user = (await session.execute(
        select(User).where(User.tg_id == m.from_user.id)
    )).scalar_one_or_none()

    # –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    lang_dl, tz_dl = _parse_start_payload(m.text or "")
    lang_tele = _norm_locale(getattr(m.from_user, "language_code", None))
    lang_default = _norm_locale(settings.default_locale or "ru")
    tz_default = settings.default_tz or "Europe/Kyiv"

    if not user:
        loc_auto = lang_dl or lang_tele or lang_default
        tz_auto = tz_dl if _is_valid_tz(tz_dl) else tz_default

        user = User(
            tg_id=m.from_user.id,
            locale=loc_auto,
            lang=loc_auto,  # —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –∫–æ–¥–æ–º, —á–∏—Ç–∞—é—â–∏–º users.lang
            tz=tz_auto,
        )
        session.add(user)
        # flush —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å id –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏, –Ω–æ –∑–∞–æ–¥–Ω–æ –∫–æ–º–º–∏—Ç–∏–º –Ω–∏–∂–µ
        await session.flush()
    else:
        changed = False
        if lang_dl and user.locale != lang_dl:
            user.locale = lang_dl
            # —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ–ª—è lang
            if getattr(user, "lang", None) != lang_dl:
                user.lang = lang_dl
            changed = True
        if tz_dl and _is_valid_tz(tz_dl) and user.tz != tz_dl:
            user.tz = tz_dl
            changed = True
        if changed:
            session.add(user)

    # –°—Ä–∞–∑—É —Ñ–∏–∫—Å–∏—Ä—É–µ–º –∞–ø–¥–µ–π—Ç, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –ø—Ä–∏ –ø–∞–¥–µ–Ω–∏–∏ –¥–æ –æ—Ç–≤–µ—Ç–∞
    await session.commit()

    loc = _pick_locale(user)
    kb = get_main_kb(loc) or None

    # –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ —Å —É—á—ë—Ç–æ–º –ø—Ä–∏–Ω—è—Ç–æ–π –ø–æ–ª–∏—Ç–∏–∫–∏
    txt_key = "hello_ready" if getattr(user, "consent_accepted_at", None) else "hello_need_privacy"
    # –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ —Å–ª–æ–≤–∞—Ä—é —Ç–µ–∫—Å—Ç–æ–≤
    txts = _TEXTS.get(loc) or _TEXTS["ru"]
    await m.answer(txts.get(txt_key, _TEXTS["ru"]["hello_need_privacy"]), reply_markup=kb)# app/handlers/start.py

import re
from zoneinfo import ZoneInfo

from aiogram import Router
from aiogram.filters import Command, CommandStart
from aiogram.types import Message
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.keyboards import get_main_kb
from app.config import settings

router = Router()

_TEXTS = {
    "ru": {
        "hello_need_privacy": (
            "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –¥–Ω–µ–≤–Ω–∏–∫-–ø–æ–º–æ—â–Ω–∏–∫.\n"
            "–ù–∞–∂–º–∏ <b>üîí –ü–æ–ª–∏—Ç–∏–∫–∞</b>, —á—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å —É—Å–ª–æ–≤–∏—è –∏ –Ω–∞—á–∞—Ç—å.\n"
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
        "hello_ready": (
            "–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å –∑–∞–ø–∏—Å—å –∫–æ–º–∞–Ω–¥–æ–π /journal.\n"
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
    },
    "uk": {
        "hello_need_privacy": (
            "–ü—Ä–∏–≤—ñ—Ç! –¶–µ —â–æ–¥–µ–Ω–Ω–∏–∫-–ø–æ–º—ñ—á–Ω–∏–∫.\n"
            "–ù–∞—Ç–∏—Å–Ω–∏ <b>üîí –ü–æ–ª—ñ—Ç–∏–∫–∞</b>, —â–æ–± –ø—Ä–∏–π–Ω—è—Ç–∏ —É–º–æ–≤–∏ —ñ –ø–æ—á–∞—Ç–∏.\n"
            "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
        "hello_ready": (
            "–ó –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è–º! –ú–æ–∂–µ—à –ø–∏—Å–∞—Ç–∏ –∑–∞–ø–∏—Å –∫–æ–º–∞–Ω–¥–æ—é /journal.\n"
            "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É."
        ),
    },
    "en": {
        "hello_need_privacy": (
            "Hi! This is a journal assistant.\n"
            "Press <b>üîí Privacy</b> to accept the policy and start.\n"
            "Main menu is below."
        ),
        "hello_ready": (
            "Welcome back! You can write an entry with /journal.\n"
            "Main menu is below."
        ),
    },
}
_SUPPORTED = {"ru","uk","en"}

def _norm_locale(x: str | None) -> str:
    s = (x or "").split("-")[0].lower()
    if s == "ua": s = "uk"
    return s if s in _SUPPORTED else "ru"

def _is_valid_tz(tz: str | None) -> bool:
    if not tz: return False
    try:
        ZoneInfo(tz); return True
    except Exception:
        return False

def _parse_start_payload(text: str | None) -> tuple[str | None, str | None]:
    if not text: return None, None
    parts = (text or "").split(maxsplit=1)
    payload = parts[1] if len(parts) > 1 else ""
    if not payload: return None, None
    m_lang = re.search(r"(?:^|\s)lang=(ru|uk|en|ua)\b", payload, re.I)
    m_tz   = re.search(r"(?:^|\s)tz=([\w/\-+]+)", payload, re.I)
    lang = _norm_locale(m_lang.group(1)) if m_lang else None
    tz   = m_tz.group(1) if m_tz else None
    return lang, tz

@router.message(CommandStart())
@router.message(Command("start"))
async def cmd_start(m: Message, session: AsyncSession):
    user = (await session.execute(select(User).where(User.tg_id == m.from_user.id))).scalar_one_or_none()

    lang_dl, tz_dl = _parse_start_payload(m.text or "")
    lang_tele = _norm_locale(getattr(m.from_user, "language_code", None))
    lang_default = _norm_locale(getattr(settings, "default_locale", "ru"))
    tz_default = getattr(settings, "default_tz", "Europe/Kyiv")

    if not user:
        loc_auto = lang_dl or lang_tele or lang_default
        tz_auto  = tz_dl if _is_valid_tz(tz_dl) else tz_default
        user = User(tg_id=m.from_user.id, locale=loc_auto, lang=loc_auto, tz=tz_auto)
        session.add(user)
        await session.flush()
    else:
        changed = False
        if lang_dl and user.locale != lang_dl:
            user.locale = lang_dl
            user.lang = lang_dl
            changed = True
        if tz_dl and _is_valid_tz(tz_dl) and user.tz != tz_dl:
            user.tz = tz_dl
            changed = True
        if changed: session.add(user)

    loc = _norm_locale(getattr(user, "locale", None))
    kb = get_main_kb(loc)
    key = "hello_ready" if getattr(user, "consent_accepted_at", None) else "hello_need_privacy"
    await m.answer(_TEXTS[loc][key], reply_markup=kb)
    await session.commit()
==========================================================================================
# app/hooks.py
==========================================================================================

import os, pkgutil, importlib, inspect
try:
    from fastapi import FastAPI, APIRouter
    from fastapi.responses import HTMLResponse, PlainTextResponse
    from starlette.applications import Starlette
except Exception:
    FastAPI = object
    Starlette = object

def _register(app):
    try:
        r = APIRouter()
        @r.get("/pay", response_class=HTMLResponse)
        async def pay(tg_id: str | None = None):
            p = os.path.join(os.path.dirname(__file__), "templates", "pay.html")
            return HTMLResponse(open(p, "r", encoding="utf-8").read())
        @r.get("/pay-mono")
        async def pay_mono(tg_id: str | None = None):
            return PlainTextResponse("MonoPay stub OK", status_code=200)
        @r.get("/pay-crypto")
        async def pay_crypto(tg_id: str | None = None):
            return PlainTextResponse("Crypto stub OK", status_code=200)
        existing = {getattr(rt, "path", "") for rt in getattr(app, "routes", []) or getattr(app.router, "routes", [])}
        need = {"/pay","/pay-mono","/pay-crypto"}
        if not need.issubset(existing):
            app.include_router(r)
    except Exception:
        pass

def _scan_and_patch():
    try:
        import app as _app_pkg
    except Exception:
        return
    for m in pkgutil.walk_packages(_app_pkg.__path__, "app."):
        try:
            mod = importlib.import_module(m.name)
        except Exception:
            continue
        for _, obj in inspect.getmembers(mod):
            if isinstance(obj, (FastAPI, Starlette)):
                _register(obj)

_scan_and_patch()

==========================================================================================
# app/http.py
==========================================================================================

from fastapi import FastAPI, Query, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse, PlainTextResponse
from pathlib import Path
import os, httpx

app = FastAPI(title="Diary HTTP")

def _load_env_chain():
    candidates = [
        "scripts/dev.env", "dev.env", ".env", ".env.local",
        "config/dev.env", "config/.env", "env", "local.env"
    ]
    for rel in candidates:
        p = Path(rel)
        if not p.exists():
            continue
        for line in p.read_text(encoding="utf-8").splitlines():
            s = line.strip()
            if not s or s.startswith("#") or "=" not in s:
                continue
            k, v = s.split("=", 1)
            k, v = k.strip(), v.strip().strip('"').strip("'")
            if k and k not in os.environ:
                os.environ[k] = v

_load_env_chain()

def _base():
    return os.getenv("PUBLIC_URL") or os.getenv("PUBLIC_BASE_URL") or ""

@app.get("/env-check")
async def env_check():
    keys = ["PUBLIC_URL","PUBLIC_BASE_URL","SUB_PRICE_UAH","SUB_PRICE_USD","NOWP_API_KEY","MONO_TOKEN"]
    return {k: bool(os.getenv(k)) for k in keys}

@app.get("/health")
async def health():
    return {"ok": True}

@app.get("/pay", response_class=HTMLResponse)
async def pay(tg_id: str = Query(...)):
    html = f"""<!doctype html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>–û–ø–ª–∞—Ç–∞</title>
<style>
body{{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;margin:0}}
.wrap{{max-width:740px;margin:32px auto;padding:0 16px}}
h1{{font-size:28px;margin:0 0 24px}}
a.btn{{display:block;width:100%;padding:18px 20px;border:0;border-radius:16px;font-size:20px;color:#fff;text-decoration:none;text-align:center;margin:14px 0}}
a.card{{background:#5b39f0}} a.crypto{{background:#14a37f}}
</style>
<div class="wrap">
  <h1>–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã</h1>
  <a class="btn card"   href="/pay-mono?tg_id={tg_id}">–ö–∞—Ä—Ç–æ–π (MonoPay, Apple/Google Pay)</a>
  <a class="btn crypto" href="/pay-crypto?tg_id={tg_id}">–ö—Ä–∏–ø—Ç–æ–π (USDT TRC20)</a>
</div>"""
    return HTMLResponse(html)

@app.get("/pay-crypto")
async def pay_crypto(tg_id: str = Query(...)):
    api_key = os.getenv("NOWP_API_KEY","")
    amount_usd = float(os.getenv("SUB_PRICE_USD", os.getenv("SUB_PRICE_USDT","10")))
    success = _base()+"/payments/success"
    cancel  = _base()+"/payments/cancel"
    if not api_key:
        return PlainTextResponse("NOWPayments API key missing", status_code=501)
    payload = {
        "price_amount": round(amount_usd, 2),
        "price_currency": "usd",
        "pay_currency": "usdttrc20",
        "order_id": f"tg_{tg_id}",
        "success_url": success,
        "cancel_url": cancel
    }
    async with httpx.AsyncClient(timeout=20) as cli:
        r = await cli.post("https://api.nowpayments.io/v1/invoice",
                           json=payload, headers={"x-api-key": api_key})
    data = r.json()
    if r.status_code != 200 or "invoice_url" not in data:
        raise HTTPException(502, detail=data)
    return RedirectResponse(data["invoice_url"], status_code=303)

@app.get("/pay-mono")
async def pay_mono(tg_id: str = Query(...)):
    token = os.getenv("MONO_TOKEN","")
    amount_uah = float(os.getenv("SUB_PRICE_UAH","99"))
    amount = int(round(amount_uah*100))
    success = _base()+"/payments/success"
    webhook = _base()+"/payments/mono-callback"
    if not token:
        return PlainTextResponse("Monobank merchant token missing", status_code=501)
    payload = {
        "amount": amount,
        "ccy": 980,
        "merchantPaymInfo": {"reference": f"tg_{tg_id}", "destination": "Diary Assistant Premium"},
        "redirectUrl": success,
        "webHookUrl": webhook
    }
    async with httpx.AsyncClient(timeout=20) as cli:
        r = await cli.post("https://api.monobank.ua/api/merchant/invoice/create",
                           headers={"X-Token": token, "Content-Type":"application/json"},
                           json=payload)
    data = r.json()
    if r.status_code != 200 or "pageUrl" not in data:
        raise HTTPException(502, detail=data)
    return RedirectResponse(data["pageUrl"], status_code=303)

@app.post("/payments/mono-callback")
async def mono_cb(body: dict):
    return {"ok": True}

@app.get("/payments/success", response_class=HTMLResponse)
async def ok():
    return "<h1>–û–ø–ª–∞—á–µ–Ω–æ ‚úÖ</h1>"

@app.get("/payments/cancel", response_class=HTMLResponse)
async def cancel():
    return "<h1>–ü–ª–∞—Ç—ë–∂ –æ—Ç–º–µ–Ω—ë–Ω</h1>"

==========================================================================================
# app/i18n.py
==========================================================================================
from typing import Literal

Lang = Literal["ru","uk","en"]

T = {
  "saved": {
    "ru": "–°–æ—Ö—Ä–∞–Ω–∏–ª. –ó–∞–ø–∏—Å–µ–π –≤—Å–µ–≥–æ: {n}.",
    "uk": "–ó–±–µ—Ä—ñ–≥. –ó–∞–ø–∏—Å—ñ–≤ –≤—Å—å–æ–≥–æ: {n}.",
    "en": "Saved. Total entries: {n}."
  },
  "policy_header": {
    "ru": "–≠—Ç–æ –ø–æ–º–æ—â–Ω–∏–∫-–µ–∂–µ–¥–Ω–µ–≤–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø–∏—è –∏ –Ω–µ –º–µ–¥—É—Å–ª—É–≥–∞.",
    "uk": "–¶–µ –ø–æ–º—ñ—á–Ω–∏–∫-—â–æ–¥–µ–Ω–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø—ñ—è —ñ –Ω–µ –º–µ–¥–∏—á–Ω–∞ –ø–æ—Å–ª—É–≥–∞.",
    "en": "This is a diary helper, not therapy or a medical service."
  },
  "meditation_ask": {
    "ru": "‚è± –°–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –º–µ–¥–∏—Ç–∞—Ü–∏–∏? (1‚Äì120)\n–ú–æ–∂–µ—à—å —Å—Ä–∞–∑—É –ø—Ä–∏—Å–ª–∞—Ç—å –∞—É–¥–∏–æ, —Ç–æ–≥–¥–∞ –≤–∫–ª—é—á—É –µ–≥–æ.",
    "uk": "‚è± –°–∫—ñ–ª—å–∫–∏ —Ö–≤–∏–ª–∏–Ω –º–µ–¥–∏—Ç–∞—Ü—ñ—ó? (1‚Äì120)\n–ú–æ–∂–µ—à –æ–¥—Ä–∞–∑—É –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –∞—É–¥—ñ–æ ‚Äî —è –π–æ–≥–æ –≤–≤—ñ–º–∫–Ω—É.",
    "en": "‚è± How many minutes? (1‚Äì120)\nYou can also send an audio track to play."
  },
  "meditation_started": {
    "ru": "üßò –ù–∞—á–∞–ª–∏ –Ω–∞ {m} –º–∏–Ω. –ü–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ —è –Ω–∞–ø–∏—à—É.",
    "uk": "üßò –ü–æ—á–∞–ª–∏ –Ω–∞ {m} —Ö–≤. –ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —è –Ω–∞–ø–∏—à—É.",
    "en": "üßò Started for {m} min. I‚Äôll ping you when done."
  },
  "meditation_done": {
    "ru": "üîî –ú–µ–¥–∏—Ç–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ö–∞–∫ —Å–∞–º–æ—á—É–≤—Å—Ç–≤–∏–µ?",
    "uk": "üîî –ú–µ–¥–∏—Ç–∞—Ü—ñ—é –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –Ø–∫ —Å–∞–º–æ–ø–æ—á—É—Ç—Ç—è?",
    "en": "üîî Meditation finished. How do you feel?"
  },
  "music_greet": {
    "ru": "üéµ –ü—Ä–∏—à–ª–∏ –∞—É–¥–∏–æ-—Ñ–∞–π–ª ‚Äî –¥–æ–±–∞–≤–ª—é –≤ —Ç–≤–æ–∏ —Ç—Ä–µ–∫–∏. /playlist ‚Äî —Å–ø–∏—Å–æ–∫",
    "uk": "üéµ –ù–∞–¥—ñ—à–ª–∏ –∞—É–¥—ñ–æ-—Ñ–∞–π–ª ‚Äî –¥–æ–¥–∞–º —É —Ç–≤–æ—ó —Ç—Ä–µ–∫–∏. /playlist ‚Äî —Å–ø–∏—Å–æ–∫",
    "en": "üéµ Send me an audio file to add. /playlist ‚Äî to list"
  },
  "playlist_empty": {
    "ru": "–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç. –ü—Ä–∏—à–ª–∏ –∞—É–¥–∏–æ —Å—é–¥–∞.",
    "uk": "–ü–æ—Ä–æ–∂–Ω—å–æ. –ù–∞–¥—ñ—à–ª–∏ –∞—É–¥—ñ–æ —Å—é–¥–∏.",
    "en": "Empty. Send audio here."
  },
}

def pick_lang(code: str|None) -> Lang:
    c = (code or "").lower()
    if c.startswith("ru"): return "ru"
    if c.startswith("uk"): return "uk"
    return "en"

def t(key: str, lang: Lang, **kw) -> str:
    block = T.get(key)
    if not block:
        val = f"[{key}]"
    else:
        val = block.get(lang) or block.get("en") or next(iter(block.values()))
    try:
        return val.format(**kw)
    except Exception:
        return val

tr = t
detect_lang = pick_lang

__all__ = ["t","tr","pick_lang","detect_lang","Lang"]

def tr(key, code=None, lang=None, **kw):
    if lang is None:
        lang = pick_lang(code)
    try:
        return t(key, lang, **kw)
    except Exception:
        base = T.get(key, {})
        return base.get(lang) or base.get("en") or key

def detect_lang(code):
    return pick_lang(code)

==========================================================================================
# app/i18n/en.json
==========================================================================================
{
  "hello": "Hi!",
  "journal_prompt": "How are you? Jot 2‚Äì3 thoughts for today.",
  "privacy": "This is an assistant, not therapy. By accepting you acknowledge the policy."
}
==========================================================================================
# app/i18n/ru.json
==========================================================================================
{
  "hello": "–ü—Ä–∏–≤–µ—Ç!",
  "journal_prompt": "–ö–∞–∫ —Ç—ã? –ù–∞–ø–∏—à–∏ 2‚Äì3 –º—ã—Å–ª–∏ –∑–∞ —Å–µ–≥–æ–¥–Ω—è.",
  "privacy": "–≠—Ç–æ –ø–æ–º–æ—â–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø–∏—è. –ü—Ä–∏–Ω–∏–º–∞—è —É—Å–ª–æ–≤–∏—è, –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ."
}
==========================================================================================
# app/i18n/uk.json
==========================================================================================
{
  "hello": "–ü—Ä–∏–≤—ñ—Ç!",
  "journal_prompt": "–Ø–∫ —Ç–∏? –ù–∞–ø–∏—à–∏ 2‚Äì3 –¥—É–º–∫–∏ –∑–∞ —Å—å–æ–≥–æ–¥–Ω—ñ.",
  "privacy": "–¶–µ –ø–æ–º—ñ—á–Ω–∏–∫, –∞ –Ω–µ —Ç–µ—Ä–∞–ø—ñ—è. –ü—Ä–∏–π–º–∞—é—á–∏ —É–º–æ–≤–∏, –≤–∏ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂—É—î—Ç–µ —Ä–æ–∑—É–º—ñ–Ω–Ω—è."
}
==========================================================================================
# app/keyboards.py
==========================================================================================
# app/keyboards.py
from __future__ import annotations
from typing import Iterable
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

# ---- –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ª–æ–∫–∞–ª–∏
_SUPPORTED = {"ru", "uk", "en"}

def _norm_lang(lang: str | None) -> str:
    s = (lang or "ru").split("-")[0].lower()
    if s == "ua":
        s = "uk"
    return s if s in _SUPPORTED else "ru"

# ---- —Ç–µ–∫—Å—Ç—ã –∫–Ω–æ–ø–æ–∫
LABELS = {
    "ru": {
        "med": "üßò –ú–µ–¥–∏—Ç–∞—Ü–∏—è",
        "music": "üéµ –ú—É–∑—ã–∫–∞",
        "premium": "üíé Premium",
        "lang": "üåê Language",   # –Ω–∞–º–µ—Ä–µ–Ω–Ω–æ –æ—Å—Ç–∞–≤–∏–ª ¬´Language¬ª, —á—Ç–æ–±—ã –æ–¥–∏–Ω —Ç—Ä–∏–≥–≥–µ—Ä –ª–æ–≤–∏–ª –∏ RU/EN
        "privacy": "üîí Privacy", # –∏ —Ç—É—Ç ‚Äî –µ–¥–∏–Ω—ã–π —Ç–µ—Ä–º–∏–Ω, –Ω–æ —Å–º. –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –Ω–∏–∂–µ
        "bug": "üõ†Ô∏è Report bug",
    },
    "uk": {
        "med": "üßò –ú–µ–¥–∏—Ç–∞—Ü—ñ—è",
        "music": "üéµ –ú—É–∑–∏–∫–∞",
        "premium": "üíé –ü—Ä–µ–º—ñ—É–º",
        "lang": "üåê –ú–æ–≤–∞",
        "privacy": "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
        "bug": "üõ†Ô∏è –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
    },
    "en": {
        "med": "üßò Meditation",
        "music": "üéµ Music",
        "premium": "üíé Premium",
        "lang": "üåê Language",
        "privacy": "üîí Privacy",
        "bug": "üõ†Ô∏è Report a bug",
    },
}

# ---- —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –¥–ª—è –º–∞—Ç—á–µ–π —Ç–µ–∫—Å—Ç–∞
PRIVACY_LABELS  : set[str] = {"üîí Privacy", "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞", "üîí –ü–æ–ª–∏—Ç–∏–∫–∞"}
LANGUAGE_LABELS : set[str] = {"üåê Language", "üåê –ú–æ–≤–∞", "üåê –Ø–∑—ã–∫"}
REPORT_LABELS   : set[str] = {"üõ†Ô∏è Report bug", "üõ†Ô∏è Report a bug", "üõ† –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥", "üõ† –°–æ–æ–±—â–∏—Ç—å –ø—Ä–æ –±–∞–≥"}
PREMIUM_LABELS  : set[str] = {"üíé Premium", "üíé –ü—Ä–µ–º–∏—É–º", "üíé –ü—Ä–µ–º—ñ—É–º"}
MEDITATION_LABELS: set[str] = {"üßò –ú–µ–¥–∏—Ç–∞—Ü–∏—è", "üßò –ú–µ–¥–∏—Ç–∞—Ü—ñ—è", "üßò Meditation"}
MUSIC_LABELS     : set[str] = {"üéµ –ú—É–∑—ã–∫–∞", "üéµ –ú—É–∑–∏–∫–∞", "üéµ Music"}

def _is_in(text: str | None, pool: Iterable[str]) -> bool:
    return (text or "").strip() in pool

# –•–µ–ª–ø–µ—Ä—ã –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–æ–≤
def is_privacy_btn(text: str) -> bool:   return _is_in(text, PRIVACY_LABELS)
def is_language_btn(text: str) -> bool:  return _is_in(text, LANGUAGE_LABELS)
def is_report_btn(text: str) -> bool:    return _is_in(text, REPORT_LABELS)
def is_premium_btn(text: str) -> bool:   return _is_in(text, PREMIUM_LABELS)
def is_meditation_btn(text: str) -> bool:return _is_in(text, MEDITATION_LABELS)
def is_music_btn(text: str) -> bool:     return _is_in(text, MUSIC_LABELS)

# ---- –µ–¥–∏–Ω—ã–π –±–∏–ª–¥–µ—Ä –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
def get_main_kb(lang: str | None, is_premium: bool = False) -> ReplyKeyboardMarkup:
    l = _norm_lang(lang)
    t = LABELS[l]
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=t["med"]), KeyboardButton(text=t["music"])],
            [KeyboardButton(text=t["premium"])],
            [KeyboardButton(text=t["lang"])],
            [KeyboardButton(text=t["privacy"])],
            [KeyboardButton(text=t["bug"])],
        ],
        resize_keyboard=True
    )

# ---- –æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∏–º–ø–æ—Ä—Ç–æ–º
get_main_kb = get_main_kb

__all__ = [
    "get_main_kb", "get_main_kb",
    "PRIVACY_LABELS", "LANGUAGE_LABELS", "REPORT_LABELS", "PREMIUM_LABELS",
    "MEDITATION_LABELS", "MUSIC_LABELS",
    "is_privacy_btn", "is_language_btn", "is_report_btn", "is_premium_btn",
    "is_meditation_btn", "is_music_btn",
]
==========================================================================================
# app/main.py
==========================================================================================
# app/main.py
from __future__ import annotations
import asyncio, logging, os, importlib, pkgutil, contextlib
from typing import Any, Dict, Awaitable, Callable

from aiogram import Dispatcher, BaseMiddleware
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import BotCommand

from app.bot import bot
from app.db import async_session as SessionLocal, engine, Base
from app.config import settings
import app.models as _models_pkg

try:
    from app.services.reminders import tick_reminders
except Exception:
    async def tick_reminders(*_a, **_kw): return None

try:
    from app.scheduler import ensure_started  # type: ignore
except Exception:
    ensure_started = None  # type: ignore

# ‚Äî —Ä–æ—É—Ç–µ—Ä—ã ‚Äî
from app.handlers import start, language, privacy, journal, reminders, report, premium
from app.features import router as features_router

RU_COMMANDS = [
    BotCommand(command="start",   description="–ù–∞—á–∞—Ç—å"),
    BotCommand(command="journal", description="–°–¥–µ–ª–∞—Ç—å –∑–∞–ø–∏—Å—å"),
    BotCommand(command="stats",   description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",  description="–°–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"),
    BotCommand(command="premium", description="–ü—Ä–µ–º–∏—É–º-—Å—Ç–∞—Ç—É—Å"),
]
UK_COMMANDS = [
    BotCommand(command="start",   description="–ü–æ—á–∞—Ç–∏"),
    BotCommand(command="journal", description="–ó—Ä–æ–±–∏—Ç–∏ –∑–∞–ø–∏—Å"),
    BotCommand(command="stats",   description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
    BotCommand(command="remind",  description="–°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è"),
    BotCommand(command="premium", description="–ü—Ä–µ–º—ñ—É–º-—Å—Ç–∞—Ç—É—Å"),
]
EN_COMMANDS = [
    BotCommand(command="start",   description="Start"),
    BotCommand(command="journal", description="New journal entry"),
    BotCommand(command="stats",   description="Stats"),
    BotCommand(command="remind",  description="Create reminder"),
    BotCommand(command="premium", description="Premium"),
]

try:
    from app.middlewares.lang import LangMiddleware
except Exception:
    class LangMiddleware(BaseMiddleware):
        async def __call__(self, handler, event, data):
            data.setdefault("lang","ru")
            return await handler(event, data)

class DBSessionMiddleware(BaseMiddleware):
    async def __call__(self, handler: Callable[[Any, Dict[str, Any]], Awaitable[Any]], event, data: Dict[str, Any]) -> Any:
        async with SessionLocal() as session:
            data["session"] = session
            return await handler(event, data)

async def _ensure_db() -> None:
    for _, name, _ in pkgutil.iter_modules(_models_pkg.__path__, _models_pkg.__name__ + "."):
        importlib.import_module(name)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def _set_commands() -> None:
    await bot.set_my_commands(RU_COMMANDS, language_code="ru")
    await bot.set_my_commands(UK_COMMANDS, language_code="uk")
    await bot.set_my_commands(EN_COMMANDS, language_code="en")

async def _reminders_loop() -> None:
    tick = max(1, int(os.getenv("REMINDER_TICK_SEC", str(getattr(settings, "reminder_tick_sec", 5)))))
    while True:
        try:
            async with SessionLocal() as session:
                await tick_reminders(session, bot)
        except Exception:
            logging.exception("reminders_loop error")
        await asyncio.sleep(tick)

def build_dispatcher() -> Dispatcher:
    dp = Dispatcher(storage=MemoryStorage())
    dp.update.outer_middleware(DBSessionMiddleware())
    dp.update.outer_middleware(LangMiddleware())

    # –ø–æ—Ä—è–¥–æ–∫ –∫—Ä–∏—Ç–∏—á–µ–Ω: —à–∏—Ä–æ–∫–∏–µ ¬´—Å–ª—É—à–∞—Ç–µ–ª–∏¬ª ‚Äî –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ
    dp.include_router(language.router)
    dp.include_router(privacy.router)
    dp.include_router(premium.router)      # –ø–æ–¥–Ω—è—Ç –≤—ã—à–µ, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–ª–∏ –¥—Ä—É–≥–∏–µ
    dp.include_router(start.router)
    dp.include_router(journal.router)
    dp.include_router(report.router)
    dp.include_router(features_router)
    dp.include_router(reminders.router)    # —Å–∞–º—ã–π –ø–æ—Å–ª–µ–¥–Ω–∏–π
    return dp

async def main() -> None:
    logging.basicConfig(level=getattr(logging, os.getenv("LOG_LEVEL","INFO").upper(), logging.INFO))
    logging.info("Bootstrapping‚Ä¶")

    await _ensure_db()
    try:
        if ensure_started:
            ensure_started()
    except Exception:
        logging.exception("ensure_started failed")

    dp = build_dispatcher()
    await _set_commands()

    reminders_task = asyncio.create_task(_reminders_loop(), name="reminders_loop")
    logging.info("‚úÖ Bot is up. Starting polling‚Ä¶")
    try:
        await dp.start_polling(bot)
    finally:
        reminders_task.cancel()
        with contextlib.suppress(Exception):
            await reminders_task

if __name__ == "__main__":
    asyncio.run(main())
==========================================================================================
# app/middlewares/lang.py
==========================================================================================
# app/middlewares/lang.py
from __future__ import annotations
from typing import Any, Dict, Awaitable, Callable, Optional, Tuple

from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery
from sqlalchemy import select

from app.models.user import User
from app.db import async_session

SUPPORTED_LOCALES = {"ru","uk","en"}

def _extract_from_event(event: Any) -> Tuple[Optional[int], str]:
    tg_id: Optional[int] = None
    lc: str = ""
    if isinstance(event, Message) and event.from_user:
        tg_id = event.from_user.id
        lc = (event.from_user.language_code or "")[:2].lower()
    elif isinstance(event, CallbackQuery) and event.from_user:
        tg_id = event.from_user.id
        lc = (event.from_user.language_code or "")[:2].lower()
    else:
        fu = getattr(event, "event_from_user", None)
        if fu:
            tg_id = getattr(fu, "id", None)
            lc = (getattr(fu, "language_code", "") or "")[:2].lower()
    if lc == "ua": lc = "uk"
    return tg_id, lc

class LangMiddleware(BaseMiddleware):
    def __init__(self, default_locale: str = "ru") -> None:
        super().__init__()
        self.default_locale = default_locale if default_locale in SUPPORTED_LOCALES else "ru"

    async def __call__(
        self,
        handler: Callable[[Any, Dict[str, Any]], Awaitable[Any]],
        event: Any,
        data: Dict[str, Any],
    ) -> Any:
        tg_id, tele_lc = _extract_from_event(event)

        user: Optional[User] = data.get("user")
        if not user and tg_id:
            session = data.get("session")
            if session:
                user = (await session.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()
            else:
                async with async_session() as s:
                    user = (await s.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()
            if user:
                data["user"] = user

        loc = ""
        if user:
            loc = (getattr(user, "locale", None) or getattr(user, "lang", None) or "").lower()
        loc = loc[:2]
        locale = (
            loc if loc in SUPPORTED_LOCALES else
            (tele_lc if tele_lc in SUPPORTED_LOCALES else self.default_locale)
        )

        data["lang"] = locale
        if user and getattr(user, "tz", None):
            data.setdefault("tz", user.tz)

        i18n_ctx = data.get("i18n")
        if i18n_ctx:
            try:
                await i18n_ctx.set_locale(locale)
            except Exception:
                pass

        return await handler(event, data)
==========================================================================================
# app/models.py
==========================================================================================
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import Integer, String, ForeignKey, Index
class Base(DeclarativeBase):
    pass
class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    tg_id: Mapped[int] = mapped_column(Integer, unique=True)
    tz: Mapped[str] = mapped_column(String, default="Europe/Kyiv")
    reminders: Mapped[list["Reminder"]] = relationship(back_populates="user", cascade="all, delete-orphan")
class Reminder(Base):
    __tablename__ = "reminder"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    title: Mapped[str | None] = mapped_column(String)
    cron: Mapped[str | None] = mapped_column(String)
    next_run: Mapped[str | None] = mapped_column(String)
    is_active: Mapped[int] = mapped_column(Integer, default=1)
    user: Mapped["User"] = relationship(back_populates="reminders")
Index("ix_reminder_user_next", Reminder.user_id, Reminder.next_run)

==========================================================================================
# app/models/__init__.py
==========================================================================================
from .user import User
from .payment import Payment
__all__=["User","Payment"]

==========================================================================================
# app/models/bug_report.py
==========================================================================================
# app/models/bug_report.py
from __future__ import annotations

from typing import Optional
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import ForeignKey, Text, String, TIMESTAMP, func, Index, text as sa_text
from app.db import Base

class BugReport(Base):
    __tablename__ = "bug_reports"

    id: Mapped[int] = mapped_column(primary_key=True)

    user_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    # —Ç–µ–∫—Å—Ç –æ—Ç—á—ë—Ç–∞ ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π
    text: Mapped[str] = mapped_column(Text, nullable=False)

    # —Å—Ç–∞—Ç—É—Å: python-side default + server-side default (–≤–∞–∂–Ω–æ: sa_text, —á—Ç–æ–±—ã –Ω–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞—Ç—å —Å –ø–æ–ª–µ–º text)
    status: Mapped[str] = mapped_column(
        String(32),
        default="new",
        server_default=sa_text("'new'"),
        nullable=False,
    )

    created_at = mapped_column(
        TIMESTAMP(timezone=True),
        server_default=func.now(),   # –∫—Ä–æ—Å—Å-–°–£–ë–î –Ω–æ—Ä–º–∞–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
        nullable=False,
    )

    __table_args__ = (
        Index("ix_bug_reports_status", "status"),
    )

    def __repr__(self) -> str:
        return f"<BugReport id={self.id} user_id={self.user_id} status={self.status}>"
==========================================================================================
# app/models/journal.py
==========================================================================================
from __future__ import annotations

from typing import Optional
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import ForeignKey, Text, Integer

from app.db import Base
from app.models.mixins import TimestampMixin


class JournalEntry(TimestampMixin, Base):
    __tablename__ = "journal_entries"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"),
        index=True,
        nullable=False,
    )
    text: Mapped[str] = mapped_column(Text, nullable=False)
    # 1..5 ‚Äî –≤–∞–ª–∏–¥–∏—Ä—É–π –≤ –∫–æ–¥–µ/—Å—Ö–µ–º–µ, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    mood: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
==========================================================================================
# app/models/mixins.py
==========================================================================================
from __future__ import annotations

from datetime import datetime
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import DateTime
from sqlalchemy.sql import func


class TimestampMixin:
    """Timezone-aware created_at / updated_at mixin."""
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    updated_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=True,
    )
==========================================================================================
# app/models/payment.py
==========================================================================================
from __future__ import annotations

from typing import Optional
from datetime import datetime

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import (
    ForeignKey,
    String,
    Integer,
    Text,
    TIMESTAMP,
    func,
    CheckConstraint,
    Index,
)

from app.db import Base
from app.models.mixins import TimestampMixin


class Payment(TimestampMixin, Base):
    __tablename__ = "payments"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    provider: Mapped[str] = mapped_column(String(32))
    plan: Mapped[str] = mapped_column(String(64))

    amount_cents: Mapped[int] = mapped_column(Integer)
    currency: Mapped[str] = mapped_column(String(8), default="USD")

    status: Mapped[str] = mapped_column(String(16))
    external_id: Mapped[Optional[str]] = mapped_column(String(128), nullable=True, index=True)

    # –•—Ä–∞–Ω–∏–º —Å—ã—Ä–æ–µ —Ç–µ–ª–æ –≤–µ–±—Ö—É–∫–∞ –∫–∞–∫ —Ç–µ–∫—Å—Ç (–±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π 256 —Å–∏–º–≤–æ–ª–æ–≤)
    payload: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –µ—Å–ª–∏ –≥–¥–µ-—Ç–æ —á–∏—Ç–∞—é—Ç —ç—Ç–æ –ø–æ–ª–µ –Ω–∞–ø—Ä—è–º—É—é
    created_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        server_default=func.now(),
    )
    paid_at: Mapped[Optional[datetime]] = mapped_column(TIMESTAMP(timezone=True), nullable=True)

    __table_args__ = (
        CheckConstraint("amount_cents >= 0", name="ck_payments_amount_nonneg"),
        Index("ix_payments_provider_status", "provider", "status"),
        # –ß–∞—Å—Ç–∏—á–Ω–æ-—É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –ø–æ external_id (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ NULL)
        # –∏–º—è —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ç–µ–º, —á—Ç–æ —Ç—ã —É–∂–µ —Å–æ–∑–¥–∞–ª —á–µ—Ä–µ–∑ SQL
        Index(
            "uq_payments_external_id",
            "external_id",
            unique=True,
            postgresql_where=(external_id.is_not(None)),  # –∏–≥–Ω–æ—Ä–∏–º NULL
        ),
    )

    def __repr__(self) -> str:
        return f"<Payment id={self.id} user_id={self.user_id} {self.provider} {self.status}>"
==========================================================================================
# app/models/reminder.py
==========================================================================================
from __future__ import annotations

import logging
from typing import Optional
from datetime import datetime

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import ForeignKey, Text, Boolean, DateTime, Index

from app.db import Base
from app.models.mixins import TimestampMixin

log = logging.getLogger("reminders")


class Reminder(TimestampMixin, Base):
    __tablename__ = "reminder"  # –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ –µ–¥. —á–∏—Å–ª–µ, –∫–∞–∫ –≤ –ë–î

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"),
        index=True,
        nullable=False,
    )

    # –ö–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç/–Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
    title: Mapped[str] = mapped_column(Text, nullable=False)

    # –õ–∏–±–æ cron, –ª–∏–±–æ –æ–¥–∏–Ω–æ—á–Ω—ã–π next_run
    cron: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    next_run: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )

    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)

    __table_args__ = (
        Index("ix_reminder_due", "is_active", "next_run"),
    )
==========================================================================================
# app/models/user.py
==========================================================================================
# app/models/user.py
from __future__ import annotations

from datetime import time, datetime
from typing import Optional

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import BigInteger, Boolean, String, Time, DateTime

from app.db import Base
from app.models.mixins import TimestampMixin


class User(TimestampMixin, Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    tg_id: Mapped[int] = mapped_column(BigInteger, unique=True, index=True, nullable=False)

    # –∏–º–µ–Ω–Ω–æ locale —Ö—Ä–∞–Ω–∏–º –≤ –ë–î
    locale: Mapped[str] = mapped_column(String(8), default="ru", nullable=False)
    tz: Mapped[str] = mapped_column(String(64), default="Europe/Kyiv", nullable=False)

    consent_accepted_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    premium_until: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    premium_trial_granted: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

    morning_auto: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    morning_time: Mapped[time] = mapped_column(Time(timezone=False), default=time(9, 30), nullable=False)

    # –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
    @property
    def language(self) -> str:
        return self.locale

    @language.setter
    def language(self, v: str) -> None:
        self.locale = (v or "ru")
==========================================================================================
# app/payments/__init__.py
==========================================================================================

==========================================================================================
# app/payments/coinbase_webhook.py
==========================================================================================
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
import os, hmac, hashlib, json, logging
from datetime import datetime, timezone, timedelta
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

router = APIRouter()
log = logging.getLogger("payments.webhook")
WEBHOOK_SECRET = os.getenv("COINBASE_COMMERCE_WEBHOOK_SECRET","")
DATABASE_URL = os.getenv("DATABASE_URL","")
engine = create_async_engine(DATABASE_URL, pool_pre_ping=True) if DATABASE_URL else None

async def grant_premium_days(tg_id: int, days: int = 31) -> bool:
    if not engine:
        return False
    async with engine.begin() as conn:
        res = await conn.execute(
            text(
                "UPDATE users "
                "SET premium_until = (CASE "
                "WHEN premium_until IS NOT NULL AND premium_until > (NOW() AT TIME ZONE 'utc') "
                "THEN premium_until ELSE (NOW() AT TIME ZONE 'utc') END) "
                " + (:days || ' days')::interval "
                "WHERE tg_id = :tg_id"
            ),
            {"tg_id": int(tg_id), "days": str(days)},
        )
        if res.rowcount == 0:
            try:
                await conn.execute(
                    text(
                        "INSERT INTO users (tg_id, premium_until) "
                        "VALUES (:tg_id, (NOW() AT TIME ZONE 'utc') + (:days || ' days')::interval)"
                    ),
                    {"tg_id": int(tg_id), "days": str(days)},
                )
            except Exception:
                pass
    return True

def _verify(sig_hdr: str, raw: bytes) -> bool:
    if not WEBHOOK_SECRET:
        return True
    digest = hmac.new(WEBHOOK_SECRET.encode(), raw, hashlib.sha256).hexdigest()
    return hmac.compare_digest(digest, sig_hdr or "")

@router.post("/payments/coinbase/webhook")
async def coinbase_webhook(request: Request):
    raw = await request.body()
    sig = request.headers.get("X-CC-Webhook-Signature","")
    if not _verify(sig, raw):
        return JSONResponse({"ok": False}, status_code=400)
    try:
        data = await request.json()
    except Exception:
        try:
            data = json.loads(raw.decode("utf-8","ignore"))
        except Exception:
            data = {}
    event = data.get("event") or {}
    etype = event.get("type")
    charge = event.get("data") or {}
    meta = charge.get("metadata") or {}
    tg_id = meta.get("tg_id")
    code = charge.get("code")
    log.info("coinbase_event type=%s code=%s tg_id=%s", etype, code, tg_id)
    ok_types = {"charge:confirmed","charge:resolved"}
    if etype in ok_types and tg_id:
        try:
            await grant_premium_days(int(tg_id), 31)
            log.info("premium_granted tg_id=%s", tg_id)
        except Exception as e:
            log.exception("premium_grant_failed tg_id=%s err=%s", tg_id, e)
            return JSONResponse({"ok": False}, status_code=500)
    return JSONResponse({"ok": True})

==========================================================================================
# app/payments/now.py
==========================================================================================

from fastapi import APIRouter, Request, Header, HTTPException
from fastapi.responses import RedirectResponse
import os, hmac, hashlib, json, requests

router = APIRouter()

def _base():
    return os.getenv("NOWP_BASE","https://api.nowpayments.io/v1").rstrip("/")

def _pub():
    return os.getenv("PUBLIC_BASE_URL","").rstrip("/")

def _price():
    return os.getenv("NOWP_PRICE_USD","1.00")

@router.get("/payments/now/create")
def now_create_invoice(tg_id: str):
    api_key = os.getenv("NOWP_API_KEY","").strip()
    if not api_key:
        raise HTTPException(status_code=500, detail="NOWP_API_KEY missing")
    payload = {
        "price_amount": _price(),
        "price_currency": "USD",
        "order_id": str(tg_id),
        "ipn_callback_url": f"{_pub()}/payments/now/webhook",
        "success_url": f"{_pub()}/payments/now/thanks",
        "cancel_url": f"{_pub()}/payments/now/cancel"
    }
    r = requests.post(f"{_base()}/invoice",
                      headers={"x-api-key": api_key, "Content-Type":"application/json"},
                      json=payload, timeout=20)
    try:
        r.raise_for_status()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"NOWP create failed: {e}")
    data = r.json()
    url = data.get("invoice_url")
    if not url:
        raise HTTPException(status_code=500, detail="invoice_url not found")
    return RedirectResponse(url, status_code=303)

@router.get("/payments/now/thanks")
def now_thanks():
    return {"ok": True, "status":"thanks"}

@router.get("/payments/now/cancel")
def now_cancel():
    return {"ok": True, "status":"cancel"}

@router.post("/payments/now/webhook")
async def now_webhook(request: Request, x_nowpayments_sig: str = Header(None)):
    raw = await request.body()
    secret = os.getenv("NOWP_IPN_SECRET","")
    expect = hmac.new(secret.encode(), raw, hashlib.sha512).hexdigest()
    if not x_nowpayments_sig or x_nowpayments_sig.lower() != expect.lower():
        raise HTTPException(status_code=400, detail="bad signature")

    body = await request.json()
    status = (body.get("payment_status") or "").lower()
    tg_id = str(body.get("order_id") or "").strip()
    invoice_id = str(body.get("invoice_id") or body.get("payment_id") or "")

    # TODO: integrate DB idempotency by invoice_id

    if status in {"finished","confirmed"} and tg_id.isdigit():
        try:
            # TODO: set_premium_until(int(tg_id), datetime.utcnow() + timedelta(days=30))
            pass
        except Exception as e:
            print("premium grant failed:", e)

    return {"ok": True}

==========================================================================================
# app/payments/nowp.py
==========================================================================================

from fastapi import APIRouter, Request
from fastapi.responses import RedirectResponse, JSONResponse
import os, hmac, hashlib, json, requests

router = APIRouter()

def _base():
    return os.getenv("NOWP_BASE", "https://api.nowpayments.io/v1")

def _verify_sig(secret: str, body: bytes, sig: str) -> bool:
    try:
        obj = json.loads(body.decode("utf-8"))
    except Exception:
        return False
    data = json.dumps(obj, separators=(',',':'), sort_keys=True)
    mac = hmac.new(secret.encode(), data.encode(), hashlib.sha512).hexdigest()
    return hmac.compare_digest(mac, (sig or '').lower())

@router.get("/payments/now/create")
def now_create(tg_id: str):
    key = os.getenv("NOWP_API_KEY")
    price = os.getenv("NOWP_PRICE_USD", "5.00")
    public = os.getenv("PUBLIC_BASE_URL", "https://ilda-comelier-pliantly.ngrok-free.dev")
    payload = {
        "price_amount": str(price),
        "price_currency": "USD",
        "order_id": str(tg_id),
        "ipn_callback_url": f"{public}/payments/now/webhook",
        "success_url": f"{public}/payments/now/thanks",
        "cancel_url": f"{public}/payments/now/cancel"
    }
    try:
        r = requests.post(f"{_base()}/invoice",
                          headers={"x-api-key": key, "Content-Type": "application/json"},
                          json=payload, timeout=20)
        r.raise_for_status()
        inv = r.json()
        url = inv.get("invoice_url") or inv.get("data",{}).get("invoice_url")
        if not url:
            return JSONResponse({"ok": False, "error": "no invoice_url", "resp": inv}, status_code=502)
        return RedirectResponse(url, status_code=303)
    except Exception as e:
        body = getattr(getattr(e, "response", None), "text", None)
        return JSONResponse({"ok": False, "error": str(e), "resp": body}, status_code=502)

@router.post("/payments/now/webhook")
async def now_webhook(request: Request):
    secret = os.getenv("NOWP_IPN_SECRET","")
    sig = request.headers.get("x-nowpayments-sig","")
    body = await request.body()
    if not _verify_sig(secret, body, sig):
        return JSONResponse({"ok": False, "reason": "bad_signature"}, status_code=401)
    data = json.loads(body.decode("utf-8"))
    status = (data.get("payment_status") or "").lower()
    order_id = str(data.get("order_id") or "")
    if status in ("finished","confirmed"):
        pass
    return JSONResponse({"ok": True})

@router.get("/payments/now/thanks")
def now_thanks():
    return {"ok": True, "status": "thanks"}

@router.get("/payments/now/cancel")
def now_cancel():
    return {"ok": False, "status": "cancel"}

==========================================================================================
# app/payments/nowpayments.py
==========================================================================================
import os, hmac, hashlib, requests
from fastapi import APIRouter, Query, Request
from fastapi.responses import RedirectResponse

router = APIRouter()

@router.get("/create")
def create_invoice(tg_id: str = Query(...)):
    api = os.getenv("NOWP_API_KEY")
    public = os.getenv("PUBLIC_BASE_URL")
    price = float(os.getenv("NOWP_PRICE_USD","5.00"))
    payload = {
        "price_amount": price,
        "price_currency": "USD",
        "order_id": f"tg_{tg_id}",
        "success_url": f"{public}/payments/success",
        "cancel_url":  f"{public}/payments/cancel",
        "ipn_callback_url": f"{public}/payments/now/webhook"
    }
    r = requests.post(
        "https://api.nowpayments.io/v1/invoice",
        headers={"x-api-key": api, "Content-Type":"application/json"},
        json=payload, timeout=20
    )
    r.raise_for_status()
    return RedirectResponse(r.json()["invoice_url"], status_code=303)

@router.post("/webhook")
async def webhook(request: Request):
    body = await request.body()
    sign = request.headers.get("x-nowpayments-sig","")
    check = hmac.new(os.getenv("NOWP_IPN_SECRET","").encode(), body, hashlib.sha512).hexdigest()
    if not hmac.compare_digest(check, sign):
        return {"ok": False}
    data = await request.json()
    status = data.get("payment_status") or data.get("invoice_status")
    order_id = data.get("order_id","")
    tg_id = order_id.replace("tg_","")
    print("NOWP EVENT:", status, tg_id)
    if status in ("finished","confirmed","paid","partially_paid"):
        # TODO: –≤—ã–¥–∞—Ç—å –ø—Ä–µ–º–∏—É–º tg_id –Ω–∞ 30 –¥–Ω–µ–π
        pass
    return {"ok": True}

==========================================================================================
# app/scheduler.py
==========================================================================================
from __future__ import annotations
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from pytz import utc
import asyncio

scheduler = AsyncIOScheduler(timezone=utc)

def ensure_started():
    # –ï—Å–ª–∏ –ª—É–ø –µ—â—ë –Ω–µ –∑–∞–ø—É—â–µ–Ω (–∏–º–ø–æ—Ä—Ç –≤—Ä–µ–º–µ–Ω–∏) ‚Äî –≤—ã—Ö–æ–¥–∏–º –º–æ–ª—á–∞.
    try:
        asyncio.get_running_loop()
    except RuntimeError:
        return
    if not scheduler.running:
        scheduler.start()

==========================================================================================
# app/services/__init__.py
==========================================================================================

==========================================================================================
# app/services/exporter.py
==========================================================================================
# exporter.py
import re
from typing import Optional, Tuple

# –ì–ª–∞–≥–æ–ª-—Ç—Ä–∏–≥–≥–µ—Ä (RU/UK/EN) + –º—è–≥–∫–∏–µ ¬´–ø–æ–∂–∞–ª—É–π—Å—Ç–∞/–±—É–¥—å –ª–∞—Å–∫–∞¬ª
VERB = (
    r"(?:–ø–æ–∂–∞–ª—É–π—Å—Ç–∞\s+)?(?:–±—É–¥—å\s+–ª–∞—Å–∫–∞\s+)?"
    r"(?:"
    r"–Ω–∞–ø–æ–º–Ω–∏(?:—Ç—å)?|–ø–æ—Å—Ç–∞–≤—å\s+–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ|"
    r"–Ω–∞–≥–∞–¥–∞–π|–Ω–∞–≥–∞–¥–∞—Ç–∏|"
    r"remind(?:\s+me)?(?:\s+to)?"
    r")"
)

# –õ—é–±—ã–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏
QUOTE_CHARS = "\"'‚Äú‚Äù¬´¬ª"
Q = r"[\"'‚Äú‚Äù¬´¬ª]"

def _strip_quotes_punct(s: str) -> str:
    s = s.strip()
    if len(s) >= 2 and s[0] in QUOTE_CHARS and s[-1] in QUOTE_CHARS:
        s = s[1:-1].strip()
    return s.rstrip(".!?,; ").lstrip()

# –ü–∞—Ç—Ç–µ—Ä–Ω—ã: –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –≥—Ä—É–ø–ø—ã what/when
_RAW_PATTERNS = [
    # 1) RU/UK/EN: ¬´–Ω–∞–ø–æ–º–Ω–∏ WHAT –≤|–æ|—á–µ—Ä–µ–∑|at|on|in WHEN¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+(?:–≤|–æ|—á–µ—Ä–µ–∑|at|on|in)\s+(?P<when>.+)",

    # 2) RU/EN: ¬´–Ω–∞–ø–æ–º–Ω–∏ —á–µ—Ä–µ–∑ WHEN WHAT¬ª
    rf"{VERB}\s+(?:—á–µ—Ä–µ–∑|in)\s+(?P<when>[^\"'‚Äú‚Äù¬´¬ª]+?)\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+{Q}?)",

    # 3) RU/UK: ¬´–Ω–∞–ø–æ–º–Ω–∏ WHAT (—Å–µ–≥–æ–¥–Ω—è|–∑–∞–≤—Ç—Ä–∞|–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞|—Å—å–æ–≥–æ–¥–Ω—ñ) [–≤ ‚Ä¶]¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+"
    rf"(?P<when>(?:—Å–µ–≥–æ–¥–Ω—è|–∑–∞–≤—Ç—Ä–∞|–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞|—Å—å–æ–≥–æ–¥–Ω—ñ)(?:\s+(?:–≤|–æ)\s+.+)?)",

    # 4) EN: ¬´remind (today|tomorrow|next Monday|on Monday [at ‚Ä¶]|weekdays|daily) WHAT¬ª
    rf"{VERB}\s+(?P<when>(?:today|tomorrow|next\s+\w+|on\s+\w+(?:day)?|weekdays|daily)(?:\s+at\s+.+)?)\s+"
    rf"(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+{Q}?)",

    # 5) Every/–∫–∞–∂–¥—ã–π/—â–æ–¥–Ω—è + –≤—Ä–µ–º—è (–ª—é–±—ã–µ —è–∑—ã–∫–∏): ¬´–Ω–∞–ø–æ–º–Ω–∏ WHAT –∫–∞–∂–¥—ã–π ‚Ä¶ –≤ 9:00¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+"
    rf"(?P<when>(?:–∫–∞–∂–¥\w+|—â–æ–¥–Ω—è|—â–æ—Ç–∏–∂–Ω—è|—â–æ—Å\w+|every|weekdays|daily)(?:\s+(?:–≤|–æ|at)\s+.+)?)",

    # 6) –ë—É–¥–Ω–∏–π/–¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏ + –≤—Ä–µ–º—è: ¬´–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç —Å—Ä–µ–¥—É –≤ 18:30¬ª / ¬´‚Ä¶ –ø–æ –±—É–¥–Ω—è–º –≤ 10¬ª
    rf"{VERB}\s+(?P<what>{Q}?[^\"'‚Äú‚Äù¬´¬ª]+?{Q}?)\s+"
    rf"(?P<when>(?:–ø–æ\s+–±—É–¥–Ω—è–º|–±—É–¥–Ω—è–º|weekdays|"
    rf"(?:–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫|–≤—Ç–æ—Ä–Ω–∏–∫|—Å—Ä–µ–¥–∞|—Å—Ä–µ–¥—É|—á–µ—Ç–≤–µ—Ä–≥|–ø—è—Ç–Ω–∏—Ü–∞|—Å—É–±–±–æ—Ç–∞|–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ)|"
    rf"(?:–ø–æ–Ω–µ–¥—ñ–ª–æ–∫|–≤—ñ–≤—Ç–æ—Ä–æ–∫|—Å–µ—Ä–µ–¥–∞|—á–µ—Ç–≤–µ—Ä|–ø º—è—Ç–Ω–∏—Ü—è|–ø'—è—Ç–Ω–∏—Ü—è|—Å—É–±–æ—Ç–∞|–Ω–µ–¥—ñ–ª—è)|"
    rf"(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday))"
    rf"(?:\s+(?:–≤|–æ|at)\s+.+)?)",
]

PATTERNS = [re.compile(p, re.I | re.U) for p in _RAW_PATTERNS]

def parse_remind(text: str) -> Optional[Tuple[str, str]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (what, when) –∏–ª–∏ None.
    –ü—Ä–∏–º–µ—Ä—ã —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è:
      - ¬´–Ω–∞–ø–æ–º–Ω–∏ –ø–æ–∑–≤–æ–Ω–∏—Ç—å –º–∞–º–µ –∑–∞–≤—Ç—Ä–∞ –≤ 9¬ª
      - ¬´–Ω–∞–ø–æ–º–Ω–∏ —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞ "–ø—Ä–∏–Ω—è—Ç—å —Ç–∞–±–ª–µ—Ç–∫–∏"¬ª
      - ¬´remind me to drink water weekdays at 10¬ª
      - ¬´–Ω–∞–≥–∞–¥–∞–π "–∑–≤—ñ—Ç" —â–æ—Å–µ—Ä–µ–¥–∏ –æ 18:30¬ª
      - ¬´–Ω–∞–ø–æ–º–Ω–∏ –æ—Ç—á—ë—Ç –ø–æ –±—É–¥–Ω—è–º –≤ 10¬ª
      - ¬´remind tomorrow at 7 "call John"¬ª
    """
    s = (text or "").strip()
    if not s:
        return None
    for rx in PATTERNS:
        m = rx.search(s)
        if not m:
            continue
        what = _strip_quotes_punct(m.group("what"))
        when = _strip_quotes_punct(m.group("when"))
        if what and when:
            return what, when
    return None
==========================================================================================
# app/services/i18n.py
==========================================================================================
from __future__ import annotations

from typing import Optional
from datetime import datetime

from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import (
    ForeignKey,
    String,
    Integer,
    TIMESTAMP,
    Text,
    func,
    CheckConstraint,
    Index,
)

from app.db import Base


class Payment(Base):
    __tablename__ = "payments"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    provider: Mapped[str] = mapped_column(String(32))
    plan: Mapped[str] = mapped_column(String(64))

    amount_cents: Mapped[int] = mapped_column(Integer)
    currency: Mapped[str] = mapped_column(String(8), default="USD")

    status: Mapped[str] = mapped_column(String(16))
    external_id: Mapped[Optional[str]] = mapped_column(String(128), nullable=True, index=True)

    # –°—ã—Ä–æ–µ —Ç–µ–ª–æ –≤–µ–±—Ö—É–∫–∞ ‚Äî –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è 256 —Å–∏–º–≤–æ–ª–æ–≤
    payload: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    created_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        server_default=func.now(),
    )
    paid_at: Mapped[Optional[datetime]] = mapped_column(TIMESTAMP(timezone=True), nullable=True)

    __table_args__ = (
        CheckConstraint("amount_cents >= 0", name="ck_payments_amount_nonneg"),
        Index("ix_payments_provider_status", "provider", "status"),
        # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –ø–æ external_id —Ç—ã —É–∂–µ —Å–æ–∑–¥–∞–ª –≤ –ë–î –∫–∞–∫
        # uq_payments_external_id (WHERE external_id IS NOT NULL)
        # ‚Äî –Ω–µ –¥—É–±–ª–∏—Ä—É—é –µ–≥–æ –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –Ω–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞–ª–æ.
    )

    def __repr__(self) -> str:
        return f"<Payment id={self.id} user_id={self.user_id} {self.provider} {self.status}>"
==========================================================================================
# app/services/nlp.py
==========================================================================================
from __future__ import annotations

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, time
from typing import Optional, Literal
from zoneinfo import ZoneInfo

@dataclass
class ParsedReminder:
    what: str
    raw_when: str
    next_run_utc: Optional[datetime] = None
    cron: Optional[str] = None

@dataclass
class ToggleRequest:
    action: Literal["enable", "disable"]
    query: Optional[str] = None
    all: bool = False

@dataclass
class ParseResult:
    intent: Literal["create", "enable", "disable"]
    reminder: Optional[ParsedReminder] = None
    toggle: Optional[ToggleRequest] = None

def parse_any(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParseResult]:
    tgl = parse_toggle(text)
    if tgl:
        return ParseResult(intent=tgl.action, toggle=tgl)
    rem = parse_remind(text, user_tz=user_tz, now=now)
    if rem:
        return ParseResult(intent="create", reminder=rem)
    return None

def parse_remind(text: str, user_tz: str = "Europe/Kyiv", now: Optional[datetime] = None) -> Optional[ParsedReminder]:
    tz = ZoneInfo(user_tz)
    now = now or datetime.now(tz)
    text_norm = _normalize(text)

    cron = _parse_recurring_cron(text_norm)
    if cron:
        what = _extract_what(text_norm, recurring=True)
        if not what:
            return None
        return ParsedReminder(what=what, raw_when=text.strip(), cron=cron)

    dt = _parse_once_datetime(text_norm, now, tz)
    if dt:
        what = _extract_what(text_norm, recurring=False)
        if not what:
            return None
        return ParsedReminder(what=what, raw_when=text.strip(), next_run_utc=dt.astimezone(ZoneInfo("UTC")))
    return None

_TOGGLE_ON_WORDS  = r"(?:–≤–∫–ª—é—á–∏|–≤–∫–ª|—É–≤—ñ–º–∫–Ω–∏|—É–≤—ñ–º–∫|on|enable)"
_TOGGLE_OFF_WORDS = r"(?:–≤—ã–∫–ª—é—á–∏|–≤—ã–∫–ª|–≤—ñ–¥–∫–ª—é—á–∏|–≤–∏–º–∫–Ω–∏|–≤–∏–º–∫|off|disable)"
_REMINDER_WORDS = r"(?:–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏(?:–µ|—è)|–Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è|reminder(?:s)?)"
_ALL_WORDS = r"(?:–≤—Å–µ|—É—Å—ñ|–≤—Å—ñ|all)"

_RE_TOGGLE = re.compile(
    rf"(?i)\b(?P<act>{_TOGGLE_ON_WORDS}|{_TOGGLE_OFF_WORDS})\b"
    rf"(?:\s+{_REMINDER_WORDS})?"
    rf"(?:\s+(?:–ø—Ä–æ|–Ω–∞|–ø–æ|about|for))?"
    rf"(?:\s+(?P<all>{_ALL_WORDS}))?"
    rf"(?:\s*(?P<query>.+))?$"
)

def parse_toggle(text: str) -> Optional[ToggleRequest]:
    s = _normalize(text)
    m = _RE_TOGGLE.match(s)
    if not m:
        return None
    act = m.group("act")
    action: Literal["enable", "disable"] = "enable" if re.search(rf"^{_TOGGLE_ON_WORDS}$", act, flags=re.I) else "disable"
    is_all = bool(m.group("all") and m.group("all").strip())
    query = (m.group("query") or "").strip()
    if is_all:
        return ToggleRequest(action=action, query=None, all=True)
    if not query:
        return ToggleRequest(action=action, query=None, all=True)
    return ToggleRequest(action=action, query=query, all=False)

_TRIGGERS = r"(?:–Ω–∞–ø–æ–º–Ω–∏|–Ω–∞–≥–∞–¥–∞–π|remind(?:\s+me\s+to)?)"
_RE_IN = r"(?:—á–µ—Ä–µ–∑|–∑–∞|in)"
_RE_AT = r"(?:–≤|–æ|at)"
_RE_TODAY = r"(?:—Å–µ–≥–æ–¥–Ω—è|—Å—å–æ–≥–æ–¥–Ω—ñ|today)"
_RE_TOMORROW = r"(?:–∑–∞–≤—Ç—Ä–∞|tomorrow)"
_RE_EVERY = r"(?:–∫–∞–∂–¥—ã–π|–∫–∞–∂–¥—É—é|–∫–∞–∂–¥–æ–µ|—â–æ–¥–Ω—è|—â–æ—Ç–∏–∂–Ω—è|—â–æ—Å–µ—Ä–µ–¥–∏|—â–æ–ø–æ–Ω–µ–¥—ñ–ª–∫–∞|every|weekdays|daily)"

_DOW_MAP = {
    "–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫": 1, "–≤—Ç–æ—Ä–Ω–∏–∫": 2, "—Å—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä–≥": 4, "–ø—è—Ç–Ω–∏—Ü–∞": 5, "—Å—É–±–±–æ—Ç–∞": 6, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ": 0, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω–∏–µ": 0,
    "–ø–æ–Ω–µ–¥—ñ–ª–æ–∫": 1, "–≤—ñ–≤—Ç–æ—Ä–æ–∫": 2, "—Å–µ—Ä–µ–¥–∞": 3, "—á–µ—Ç–≤–µ—Ä": 4, "–ø º—è—Ç–Ω–∏—Ü—è": 5, "–ø'—è—Ç–Ω–∏—Ü—è": 5, "—Å—É–±–æ—Ç–∞": 6, "–Ω–µ–¥—ñ–ª—è": 0,
    "monday": 1, "tuesday": 2, "wednesday": 3, "thursday": 4, "friday": 5, "saturday": 6, "sunday": 0,
}
_WEEKDAY_SET = set(_DOW_MAP.keys())

_RE_TIME = re.compile(r"\b(?P<h>\d{1,2})(?::(?P<m>\d{2}))?\s*(?P<ampm>am|pm)?\b", re.I)
_RE_DATE_DOT = re.compile(r"\b(?P<d>\d{1,2})\.(?P<m>\d{1,2})(?:\.(?P<y>\d{4}))?\b")
_RE_DATE_ISO = re.compile(r"\b(?P<y>\d{4})-(?P<m>\d{1,2})-(?P<d>\d{1,2})\b")

_RE_REL = re.compile(
    rf"\b{_RE_IN}\s+"
    r"(?:(?P<hours>\d+)\s*(?:—á–∞—Å(?:–∞|–æ–≤)?|–≥–æ–¥(?:–∏–Ω–∏)?|h|hours?)\s*)?"
    r"(?:(?P<minutes>\d+)\s*(?:–º–∏–Ω—É—Ç(?:—ã)?|—Ö–≤(?:–∏–ª–∏–Ω)?|m|mins?|minutes?)\s*)?"
    r"(?:(?P<days>\d+)\s*(?:–¥–Ω(?:—è|–µ–π|—ñ–≤)?|days?)\s*)?"
    r"(?:(?P<weeks>\d+)\s*(?:–Ω–µ–¥–µ–ª(?:—è|–∏|—å)|—Ç–∏–∂–Ω(?:—ñ|—ñ–≤)|weeks?)\s*)?"
    r"\b",
    re.I,
)

def _normalize(text: str) -> str:
    t = text.strip().lower().replace("‚Äô", "'")
    t = re.sub(r"\s+", " ", t)
    return t

def _extract_what(text_norm: str, recurring: bool, allow_without_trigger: bool = True) -> Optional[str]:
    markers = [
        r"\b" + _RE_IN + r"\b",
        r"\b" + _RE_AT + r"\b",
        r"\b" + _RE_TODAY + r"\b",
        r"\b" + _RE_TOMORROW + r"\b",
        r"\b" + _RE_EVERY + r"\b",
        r"\b" + "|".join(map(re.escape, _WEEKDAY_SET)) + r"\b",
        r"\b–ø–æ –±—É–¥–Ω—è–º\b",
        r"\bweekdays\b",
        r"\bdaily\b",
        r"\b—â–æ–¥–Ω—è\b",
    ]
    m = re.search(rf"{_TRIGGERS}\s+(?:me\s+to\s+)?", text_norm)
    if m:
        start = m.end()
    elif allow_without_trigger:
        start = 0
    else:
        return None

    end = len(text_norm)
    for mk in markers:
        mm = re.search(mk, text_norm[start:])
        if mm:
            end = min(end, start + mm.start())

    what = text_norm[start:end].strip(" ,.;:‚Äî-")
    return what or None

def _parse_time_fragment(s: str) -> Optional[time]:
    m = _RE_TIME.search(s)
    if not m:
        return None
    h = int(m.group("h"))
    mnt = int(m.group("m") or 0)
    ampm = (m.group("ampm") or "").lower()
    if ampm == "pm" and 1 <= h <= 11:
        h += 12
    if ampm == "am" and h == 12:
        h = 0
    if not (0 <= h <= 23 and 0 <= mnt <= 59):
        return None
    return time(hour=h, minute=mnt)

def _apply_time(base: datetime, t: time) -> datetime:
    return base.replace(hour=t.hour, minute=t.minute, second=0, microsecond=0)

def _parse_once_datetime(text_norm: str, now: datetime, tz: ZoneInfo) -> Optional[datetime]:
    m = _RE_REL.search(text_norm)
    if m and any(m.group(g) for g in ("minutes", "hours", "days", "weeks")):
        dt = now
        if m.group("minutes"): dt += timedelta(minutes=int(m.group("minutes")))
        if m.group("hours"):   dt += timedelta(hours=int(m.group("hours")))
        if m.group("days"):    dt += timedelta(days=int(m.group("days")))
        if m.group("weeks"):   dt += timedelta(weeks=int(m.group("weeks")))
        return dt

    date_dt = None
    mi = _RE_DATE_ISO.search(text_norm)
    md = _RE_DATE_DOT.search(text_norm)
    if mi:
        y, mo, d = int(mi.group("y")), int(mi.group("m")), int(mi.group("d"))
        date_dt = datetime(y, mo, d, tzinfo=tz)
    elif md:
        d, mo = int(md.group("d")), int(md.group("m"))
        y = int(md.group("y")) if md.group("y") else now.year
        date_dt = datetime(y, mo, d, tzinfo=tz)

    tm = _parse_time_fragment(text_norm)
    if date_dt:
        dt = _apply_time(date_dt, tm or time(9, 0))
        return dt

    if re.search(rf"\b{_RE_TODAY}\b", text_norm):
        dt = _apply_time(now, tm or time(9, 0))
        if tm is None and dt < now:
            dt = dt + timedelta(hours=1)
        return dt

    if re.search(rf"\b{_RE_TOMORROW}\b", text_norm):
        base = (now + timedelta(days=1)).replace(hour=9, minute=0, second=0, microsecond=0)
        if tm:
            base = _apply_time(base, tm)
        return base

    if tm:
        dt = _apply_time(now, tm)
        if dt <= now:
            dt += timedelta(days=1)
        return dt
    return None

def _parse_recurring_cron(text_norm: str) -> Optional[str]:
    tm = _parse_time_fragment(text_norm)
    if not tm:
        return None
    minute = tm.minute
    hour = tm.hour

    if re.search(r"\b(daily|—â–æ–¥–Ω—è|–∫–∞–∂–¥—ã–π –¥–µ–Ω—å)\b", text_norm):
        return f"{minute} {hour} * * *"

    if re.search(r"\b(weekdays|–ø–æ –±—É–¥–Ω—è–º)\b", text_norm):
        return f"{minute} {hour} * * 1-5"

    if re.search(r"\b(–∫–∞–∂–¥\w+|—â–æ—Å\w+|every)\b", text_norm):
        wd = _find_weekday(text_norm)
        if wd is not None:
            return f"{minute} {hour} * * {wd}"

    wd = _find_weekday(text_norm)
    if wd is not None and re.search(rf"\b{_RE_AT}\b", text_norm):
        return f"{minute} {hour} * * {wd}"
    return None

def _find_weekday(text_norm: str) -> Optional[int]:
    pos = -1
    val = None
    for name, dow in _DOW_MAP.items():
        m = re.search(rf"\b{name}\b", text_norm)
        if m and m.start() > pos:
            pos = m.start()
            val = dow
    return val

__all__ = [
    "ParsedReminder",
    "ToggleRequest",
    "ParseResult",
    "parse_any",
    "parse_remind",
    "parse_toggle",
]

==========================================================================================
# app/services/payments.py
==========================================================================================

==========================================================================================
# app/services/payments/__init__.py
==========================================================================================
from .coinbase import create_coinbase_charge, build_pay_kb
__all__=["create_coinbase_charge","build_pay_kb"]

==========================================================================================
# app/services/payments/coinbase.py
==========================================================================================
# app/services/payments/coinbase.py
from __future__ import annotations

import aiohttp, json, uuid
from typing import Optional, Tuple
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from app.config import settings
from app.models.user import User
from app.models.payment import Payment

API_BASE = getattr(settings, "coinbase_api_base", "https://api.commerce.coinbase.com")
COINBASE_CHARGES = "/charges"

def _headers(idempotency_key: str | None = None) -> dict:
    h = {
        "X-CC-Api-Key": settings.coinbase_api_key,
        "X-CC-Version": "2018-03-22",
        "Content-Type": "application/json",
    }
    if idempotency_key:
        h["Idempotency-Key"] = idempotency_key
    return h

async def create_coinbase_charge(
    session: AsyncSession,
    user: User,
    *,
    plan: str = "monthly",
    amount_usd: Optional[float] = None,
    description: Optional[str] = None,
) -> Tuple[Payment, str]:
    amount_usd = float(amount_usd if amount_usd is not None else settings.premium_price_usd)
    amount_cents = int(round(amount_usd * 100))

    pay = Payment(
        user_id=user.id,
        provider="coinbase",
        plan=plan,
        amount_cents=amount_cents,
        currency="USD",
        status="pending",
        payload=f"user:{user.id};plan:{plan}",
    )
    session.add(pay)
    await session.commit()
    await session.refresh(pay)

    body = {
        "name": "Premium 1 month",
        "description": description or "Diary Assistant Premium ‚Äî 1 month access",
        "pricing_type": "fixed_price",
        "local_price": {"amount": f"{amount_usd:.2f}", "currency": "USD"},
        "metadata": {"payment_id": str(pay.id), "user_id": str(user.id), "plan": plan},
    }

    timeout = aiohttp.ClientTimeout(total=25)
    idem = str(uuid.uuid4())

    async with aiohttp.ClientSession(timeout=timeout) as http:
        async with http.post(f"{API_BASE}{COINBASE_CHARGES}", headers=_headers(idem), data=json.dumps(body)) as resp:
            data = await resp.json()
            if resp.status >= 300:
                # –æ—Ç–º–µ—Ç–∏–º –æ—à–∏–±–∫—É –≤ –ø–ª–∞—Ç–µ–∂–µ –∏ –ø—Ä–æ–±—Ä–æ—Å–∏–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
                pay.status = "error"
                pay.payload = (pay.payload or "") + f";err:{resp.status}"
                await session.commit()
                raise RuntimeError(f"Coinbase create charge error {resp.status}: {data}")

    charge = data.get("data") or {}
    hosted_url = charge.get("hosted_url")
    pay.external_id = charge.get("id")
    await session.commit()
    return pay, hosted_url

def build_pay_kb(url: str, lang: str = "ru") -> InlineKeyboardMarkup:
    text = {
        "ru": "üíé –û–ø–ª–∞—Ç–∏—Ç—å Premium (Crypto)",
        "uk": "üíé –û–ø–ª–∞—Ç–∏—Ç–∏ Premium (Crypto)",
        "en": "üíé Pay Premium (Crypto)",
    }.get((lang or "ru")[:2], "üíé Pay Premium (Crypto)")
    return InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=text, url=url)]])
==========================================================================================
# app/services/reminders.py
==========================================================================================
# app/services/reminders.py
from __future__ import annotations

from datetime import datetime, timezone, timedelta
from zoneinfo import ZoneInfo

from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

try:
    from croniter import croniter  # pip install croniter
except Exception:  # fallback-—Å—Ç–∞–±, —á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞—Ç—å
    croniter = None  # type: ignore

# –ú–æ–¥–µ–ª–∏
from app.models.user import User
from app.models.reminder import Reminder


# ---------- i18n –º–∏–Ω–∏-–Ω–∞–±–æ—Ä ----------
_TEXT = {
    "ding": {
        "ru": "‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {title}",
        "uk": "‚è∞ –ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è: {title}",
        "en": "‚è∞ Reminder: {title}",
    }
}

def _pick_lang(u: User | None) -> str:
    cand = (getattr(u, "locale", None) or getattr(u, "lang", None) or "ru").lower()
    cand = cand.split("-")[0]
    return cand if cand in {"ru", "uk", "en"} else "ru"

def _fmt_local(dt_utc: datetime, tz_name: str | None) -> str:
    try:
        return dt_utc.astimezone(ZoneInfo(tz_name or "Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return dt_utc.astimezone(ZoneInfo("Europe/Kyiv")).strftime("%Y-%m-%d %H:%M")


# ---------- cron ‚Üí next UTC ----------
async def compute_next_run(cron: str, now_utc: datetime, tz_name: str) -> datetime | None:
    """
    cron: —Å—Ç—Ä–æ–∫–∞ crontab, –Ω–∞–ø—Ä. "0 9 * * 1-5"
    now_utc: —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç (UTC, aware)
    tz_name: –∏–º—è TZ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (Europe/Kyiv –∏ —Ç.–ø.)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π –∑–∞–ø—É—Å–∫ –≤ UTC (aware) –ª–∏–±–æ None.
    """
    if croniter is None:
        return None
    try:
        base_local = now_utc.astimezone(ZoneInfo(tz_name or "UTC"))
        it = croniter(cron, base_local)
        nxt_local = it.get_next(datetime)  # aware –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π TZ
        return nxt_local.astimezone(timezone.utc)
    except Exception:
        return None


# ---------- —è–¥—Ä–æ —Ç–∏–∫–∞ ----------
async def _tick_with_session(session: AsyncSession, bot) -> None:
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ/–¥–æ–ª–∂–Ω—ã–µ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.
    - –ë–µ—Ä—ë–º due –≤ UTC
    - –®–ª—ë–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    - –ï—Å–ª–∏ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ ‚Äî —Å—á–∏—Ç–∞–µ–º next_run; –µ—Å–ª–∏ –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ ‚Äî –≤—ã–∫–ª—é—á–∞–µ–º
    """
    now_utc = datetime.now(timezone.utc)

    # –ü–æ–¥—Ç—è–≥–∏–≤–∞–µ–º –≤–º–µ—Å—Ç–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (–¥–ª—è tz/locale/tg_id)
    q = (
        select(Reminder, User)
        .join(User, Reminder.user_id == User.id)
        .where(
            and_(
                Reminder.is_active.is_(True),
                Reminder.next_run.is_not(None),
                Reminder.next_run <= now_utc,
            )
        )
        .order_by(Reminder.next_run.asc())
        .limit(100)
    )
    rows = (await session.execute(q)).all()

    for r, u in rows:
        # –ë–µ–∑ tg_id —Å–º—ã—Å–ª–∞ —Å–ª–∞—Ç—å –Ω–µ—Ç ‚Äî –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º
        if not getattr(u, "tg_id", None):
            r.is_active = False
            session.add(r)
            continue

        lang = _pick_lang(u)
        txt = _TEXT["ding"][lang].format(title=r.title or "reminder")
        try:
            await bot.send_message(u.tg_id, txt)
        except Exception:
            # –ù–∞–ø—Ä–∏–º–µ—Ä, 403 (bot was blocked). –ß—Ç–æ–±—ã –Ω–µ –∑–∞–±–∏–≤–∞—Ç—å –æ—á–µ—Ä–µ–¥—å ‚Äî –≥–ª—É—à–∏–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.
            r.is_active = False
            session.add(r)
            continue

        # –ü–µ—Ä–µ—Å—Ç–∞–≤–ª—è–µ–º next_run
        if r.cron:
            nxt = await compute_next_run(r.cron, now_utc + timedelta(seconds=1), u.tz or "Europe/Kyiv")
            if nxt:
                r.next_run = nxt
            else:
                r.is_active = False  # –Ω–µ —Å–º–æ–≥–ª–∏ –ø–æ—Å—á–∏—Ç–∞—Ç—å ‚Äî –≤—ã–∫–ª—é—á–∏–º
        else:
            # –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ
            r.is_active = False
            r.next_run = None

        session.add(r)

    if rows:
        await session.commit()


# ---------- –≤–Ω–µ—à–Ω–∏–π API —Å –≥–∏–±–∫–æ–π —Å–∏–≥–Ω–∞—Ç—É—Ä–æ–π ----------
async def tick_reminders(*args):
    """
    –ì–∏–±–∫–∏–π –∞–¥–∞–ø—Ç–µ—Ä, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å main.py.
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º:
      - await tick_reminders(session, bot)
      - await tick_reminders(bot, async_sessionmaker)
      - await tick_reminders(async_sessionmaker, bot)
    """
    if len(args) != 2:
        raise TypeError("tick_reminders expects 2 args: (session, bot) OR (bot, sessionmaker)")

    a, b = args[0], args[1]

    # –í–∞—Ä–∏–∞–Ω—Ç 1: –Ω–∞–º –¥–∞–ª–∏ (session, bot)
    if hasattr(a, "execute") and hasattr(b, "send_message"):
        session, bot = a, b
        return await _tick_with_session(session, bot)

    # –í–∞—Ä–∏–∞–Ω—Ç 2/3: –Ω–∞–º –¥–∞–ª–∏ –±–æ—Ç –∏ —Ñ–∞–±—Ä–∏–∫—É —Å–µ—Å—Å–∏–π (–∏–ª–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç)
    if hasattr(a, "send_message") and callable(b):
        bot, sessionmaker = a, b
    elif hasattr(b, "send_message") and callable(a):
        bot, sessionmaker = b, a
    else:
        raise TypeError("tick_reminders: unable to detect (session vs bot vs sessionmaker)")

    # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é –∏–∑ —Ñ–∞–±—Ä–∏–∫–∏
    session = await sessionmaker() if "await" in getattr(sessionmaker, "__code__", type("", (), {})()).co_names else sessionmaker()
    async with session as s:
        return await _tick_with_session(s, bot)

def now_utc() -> datetime:
    return datetime.now(timezone.utc)

def to_utc(dt: datetime, tz_name: str | None) -> datetime:
    """–õ–æ–∫–∞–ª—å–Ω–æ–µ -> UTC (aware). –ï—Å–ª–∏ dt naive ‚Äî —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –æ–Ω –≤ tz_name."""
    try:
        tz = ZoneInfo(tz_name or "UTC")
    except Exception:
        tz = ZoneInfo("UTC")
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=tz)
    else:
        dt = dt.astimezone(tz)
    return dt.astimezone(timezone.utc)

def to_local(dt_utc: datetime, tz_name: str | None) -> datetime:
    """UTC -> –ª–æ–∫–∞–ª—å–Ω–æ–µ (aware)."""
    if dt_utc.tzinfo is None:
        dt_utc = dt_utc.replace(tzinfo=timezone.utc)
    try:
        tz = ZoneInfo(tz_name or "Europe/Kyiv")
    except Exception:
        tz = ZoneInfo("Europe/Kyiv")
    return dt_utc.astimezone(tz)
==========================================================================================
# app/texts.py
==========================================================================================

from typing import Dict

DEFAULT_LOCALE = "ru"
SUPPORTED_LOCALES = {"ru", "uk", "en"}

TEXTS: Dict[str, Dict[str, str]] = {
    "ru": {
        # common
        "welcome": "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –¥–Ω–µ–≤–Ω–∏–∫-–ø–æ–º–æ—â–Ω–∏–∫. –ù–∞–∂–º–∏ üîí –ü–æ–ª–∏—Ç–∏–∫–∞, —á—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å —É—Å–ª–æ–≤–∏—è –∏ –Ω–∞—á–∞—Ç—å.",
        "privacy": "–≠—Ç–æ –ø–æ–º–æ—â–Ω–∏–∫-–¥–Ω–µ–≤–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø–∏—è –∏ –Ω–µ –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∞—è —É—Å–ª—É–≥–∞.",
        "privacy_answer": "–û—Ç–≤–µ—Ç: –°–æ–≥–ª–∞—Å–µ–Ω / –ù–µ —Å–æ–≥–ª–∞—Å–µ–Ω",
        "privacy_thanks": "–°–ø–∞—Å–∏–±–æ! –ú–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å. –ù–∞–ø–∏—à–∏ –ø–µ—Ä–≤—É—é –∑–∞–ø–∏—Å—å: /journal",
        "privacy_declined": "–û–∫. –Ø –Ω–µ –±—É–¥—É —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –∑–∞–ø–∏—Å–∏, –ø–æ–∫–∞ –≤—ã –Ω–µ —Å–æ–≥–ª–∞—Å–Ω—ã.",
        "choose_lang": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫: RU / UK / EN (–º–æ–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å: —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / –∞–Ω–≥–ª–∏–π—Å–∫–∏–π)",
        "lang_updated": "–ì–æ—Ç–æ–≤–æ. –Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª—ë–Ω.",
        "press_start": "–ù–∞–∂–º–∏ /start",
        "main_hint": "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É.",

        # menu/buttons
        "menu_meditation": "üßò –ú–µ–¥–∏—Ç–∞—Ü–∏—è",
        "menu_music": "üéµ –ú—É–∑—ã–∫–∞",
        "btn_language": "üåê –Ø–∑—ã–∫",
        "btn_privacy":  "üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
        "btn_report":   "üõ† –°–æ–æ–±—â–∏—Ç—å –ø—Ä–æ –±–∞–≥",
        "btn_premium":  "üíé –ü—Ä–µ–º–∏—É–º",

        # features
        "meditations_intro": "üßò –ü–æ–¥–±–æ—Ä–∫–∞ –∫–æ—Ä–æ—Ç–∫–∏—Ö –º–µ–¥–∏—Ç–∞—Ü–∏–π –∏ –¥—ã—Ö–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–∞–∫—Ç–∏–∫.",
        "music_intro": "üéµ –ú—É–∑—ã–∫–∞ –¥–ª—è —Ñ–æ–∫—É—Å–∞, —Å–Ω–∞ –∏ —Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–∏—è.",
        "med_choose": "–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü–∏–∏:",
        "music_choose": "–í—ã–±–µ—Ä–∏ –ø–ª–µ–π–ª–∏—Å—Ç:",
    },
    "uk": {
        "welcome": "–ü—Ä–∏–≤—ñ—Ç! –¶–µ —â–æ–¥–µ–Ω–Ω–∏–∫-–ø–æ–º—ñ—á–Ω–∏–∫. –ù–∞—Ç–∏—Å–Ω–∏ üîí –ü–æ–ª—ñ—Ç–∏–∫–∞, —â–æ–± –ø—Ä–∏–π–Ω—è—Ç–∏ —É–º–æ–≤–∏ —ñ –ø–æ—á–∞—Ç–∏.",
        "privacy": "–¶–µ –ø–æ–º—ñ—á–Ω–∏–∫-—â–æ–¥–µ–Ω–Ω–∏–∫, –Ω–µ —Ç–µ—Ä–∞–ø—ñ—è —ñ –Ω–µ –º–µ–¥–∏—á–Ω–∞ –ø–æ—Å–ª—É–≥–∞.",
        "privacy_answer": "–í—ñ–¥–ø–æ–≤—ñ–¥—å: –ó–≥–æ–¥–µ–Ω / –ù–µ –∑–≥–æ–¥–µ–Ω",
        "privacy_thanks": "–î—è–∫—É—é! –ü–æ—á–∏–Ω–∞—î–º–æ. –ù–∞–ø–∏—à–∏ –ø–µ—Ä—à–∏–π –∑–∞–ø–∏—Å: /journal",
        "privacy_declined": "–û–∫. –Ø –Ω–µ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏–º—É –∑–∞–ø–∏—Å–∏, –ø–æ–∫–∏ –≤–∏ –Ω–µ –∑–≥–æ–¥–Ω—ñ.",
        "choose_lang": "–û–±–µ—Ä–∏ –º–æ–≤—É: RU / UK / EN (–º–æ–∂–Ω–∞ –Ω–∞–ø–∏—Å–∞—Ç–∏: —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / —Ä—É—Å—Å–∫–∏–π / english)",
        "lang_updated": "–ì–æ—Ç–æ–≤–æ. –ú–æ–≤—É –æ–Ω–æ–≤–ª–µ–Ω–æ.",
        "press_start": "–ù–∞—Ç–∏—Å–Ω–∏ /start",
        "main_hint": "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é ‚Äî –≤–Ω–∏–∑—É.",

        "menu_meditation": "üßò –ú–µ–¥–∏—Ç–∞—Ü—ñ—è",
        "menu_music": "üéµ –ú—É–∑–∏–∫–∞",
        "btn_language": "üåê –ú–æ–≤–∞",
        "btn_privacy":  "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
        "btn_report":   "üõ† –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
        "btn_premium":  "üíé –ü—Ä–µ–º—ñ—É–º",

        "meditations_intro": "üßò –î–æ–±—ñ—Ä–∫–∞ –∫–æ—Ä–æ—Ç–∫–∏—Ö –º–µ–¥–∏—Ç–∞—Ü—ñ–π —Ç–∞ –¥–∏—Ö–∞–ª—å–Ω–∏—Ö –ø—Ä–∞–∫—Ç–∏–∫.",
        "music_intro": "üéµ –ú—É–∑–∏–∫–∞ –¥–ª—è —Ñ–æ–∫—É—Å—É, —Å–Ω—É —Ç–∞ —Ä–æ–∑—Å–ª–∞–±–ª–µ–Ω–Ω—è.",
        "med_choose": "–û–±–µ—Ä—ñ—Ç—å —Ä–µ–∂–∏–º –º–µ–¥–∏—Ç–∞—Ü—ñ—ó:",
        "music_choose": "–í–∏–±–µ—Ä—ñ—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç:",
    },
    "en": {
        "welcome": "Hi! This is a diary assistant. Tap üîí Privacy to accept the policy and start.",
        "privacy": "This is a journal assistant, not therapy or a medical service.",
        "privacy_answer": "Reply: Agree / Disagree",
        "privacy_thanks": "Thanks! You can start. Send your first entry: /journal",
        "privacy_declined": "Okay. I won‚Äôt save entries until you agree.",
        "choose_lang": "Choose language: RU / UK / EN (you can also type: —Ä—É—Å—Å–∫–∏–π / —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞ / english)",
        "lang_updated": "Done. Language updated.",
        "press_start": "Press /start",
        "main_hint": "Main menu is below.",

        "menu_meditation": "üßò Meditation",
        "menu_music": "üéµ Music",
        "btn_language": "üåê Language",
        "btn_privacy":  "üîí Privacy",
        "btn_report":   "üõ† Report a bug",
        "btn_premium":  "üíé Premium",

        "meditations_intro": "üßò Short meditations and breathing exercises.",
        "music_intro": "üéµ Music for focus, sleep and relaxation.",
        "med_choose": "Choose a meditation mode:",
        "music_choose": "Choose a playlist:",
    },
}

def _normalize_lang(lang: str | None) -> str:
    if not lang:
        return DEFAULT_LOCALE
    lang = lang.lower()[:2]
    return lang if lang in SUPPORTED_LOCALES else DEFAULT_LOCALE

def t(key: str, lang: str | None = None, **kwargs) -> str:
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ —Å —Ñ–æ–ª–±—ç–∫–∞–º–∏ –∏ .format(**kwargs).
    –ü–æ—Ä—è–¥–æ–∫ —Ñ–æ–ª–±—ç–∫–æ–≤: lang -> DEFAULT_LOCALE -> 'en' -> key
    """
    loc = _normalize_lang(lang)
    s = TEXTS.get(loc, {}).get(key)
    if s is None:
        s = TEXTS.get(DEFAULT_LOCALE, {}).get(key)
    if s is None:
        s = TEXTS.get("en", {}).get(key)
    if s is None:
        s = key
    try:
        return s.format(**kwargs)
    except Exception:
        return s

==========================================================================================
# app/urls.py
==========================================================================================
from .config import PUBLIC_URL
def pay_url(tg_id: int) -> str:
    return f"{PUBLIC_URL.rstrip('/')}/pay?tg_id={tg_id}"

==========================================================================================
# app/web.py
==========================================================================================
from fastapi import FastAPI

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–π —Å–≤–æ–π —Ä–æ—É—Ç–µ—Ä —Å Coinbase –≤–µ–±—Ö—É–∫–∞–º–∏.
# –§–∞–π–ª —Ç—ã –∫–∏–¥–∞–ª –∫–∞–∫ –º–æ–¥—É–ª—å —Å APIRouter ‚Äî —Å—á–∏—Ç–∞—é, —á—Ç–æ –æ–Ω –ª–µ–∂–∏—Ç –≤ app/api/coinbase.py
# –ï—Å–ª–∏ —É —Ç–µ–±—è –¥—Ä—É–≥–æ–µ –∏–º—è/–ø—É—Ç—å ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ–ø—Ä–∞–≤—å –∏–º–ø–æ—Ä—Ç –Ω–∏–∂–µ.
from app.api.coinbase import router as coinbase_router

app = FastAPI(title="DiaryBot API", version="1.0")
app.include_router(coinbase_router)

@app.get("/healthz")
def healthz():
    return {"ok": True}

==========================================================================================
# app/webhooks/__init__.py
==========================================================================================

==========================================================================================
# app/webhooks/coinbase.py
==========================================================================================
# app/api/coinbase.py
from __future__ import annotations

import hmac, hashlib, json
from datetime import datetime, timezone, timedelta

from fastapi import APIRouter, Request, HTTPException
from starlette.responses import RedirectResponse
from sqlalchemy import select

from app.config import settings
from app.db import async_session
from app.models.payment import Payment
from app.models.user import User
from app.services.payments.coinbase import create_coinbase_charge

router = APIRouter(prefix="/payments/coinbase", tags=["payments"])

def _verify_signature(raw: bytes, sig: str | None) -> None:
    secret = (settings.coinbase_webhook_secret or "").encode()
    if not secret:
        raise HTTPException(500, "webhook secret is not set")
    calc = hmac.new(secret, raw, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(calc, (sig or "")):
        raise HTTPException(400, "bad signature")

@router.post("/webhook")
async def coinbase_webhook(request: Request):
    raw = await request.body()
    _verify_signature(raw, request.headers.get("X-CC-Webhook-Signature"))

    try:
        payload = json.loads(raw.decode("utf-8"))
    except Exception:
        raise HTTPException(400, "bad json")

    evt = (payload.get("event") or {})
    etype = evt.get("type")
    data = (evt.get("data") or {})
    meta = (data.get("metadata") or {})
    ext_id = data.get("id")

    local_pricing = ((data.get("pricing") or {}).get("local") or {})
    local_amount = local_pricing.get("amount")
    local_currency = local_pricing.get("currency")

    async with async_session() as s:
        # 1) –∏—â–µ–º –ø–ª–∞—Ç—ë–∂ –ø–æ external_id (–∏/–∏–ª–∏ –ø–æ metadata.payment_id –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤)
        pay = (await s.execute(select(Payment).where(Payment.external_id == ext_id))).scalar_one_or_none()
        if not pay and meta.get("payment_id"):
            pay = (await s.execute(select(Payment).where(Payment.id == int(meta["payment_id"])))).scalar_one_or_none()

        if not pay:
            # –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —á–∞—Ä–¥–∂ ‚Äî —Ç–∏—Ö–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º (–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å)
            return {"ok": True}

        # 2) —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω? —Ç–æ–∂–µ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ –≤—ã—Ö–æ–¥–∏–º
        if pay.status == "succeeded":
            return {"ok": True}

        # 3) –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏ –ø—Ä–æ–¥–ª–µ–≤–∞–µ–º –ø—Ä–µ–º–∏—É–º
        if etype == "charge:confirmed":
            pay.status = "succeeded"
            pay.paid_at = datetime.now(timezone.utc)
            if local_amount and local_currency:
                try:
                    pay.amount_cents = int(round(float(local_amount) * 100))
                    pay.currency = local_currency
                except Exception:
                    pass

            # –ø—Ä–æ–¥–ª–∏—Ç—å –ø—Ä–µ–º–∏—É–º –≤–ª–∞–¥–µ–ª—å—Ü—É
            user = (await s.execute(select(User).where(User.id == pay.user_id))).scalar_one_or_none()
            if user:
                now = datetime.now(timezone.utc)
                base = user.premium_until if user.premium_until and user.premium_until > now else now
                user.premium_until = base + timedelta(days=30)
                s.add(user)

        elif etype in {"charge:failed", "charge:delayed", "charge:expired", "charge:unresolved"}:
            pay.status = "failed"

        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é ¬´–∫–≤–∏—Ç–∞–Ω—Ü–∏—é¬ª —Å–æ–±—ã—Ç–∏—è (–ø–æ–ª–Ω—ã–π JSON –≤ String(256) –Ω–µ –≤–ª–µ–∑–µ—Ç)
        pay.payload = json.dumps({"etype": etype, "ext_id": ext_id}, ensure_ascii=False)[:250]
        s.add(pay)
        await s.commit()

    return {"ok": True}

@router.get("/buy")
async def coinbase_buy(user_id: int | None = None, tg_id: int | None = None):
    if not user_id and not tg_id:
        raise HTTPException(400, "user_id or tg_id required")

    async with async_session() as s:
        if user_id:
            user = (await s.execute(select(User).where(User.id == user_id))).scalar_one_or_none()
        else:
            user = (await s.execute(select(User).where(User.tg_id == tg_id))).scalar_one_or_none()
        if not user:
            raise HTTPException(404, "user not found")

        pay, hosted = await create_coinbase_charge(
            session=s,
            user=user,
            plan="monthly",
            amount_usd=settings.premium_price_usd,
            description="Diary Assistant Premium ‚Äî 1 month",
        )

    return RedirectResponse(hosted, status_code=302)
==========================================================================================
# locales/ru.json
==========================================================================================
{
  "premium_inactive": "–ü—Ä–µ–º–∏—É–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –û—Ñ–æ—Ä–º–∏ –ø–æ–¥–ø–∏—Å–∫—É –∏–ª–∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π –ø—Ä–æ–±–Ω—ã–π –¥–µ–Ω—å.",
  "menu_premium": "üíé –ü—Ä–µ–º–∏—É–º",
  "menu_lang": "üåê –Ø–∑—ã–∫",
  "menu_policy": "üîí –ü–æ–ª–∏—Ç–∏–∫–∞",
  "menu_bug": "üõ† –°–æ–æ–±—â–∏—Ç—å –æ –±–∞–≥–µ",
  "med_choose": "–í—ã–±–µ—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –º–µ–¥–∏—Ç–∞—Ü–∏–∏:",
  "med_started": "–ú–µ–¥–∏—Ç–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ {mins} –º–∏–Ω.",
  "med_finished": "–ú–µ–¥–∏—Ç–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ö–∞–∫ –æ—â—É—â–µ–Ω–∏—è? –ù–∞–ø–∏—à–∏ /journal",
  "cal_send": "–ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ –∏–ª–∏ —Ç–µ–∫—Å—Ç —Å —Å–æ—Å—Ç–∞–≤–æ–º –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä: \"–º–æ–ª–æ–∫–æ 300 –º–ª, –∞—Ä–∞—Ö–∏—Å 40 –≥, –±–∞–Ω–∞–Ω 120 –≥\").",
  "cal_total": "–ò—Ç–æ–≥–æ: {kcal} –∫–∫–∞–ª ‚Äî –ë:{p} –≥ –ñ:{f} –≥ –£:{c} –≥",
  "chat_on": "–†–µ–∂–∏–º –æ–±—â–µ–Ω–∏—è –≤–∫–ª—é—á—ë–Ω.",
  "chat_off": "–†–µ–∂–∏–º –æ–±—â–µ–Ω–∏—è –≤—ã–∫–ª—é—á–µ–Ω.",
  "chat_hint": "–ú–æ–∂–µ—à—å —Å–ø—Ä–æ—Å–∏—Ç—å: ¬´—á—Ç–æ –Ω–∞–¥–µ—Ç—å —Å–µ–≥–æ–¥–Ω—è?¬ª –∏–ª–∏ –ø—Ä–∏—Å–ª–∞—Ç—å —Ñ–æ—Ç–æ.",
  "chat_reply_generic": "–Ø –±—ã –≤—ã–±—Ä–∞–ª —Å–∏–Ω—é—é –∫–æ—Ñ—Ç—É –∏ —Ç—ë–º–Ω—ã–µ –¥–∂–∏–Ω—Å—ã ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ –∏ —É–º–µ—Å—Ç–Ω–æ.",
  "music_hello": "–ü—Ä–∏—à–ª–∏ –∞—É–¥–∏–æ, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –≤ –ø–ª–µ–π–ª–∏—Å—Ç –º–µ–¥–∏—Ç–∞—Ü–∏–∏. –ö–æ–º–∞–Ω–¥–∞: /music ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç—Ä–µ–∫–∏.",
  "music_saved": "–°–æ—Ö—Ä–∞–Ω—ë–Ω —Ç—Ä–µ–∫: {title}",
  "music_list_empty": "–ü–æ–∫–∞ –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤.",
  "music_list": "–¢–≤–æ–∏ —Ç—Ä–µ–∫–∏:\n{items}"
}

==========================================================================================
# locales/uk.json
==========================================================================================
{
  "premium_inactive": "–ü—Ä–µ–º—ñ—É–º –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π. –û—Ñ–æ—Ä–º–∏ –ø—ñ–¥–ø–∏—Å–∫—É –∞–±–æ –∞–∫—Ç–∏–≤—É–π –ø—Ä–æ–±–Ω–∏–π –¥–µ–Ω—å.",
  "menu_premium": "üíé –ü—Ä–µ–º—ñ—É–º",
  "menu_lang": "üåê –ú–æ–≤–∞",
  "menu_policy": "üîí –ü–æ–ª—ñ—Ç–∏–∫–∞",
  "menu_bug": "üõ† –ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥",
  "med_choose": "–û–±–µ—Ä–∏ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –º–µ–¥–∏—Ç–∞—Ü—ñ—ó:",
  "med_started": "–ú–µ–¥–∏—Ç–∞—Ü—ñ—è –∑–∞–ø—É—â–µ–Ω–∞ –Ω–∞ {mins} —Ö–≤.",
  "med_finished": "–ú–µ–¥–∏—Ç–∞—Ü—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –Ø–∫ –≤—ñ–¥—á—É—Ç—Ç—è? –ù–∞–ø–∏—à–∏ /journal",
  "cal_send": "–ù–∞–¥—ñ—à–ª–∏ —Ñ–æ—Ç–æ –∞–±–æ —Ç–µ–∫—Å—Ç –∑—ñ —Å–∫–ª–∞–¥–æ–º —Ç–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—é (–Ω–∞–ø—Ä.: \"–º–æ–ª–æ–∫–æ 300 –º–ª, –∞—Ä–∞—Ö—ñ—Å 40 –≥, –±–∞–Ω–∞–Ω 120 –≥\").",
  "cal_total": "–†–∞–∑–æ–º: {kcal} –∫–∫–∞–ª ‚Äî –ë:{p} –≥ –ñ:{f} –≥ –í:{c} –≥",
  "chat_on": "–†–µ–∂–∏–º —Å–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è —É–≤—ñ–º–∫–Ω–µ–Ω–æ.",
  "chat_off": "–†–µ–∂–∏–º —Å–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω–æ.",
  "chat_hint": "–ú–æ–∂–µ—à —Å–ø–∏—Ç–∞—Ç–∏: \"—è–∫–∏–π –ª—É–∫ –≤–¥—è–≥—Ç–∏ —Å—å–æ–≥–æ–¥–Ω—ñ?\" –∞–±–æ –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ñ–æ—Ç–æ.",
  "chat_reply_generic": "–Ø –± –æ–±—Ä–∞–≤ —Å–∏–Ω—é –∫–æ—Ñ—Ç—É —Ç–∞ —Ç–µ–º–Ω—ñ –¥–∂–∏–Ω—Å–∏ ‚Äî —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–æ —ñ –¥–æ—Ä–µ—á–Ω–æ.",
  "music_hello": "–ù–∞–¥—ñ—à–ª–∏ –∞—É–¥—ñ–æ, —â–æ–± –¥–æ–¥–∞—Ç–∏ —É –ø–ª–µ–π–ª–∏—Å—Ç –º–µ–¥–∏—Ç–∞—Ü—ñ—ó. –ö–æ–º–∞–Ω–¥–∞: /music ‚Äî –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Ç—Ä–µ–∫–∏.",
  "music_saved": "–ó–±–µ—Ä–µ–∂–µ–Ω–æ —Ç—Ä–µ–∫: {title}",
  "music_list_empty": "–ü–æ–∫–∏ —â–æ –Ω–µ–º–∞—î —Ç—Ä–µ–∫—ñ–≤.",
  "music_list": "–¢–≤–æ—ó —Ç—Ä–µ–∫–∏:\n{items}"
}

==========================================================================================
# migrations/env.py
==========================================================================================
from __future__ import annotations
from logging.config import fileConfig
from alembic import context
from sqlalchemy.ext.asyncio import async_engine_from_config
from sqlalchemy import pool
from app.config import settings
target_metadata = None
config = context.config
config.set_main_option("sqlalchemy.url", settings.database_url)
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
def run_migrations_offline():
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url, target_metadata=target_metadata, literal_binds=True, dialect_opts={"paramstyle": "named"})
    with context.begin_transaction():
        context.run_migrations()
def run_migrations_online():
    connectable = async_engine_from_config(config.get_section(config.config_ini_section), prefix="sqlalchemy.", poolclass=pool.NullPool)
    async def do_run_migrations(connection):
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()
    import asyncio
    async def runner():
        async with connectable.connect() as conn:
            await do_run_migrations(conn)
    asyncio.run(runner())
if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

==========================================================================================
# migrations/versions/b0b54fc02dab_payments_table.py
==========================================================================================
"""payments table

Revision ID: b0b54fc02dab
Revises: 
Create Date: 2025-11-14 00:16:30.016965

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'b0b54fc02dab'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    pass


def downgrade() -> None:
    """Downgrade schema."""
    pass

==========================================================================================
# README.md
==========================================================================================
# ValFlow Diary Bot ‚Äî MVP

## –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç
1) –°–∫–æ–ø–∏—Ä—É–π .env.example ‚Üí .env –∏ –∑–∞–ø–æ–ª–Ω–∏ —Ç–æ–∫–µ–Ω/–ë–î.
2) –ü–æ–¥–Ω–∏–º–∏ Postgres (–ª–æ–∫–∞–ª—å–Ω–æ –∏–ª–∏ —á–µ—Ä–µ–∑ Docker) –∏ —Å–æ–∑–¥–∞–π –ë–î valflow_diary.
3) python -m venv .venv && source .venv/bin/activate (Windows: `.venv\\Scripts\\activate`)
4) pip install -r requirements.txt
5) python -m app.main

## –ö–æ–º–∞–Ω–¥—ã –≤ –±–æ—Ç–µ
- /start ‚Äî –æ–Ω–±–æ—Ä–¥–∏–Ω–≥
- /journal ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞ –¥–ª—è –∑–∞–ø–∏—Å–∏
- /stats ‚Äî –∫—Ä–∞—Ç–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
- /remind ‚Äî –ø—Ä–∏–º–µ—Ä —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
- /premium ‚Äî —Å—Ç–∞—Ç—É—Å –ø—Ä–µ–º–∏—É–º–∞

## –î–∏–∑–∞–π–Ω —Ä–µ—à–µ–Ω–∏–π
- –¢–æ–ª—å–∫–æ 3 –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ (üåê Language / üîí Privacy / üõ† Report bug).
- –ü—Ä–µ–º–∏—É–º-–¥–µ–Ω—å –≤—ã–¥–∞—ë—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ—Å–ª–µ 2 –∑–∞–ø–∏—Å–µ–π + 1 –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è + –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ Telegram –∫–∞–Ω–∞–ª.
- –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –ë–î, —Ñ–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç due —Ä–∞–∑ –≤ 30—Å.
- i18n –ø—Ä–æ—Å—Ç–∞—è, JSON-—Ñ–∞–π–ª—ã.

## –ö—É–¥–∞ —Ä–∞–∑–≤–∏–≤–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ
- –≠–∫—Å–ø–æ—Ä—Ç PDF/CSV (–≤–∫–ª—é—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä PDF);
- –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä cron (¬´–∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 9:00¬ª ‚Üí `cron`);
- –ü–ª–∞—Ç–µ–∂–∏ Telegram Stars/Stripe;
- –í–µ–±-–¥–∞—à–±–æ—Ä–¥ (Next.js) —Å –≥—Ä–∞—Ñ–∏–∫–∞–º–∏ –∏ –ø–æ–∏—Å–∫–æ–º;
- –ü–æ–ª–∏—Ç–∏–∫–∞: –∫–Ω–æ–ø–∫–∞ ¬´–∫—Ä–∏–∑–∏—Å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã¬ª –ø—Ä–∏ —Ç—Ä–∏–≥–≥–µ—Ä–∞—Ö.
==========================================================================================
# requirements.txt
==========================================================================================
# –°–æ–≤–º–µ—Å—Ç–∏–º–æ —Å Python 3.13
aiogram>=3.13.0
SQLAlchemy>=2.0
asyncpg>=0.30
alembic>=1.13
pydantic>=2.10
pydantic-settings>=2.4
python-dotenv>=1.0.1
croniter>=2.0.5
dateparser>=1.2.0
orjson>=3.11

==========================================================================================
# scripts/dev.env
==========================================================================================
COMMERCE_CHECKOUT_URL=https://commerce.coinbase.com/checkout/5705c216-b37e-47b5-85dc-919a75e9fe09
PUBLIC_BASE_URL=https://ilda-comelier-pliantly.ngrok-free.dev
COINBASE_COMMERCE_WEBHOOK_SECRET=47870ee0-2bed-4aca-b21e-579d937f9e60
NOWP_API_KEY=QWMJHTA-TCZMKSY-NCXRV89-EPSSZ7R
NOWP_IPN_SECRET=eQBo37jPkSapbxGyUtjFyySe6S2EYsOm
NOWP_PRICE_USD=3.00
NOWP_BASE=https://api.nowpayments.io/v1
ENABLE_NOWPAYMENTS=1
ENABLE_COINBASE=0
SUB_PRICE_USD=10
TG_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
TELEGRAM_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
BOT_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8

MONO_PRICE_UAH=12000

MONO_TOKEN=mwWTgxfdFSrx89aPw0jgRWQ

==========================================================================================
# scripts_msgfmt.py
==========================================================================================

import sys, struct, io, re
def parse_po(po_text:str):
    msgs = {}
    msgid = None
    msgstr = None
    lines = iter(po_text.splitlines())
    def unq(s): return bytes(s[1:-1], "utf-8").decode("unicode_escape")
    for line in lines:
        if line.startswith("msgid "):
            msgid = unq(line[5:].strip())
            cont=[]
            for l in lines:
                if l.startswith("msgstr "):
                    msgstr = unq(l[6:].strip()); break
                if l.startswith('"'): cont.append(unq(l.strip()))
                else: break
            if cont: msgid += "".join(cont)
            cont=[]
            for l in lines:
                if l.startswith('"'):
                    cont.append(unq(l.strip()))
                else:
                    msgs[msgid]=msgstr+("".join(cont) if cont else "")
                    msgid=None; msgstr=None
                    if l.startswith("msgid "):
                        msgid = unq(l[5:].strip()); cont=[]
                        for l2 in lines:
                            if l2.startswith("msgstr "):
                                msgstr = unq(l2[6:].strip()); break
                            if l2.startswith('"'): cont.append(unq(l2.strip()))
                            else: break
                        if cont: msgid += "".join(cont)
                        cont=[]
                        for l2 in lines:
                            if l2.startswith('"'): cont.append(unq(l2.strip()))
                            else:
                                msgs[msgid]=msgstr+("".join(cont) if cont else ""); msgid=None; msgstr=None
                                break
                    break
    if msgid is not None:
        msgs[msgid]=msgstr or ""
    return msgs
def write_mo(msgs, out):
    KEYS=list(msgs.keys())
    ids=b"\x00".join(s.encode("utf-8") for s in KEYS)+b"\x00"
    strs=b"\x00".join(msgs[k].encode("utf-8") for k in KEYS)+b"\x00"
    keystart=7*4+16*len(KEYS)
    valstart=keystart+len(ids)
    koffsets=[]; voffsets=[]
    off=0
    for k in KEYS:
        bts=k.encode("utf-8")+b"\x00"
        koffsets.append((len(bts)-1, keystart+off)); off+=len(bts)
    off=0
    for k in KEYS:
        bts=msgs[k].encode("utf-8")+b"\x00"
        voffsets.append((len(bts)-1, valstart+off)); off+=len(bts)
    out.write(struct.pack("Iiiiiii",0x950412de,0, len(KEYS), 7*4, 7*4+8*len(KEYS), 0,0))
    for ln,ofs in koffsets: out.write(struct.pack("II", ln, ofs))
    for ln,ofs in voffsets: out.write(struct.pack("II", ln, ofs))
    out.write(ids); out.write(strs)
def compile_po_to_mo(src, dst):
    text=open(src,"r",encoding="utf-8").read()
    msgs=parse_po(text)
    with open(dst,"wb") as f: write_mo(msgs,f)
if __name__=="__main__":
    compile_po_to_mo(sys.argv[1], sys.argv[2])

==========================================================================================
# storage/music/319145673/index.json
==========================================================================================
[
  {
    "file_id": "CQACAgIAAxkBAAICg2kouvl_Psh6gfS_k6AHFwABQ9KBIwACtIgAAm3BSUncuanNsOQ_vTYE",
    "title": "Hugo_Strasser_There_Is_A_House_The_House_Of_The_Rising_Sun_SkySound.mp3"
  }
]
==========================================================================================
# storage/music/377555215/index.json
==========================================================================================
[
  {
    "file_id": "CQACAgIAAxkBAAICcWkoucLVKGdv6oe7JAxdRRpfE7_GAAJpiAACxrtASepUrtnJvT0iNgQ",
    "title": "Enza - Ride It (Original Mix).mp3"
  }
]
==========================================================================================
# storage/music/6657238126/index.json
==========================================================================================
[
  {
    "file_id": "CQACAgIAAxkBAAICnGkovrxgZOeyQeLnK5uNBbyry4-cAAIKhgACY0pJST9uW44hJ3nrNgQ",
    "title": "d1n_mc-pochemu-odna-a-pochemu-grustish-a-pochemu-ty-ne-spish.mp3"
  }
]
==========================================================================================
# README.md
==========================================================================================
# ValFlow Diary Bot ‚Äî MVP

## –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç
1) –°–∫–æ–ø–∏—Ä—É–π .env.example ‚Üí .env –∏ –∑–∞–ø–æ–ª–Ω–∏ —Ç–æ–∫–µ–Ω/–ë–î.
2) –ü–æ–¥–Ω–∏–º–∏ Postgres (–ª–æ–∫–∞–ª—å–Ω–æ –∏–ª–∏ —á–µ—Ä–µ–∑ Docker) –∏ —Å–æ–∑–¥–∞–π –ë–î valflow_diary.
3) python -m venv .venv && source .venv/bin/activate (Windows: `.venv\\Scripts\\activate`)
4) pip install -r requirements.txt
5) python -m app.main

## –ö–æ–º–∞–Ω–¥—ã –≤ –±–æ—Ç–µ
- /start ‚Äî –æ–Ω–±–æ—Ä–¥–∏–Ω–≥
- /journal ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞ –¥–ª—è –∑–∞–ø–∏—Å–∏
- /stats ‚Äî –∫—Ä–∞—Ç–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
- /remind ‚Äî –ø—Ä–∏–º–µ—Ä —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
- /premium ‚Äî —Å—Ç–∞—Ç—É—Å –ø—Ä–µ–º–∏—É–º–∞

## –î–∏–∑–∞–π–Ω —Ä–µ—à–µ–Ω–∏–π
- –¢–æ–ª—å–∫–æ 3 –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ (üåê Language / üîí Privacy / üõ† Report bug).
- –ü—Ä–µ–º–∏—É–º-–¥–µ–Ω—å –≤—ã–¥–∞—ë—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ—Å–ª–µ 2 –∑–∞–ø–∏—Å–µ–π + 1 –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è + –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ Telegram –∫–∞–Ω–∞–ª.
- –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –ë–î, —Ñ–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç due —Ä–∞–∑ –≤ 30—Å.
- i18n –ø—Ä–æ—Å—Ç–∞—è, JSON-—Ñ–∞–π–ª—ã.

## –ö—É–¥–∞ —Ä–∞–∑–≤–∏–≤–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ
- –≠–∫—Å–ø–æ—Ä—Ç PDF/CSV (–≤–∫–ª—é—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä PDF);
- –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä cron (¬´–∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 9:00¬ª ‚Üí `cron`);
- –ü–ª–∞—Ç–µ–∂–∏ Telegram Stars/Stripe;
- –í–µ–±-–¥–∞—à–±–æ—Ä–¥ (Next.js) —Å –≥—Ä–∞—Ñ–∏–∫–∞–º–∏ –∏ –ø–æ–∏—Å–∫–æ–º;
- –ü–æ–ª–∏—Ç–∏–∫–∞: –∫–Ω–æ–ø–∫–∞ ¬´–∫—Ä–∏–∑–∏—Å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã¬ª –ø—Ä–∏ —Ç—Ä–∏–≥–≥–µ—Ä–∞—Ö.
==========================================================================================
# requirements.txt
==========================================================================================
# –°–æ–≤–º–µ—Å—Ç–∏–º–æ —Å Python 3.13
aiogram>=3.13.0
SQLAlchemy>=2.0
asyncpg>=0.30
alembic>=1.13
pydantic>=2.10
pydantic-settings>=2.4
python-dotenv>=1.0.1
croniter>=2.0.5
dateparser>=1.2.0
orjson>=3.11

==========================================================================================
# scripts/dev.env
==========================================================================================
COMMERCE_CHECKOUT_URL=https://commerce.coinbase.com/checkout/5705c216-b37e-47b5-85dc-919a75e9fe09
PUBLIC_BASE_URL=https://ilda-comelier-pliantly.ngrok-free.dev
COINBASE_COMMERCE_WEBHOOK_SECRET=47870ee0-2bed-4aca-b21e-579d937f9e60
NOWP_API_KEY=QWMJHTA-TCZMKSY-NCXRV89-EPSSZ7R
NOWP_IPN_SECRET=eQBo37jPkSapbxGyUtjFyySe6S2EYsOm
NOWP_PRICE_USD=3.00
NOWP_BASE=https://api.nowpayments.io/v1
ENABLE_NOWPAYMENTS=1
ENABLE_COINBASE=0
SUB_PRICE_USD=10
TG_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
TELEGRAM_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8
BOT_TOKEN=8458105595:AAHOQTwXEsAB5rKed0obo5rs0KX-n1d4ig8

MONO_PRICE_UAH=12000

MONO_TOKEN=mwWTgxfdFSrx89aPw0jgRWQ

==========================================================================================
# scripts_msgfmt.py
==========================================================================================

import sys, struct, io, re
def parse_po(po_text:str):
    msgs = {}
    msgid = None
    msgstr = None
    lines = iter(po_text.splitlines())
    def unq(s): return bytes(s[1:-1], "utf-8").decode("unicode_escape")
    for line in lines:
        if line.startswith("msgid "):
            msgid = unq(line[5:].strip())
            cont=[]
            for l in lines:
                if l.startswith("msgstr "):
                    msgstr = unq(l[6:].strip()); break
                if l.startswith('"'): cont.append(unq(l.strip()))
                else: break
            if cont: msgid += "".join(cont)
            cont=[]
            for l in lines:
                if l.startswith('"'):
                    cont.append(unq(l.strip()))
                else:
                    msgs[msgid]=msgstr+("".join(cont) if cont else "")
                    msgid=None; msgstr=None
                    if l.startswith("msgid "):
                        msgid = unq(l[5:].strip()); cont=[]
                        for l2 in lines:
                            if l2.startswith("msgstr "):
                                msgstr = unq(l2[6:].strip()); break
                            if l2.startswith('"'): cont.append(unq(l2.strip()))
                            else: break
                        if cont: msgid += "".join(cont)
                        cont=[]
                        for l2 in lines:
                            if l2.startswith('"'): cont.append(unq(l2.strip()))
                            else:
                                msgs[msgid]=msgstr+("".join(cont) if cont else ""); msgid=None; msgstr=None
                                break
                    break
    if msgid is not None:
        msgs[msgid]=msgstr or ""
    return msgs
def write_mo(msgs, out):
    KEYS=list(msgs.keys())
    ids=b"\x00".join(s.encode("utf-8") for s in KEYS)+b"\x00"
    strs=b"\x00".join(msgs[k].encode("utf-8") for k in KEYS)+b"\x00"
    keystart=7*4+16*len(KEYS)
    valstart=keystart+len(ids)
    koffsets=[]; voffsets=[]
    off=0
    for k in KEYS:
        bts=k.encode("utf-8")+b"\x00"
        koffsets.append((len(bts)-1, keystart+off)); off+=len(bts)
    off=0
    for k in KEYS:
        bts=msgs[k].encode("utf-8")+b"\x00"
        voffsets.append((len(bts)-1, valstart+off)); off+=len(bts)
    out.write(struct.pack("Iiiiiii",0x950412de,0, len(KEYS), 7*4, 7*4+8*len(KEYS), 0,0))
    for ln,ofs in koffsets: out.write(struct.pack("II", ln, ofs))
    for ln,ofs in voffsets: out.write(struct.pack("II", ln, ofs))
    out.write(ids); out.write(strs)
def compile_po_to_mo(src, dst):
    text=open(src,"r",encoding="utf-8").read()
    msgs=parse_po(text)
    with open(dst,"wb") as f: write_mo(msgs,f)
if __name__=="__main__":
    compile_po_to_mo(sys.argv[1], sys.argv[2])

==========================================================================================
# storage/music/319145673/index.json
==========================================================================================
[
  {
    "file_id": "CQACAgIAAxkBAAICg2kouvl_Psh6gfS_k6AHFwABQ9KBIwACtIgAAm3BSUncuanNsOQ_vTYE",
    "title": "Hugo_Strasser_There_Is_A_House_The_House_Of_The_Rising_Sun_SkySound.mp3"
  }
]
==========================================================================================
# storage/music/377555215/index.json
==========================================================================================
[
  {
    "file_id": "CQACAgIAAxkBAAICcWkoucLVKGdv6oe7JAxdRRpfE7_GAAJpiAACxrtASepUrtnJvT0iNgQ",
    "title": "Enza - Ride It (Original Mix).mp3"
  }
]
==========================================================================================
# storage/music/6657238126/index.json
==========================================================================================
[
  {
    "file_id": "CQACAgIAAxkBAAICnGkovrxgZOeyQeLnK5uNBbyry4-cAAIKhgACY0pJST9uW44hJ3nrNgQ",
    "title": "d1n_mc-pochemu-odna-a-pochemu-grustish-a-pochemu-ty-ne-spish.mp3"
  }
]